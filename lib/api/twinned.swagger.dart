// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';
import 'dart:convert';

import 'package:chopper/chopper.dart';

import 'client_mapping.dart';
import 'dart:async';
import 'package:http/http.dart' as http;
import 'package:http/http.dart' show MultipartFile;
import 'package:chopper/chopper.dart' as chopper;
import 'twinned.enums.swagger.dart' as enums;
export 'twinned.enums.swagger.dart';

part 'twinned.swagger.chopper.dart';
part 'twinned.swagger.g.dart';

// **************************************************************************
// SwaggerChopperGenerator
// **************************************************************************

@ChopperApi()
abstract class Twinned extends ChopperService {
  static Twinned create({
    ChopperClient? client,
    http.Client? httpClient,
    Authenticator? authenticator,
    ErrorConverter? errorConverter,
    Converter? converter,
    Uri? baseUrl,
    Iterable<dynamic>? interceptors,
  }) {
    if (client != null) {
      return _$Twinned(client);
    }

    final newClient = ChopperClient(
        services: [_$Twinned()],
        converter: converter ?? $JsonSerializableConverter(),
        interceptors: interceptors ?? [],
        client: httpClient,
        authenticator: authenticator,
        errorConverter: errorConverter,
        baseUrl: baseUrl ?? Uri.parse('http://twinned.digital/rest/nocode'));
    return _$Twinned(newClient);
  }

  ///Cleanup entire data
  ///@param dropIndexes drop the entire data tables and recreate them
  Future<chopper.Response<BaseResponse>> cleanup({
    bool? dropIndexes,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        BaseResponse, () => BaseResponse.fromJsonFactory);

    return _cleanup(
        dropIndexes: dropIndexes?.toString(), apikey: apikey?.toString());
  }

  ///Cleanup entire data
  ///@param dropIndexes drop the entire data tables and recreate them
  @Delete(path: '/IoT/cleanup')
  Future<chopper.Response<BaseResponse>> _cleanup({
    @Header('dropIndexes') String? dropIndexes,
    @Header('APIKEY') String? apikey,
  });

  ///Cleanup entire data
  Future<chopper.Response<BaseResponse>> cleanupModels({dynamic apikey}) {
    generatedMapping.putIfAbsent(
        BaseResponse, () => BaseResponse.fromJsonFactory);

    return _cleanupModels(apikey: apikey?.toString());
  }

  ///Cleanup entire data
  @Delete(path: '/IoT/clear/models')
  Future<chopper.Response<BaseResponse>> _cleanupModels(
      {@Header('APIKEY') String? apikey});

  ///Cleanup entire data
  ///@param modelId provide this to delete only the data belongs to this model
  ///@param deviceId provide this to delete only the data belongs to this device
  Future<chopper.Response<BaseResponse>> cleanupData({
    String? modelId,
    String? deviceId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        BaseResponse, () => BaseResponse.fromJsonFactory);

    return _cleanupData(
        modelId: modelId?.toString(),
        deviceId: deviceId?.toString(),
        apikey: apikey?.toString());
  }

  ///Cleanup entire data
  ///@param modelId provide this to delete only the data belongs to this model
  ///@param deviceId provide this to delete only the data belongs to this device
  @Delete(path: '/IoT/clear/data')
  Future<chopper.Response<BaseResponse>> _cleanupData({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Header('APIKEY') String? apikey,
  });

  ///Get Twin Domain info
  ///@param orgId
  ///@param nocodeAuthToken
  Future<chopper.Response<TwinInfoRes>> getTwinDomainInfo({
    required String? orgId,
    String? nocodeAuthToken,
  }) {
    generatedMapping.putIfAbsent(
        TwinInfoRes, () => TwinInfoRes.fromJsonFactory);

    return _getTwinDomainInfo(
        orgId: orgId, nocodeAuthToken: nocodeAuthToken?.toString());
  }

  ///Get Twin Domain info
  ///@param orgId
  ///@param nocodeAuthToken
  @Get(path: '/IoT/twin/info/{orgId}')
  Future<chopper.Response<TwinInfoRes>> _getTwinDomainInfo({
    @Path('orgId') required String? orgId,
    @Header('nocodeAuthToken') String? nocodeAuthToken,
  });

  ///Create digital twin account
  ///@param nocodeAuthToken
  ///@param body
  Future<chopper.Response<TwinInfoRes>> createTwinDomain({
    String? nocodeAuthToken,
    required NoCodeInfo? body,
  }) {
    generatedMapping.putIfAbsent(NoCodeInfo, () => NoCodeInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TwinInfoRes, () => TwinInfoRes.fromJsonFactory);

    return _createTwinDomain(
        nocodeAuthToken: nocodeAuthToken?.toString(), body: body);
  }

  ///Create digital twin account
  ///@param nocodeAuthToken
  ///@param body
  @Post(path: '/IoT/twin/create')
  Future<chopper.Response<TwinInfoRes>> _createTwinDomain({
    @Header('nocodeAuthToken') String? nocodeAuthToken,
    @Body() required NoCodeInfo? body,
  });

  ///Create or update configuration
  ///@param body
  Future<chopper.Response<TwinSysConfigEntityRes>> upsertTwinConfig({
    required TwinSysInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinSysInfo, () => TwinSysInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TwinSysConfigEntityRes, () => TwinSysConfigEntityRes.fromJsonFactory);

    return _upsertTwinConfig(body: body, apikey: apikey?.toString());
  }

  ///Create or update configuration
  ///@param body
  @Post(path: '/IoT/twin/config/upsert')
  Future<chopper.Response<TwinSysConfigEntityRes>> _upsertTwinConfig({
    @Body() required TwinSysInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get Twin system information only with branding information
  ///@param domainKey
  Future<chopper.Response<TwinSysInfoEntityRes>> getTwinSysInfo(
      {required String? domainKey}) {
    generatedMapping.putIfAbsent(
        TwinSysInfoEntityRes, () => TwinSysInfoEntityRes.fromJsonFactory);

    return _getTwinSysInfo(domainKey: domainKey);
  }

  ///Get Twin system information only with branding information
  ///@param domainKey
  @Get(path: '/IoT/twin/info/get/{domainKey}')
  Future<chopper.Response<TwinSysInfoEntityRes>> _getTwinSysInfo(
      {@Path('domainKey') required String? domainKey});

  ///Get Twin system information along with other settings
  Future<chopper.Response<TwinSysInfoEntityRes>> getTwinSysConfig(
      {dynamic apikey}) {
    generatedMapping.putIfAbsent(
        TwinSysInfoEntityRes, () => TwinSysInfoEntityRes.fromJsonFactory);

    return _getTwinSysConfig(apikey: apikey?.toString());
  }

  ///Get Twin system information along with other settings
  @Get(path: '/IoT/twin/config/get')
  Future<chopper.Response<TwinSysInfoEntityRes>> _getTwinSysConfig(
      {@Header('APIKEY') String? apikey});

  ///Get tag list of an entity type
  ///@param entityType
  Future<chopper.Response<TagsRes>> getTags({
    required enums.IoTTwinTagsGetEntityTypeGetEntityType? entityType,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(TagsRes, () => TagsRes.fromJsonFactory);

    return _getTags(
        entityType: entityType?.value?.toString(), apikey: apikey?.toString());
  }

  ///Get tag list of an entity type
  ///@param entityType
  @Get(path: '/IoT/twin/tags/get/{entityType}')
  Future<chopper.Response<TagsRes>> _getTags({
    @Path('entityType') required String? entityType,
    @Header('APIKEY') String? apikey,
  });

  ///Get plan
  Future<chopper.Response<OrgPlanEntityRes>> getPlan({dynamic apikey}) {
    generatedMapping.putIfAbsent(
        OrgPlanEntityRes, () => OrgPlanEntityRes.fromJsonFactory);

    return _getPlan(apikey: apikey?.toString());
  }

  ///Get plan
  @Get(path: '/IoT/twin/plan/get')
  Future<chopper.Response<OrgPlanEntityRes>> _getPlan(
      {@Header('APIKEY') String? apikey});

  ///Reload plan
  Future<chopper.Response<BaseResponse>> reloadPlan({dynamic apikey}) {
    generatedMapping.putIfAbsent(
        BaseResponse, () => BaseResponse.fromJsonFactory);

    return _reloadPlan(apikey: apikey?.toString());
  }

  ///Reload plan
  @Get(path: '/IoT/twin/plan/reload')
  Future<chopper.Response<BaseResponse>> _reloadPlan(
      {@Header('APIKEY') String? apikey});

  ///Get usage
  Future<chopper.Response<UsageEntityRes>> getUsage({dynamic apikey}) {
    generatedMapping.putIfAbsent(
        UsageEntityRes, () => UsageEntityRes.fromJsonFactory);

    return _getUsage(apikey: apikey?.toString());
  }

  ///Get usage
  @Get(path: '/IoT/twin/usage/get')
  Future<chopper.Response<UsageEntityRes>> _getUsage(
      {@Header('APIKEY') String? apikey});

  ///Get the most recent data for this device
  ///@param deviceId
  ///@param isHardwareDevice
  Future<chopper.Response<DeviceDataEntityRes>> getDeviceData({
    required String? deviceId,
    bool? isHardwareDevice,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceDataEntityRes, () => DeviceDataEntityRes.fromJsonFactory);

    return _getDeviceData(
        deviceId: deviceId,
        isHardwareDevice: isHardwareDevice?.toString(),
        apikey: apikey?.toString());
  }

  ///Get the most recent data for this device
  ///@param deviceId
  ///@param isHardwareDevice
  @Get(path: '/DeviceData/get/{deviceId}')
  Future<chopper.Response<DeviceDataEntityRes>> _getDeviceData({
    @Path('deviceId') required String? deviceId,
    @Header('isHardwareDevice') String? isHardwareDevice,
    @Header('APIKEY') String? apikey,
  });

  ///Search recent device data
  ///@param modelId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetId
  ///@param filterByLocation
  ///@param body
  Future<chopper.Response<DeviceDataArrayRes>> searchRecentDeviceData({
    String? modelId,
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? assetId,
    bool? filterByLocation,
    required FilterSearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceDataArrayRes, () => DeviceDataArrayRes.fromJsonFactory);

    return _searchRecentDeviceData(
        modelId: modelId?.toString(),
        premiseId: premiseId?.toString(),
        facilityId: facilityId?.toString(),
        floorId: floorId?.toString(),
        assetId: assetId?.toString(),
        filterByLocation: filterByLocation?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search recent device data
  ///@param modelId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetId
  ///@param filterByLocation
  ///@param body
  @Post(path: '/DeviceData/recent')
  Future<chopper.Response<DeviceDataArrayRes>> _searchRecentDeviceData({
    @Header('modelId') String? modelId,
    @Header('premiseId') String? premiseId,
    @Header('facilityId') String? facilityId,
    @Header('floorId') String? floorId,
    @Header('assetId') String? assetId,
    @Header('filterByLocation') String? filterByLocation,
    @Body() required FilterSearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search device history data
  ///@param deviceId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetId
  ///@param filterByLocation
  ///@param body
  Future<chopper.Response<DeviceDataArrayRes>> searchDeviceHistoryData({
    String? deviceId,
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? assetId,
    bool? filterByLocation,
    required FilterSearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceDataArrayRes, () => DeviceDataArrayRes.fromJsonFactory);

    return _searchDeviceHistoryData(
        deviceId: deviceId?.toString(),
        premiseId: premiseId?.toString(),
        facilityId: facilityId?.toString(),
        floorId: floorId?.toString(),
        assetId: assetId?.toString(),
        filterByLocation: filterByLocation?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search device history data
  ///@param deviceId
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetId
  ///@param filterByLocation
  ///@param body
  @Post(path: '/DeviceData/history/search')
  Future<chopper.Response<DeviceDataArrayRes>> _searchDeviceHistoryData({
    @Header('deviceId') String? deviceId,
    @Header('premiseId') String? premiseId,
    @Header('facilityId') String? facilityId,
    @Header('floorId') String? floorId,
    @Header('assetId') String? assetId,
    @Header('filterByLocation') String? filterByLocation,
    @Body() required FilterSearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Remove history data record
  ///@param recordId
  Future<chopper.Response<DeviceDataEntityRes>> removeHistoryDataRecord({
    required String? recordId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceDataEntityRes, () => DeviceDataEntityRes.fromJsonFactory);

    return _removeHistoryDataRecord(
        recordId: recordId, apikey: apikey?.toString());
  }

  ///Remove history data record
  ///@param recordId
  @Delete(path: '/DeviceData/history/remove/{recordId}')
  Future<chopper.Response<DeviceDataEntityRes>> _removeHistoryDataRecord({
    @Path('recordId') required String? recordId,
    @Header('APIKEY') String? apikey,
  });

  ///Send device data
  ///@param hardwareDeviceId hardware device id
  ///@param body
  Future<chopper.Response<BaseResponse>> sendDeviceData({
    String? hardwareDeviceId,
    required Object? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        BaseResponse, () => BaseResponse.fromJsonFactory);

    return _sendDeviceData(
        hardwareDeviceId: hardwareDeviceId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Send device data
  ///@param hardwareDeviceId hardware device id
  ///@param body
  @Post(path: '/DeviceData/send')
  Future<chopper.Response<BaseResponse>> _sendDeviceData({
    @Header('hardwareDeviceId') String? hardwareDeviceId,
    @Body() required Object? body,
    @Header('APIKEY') String? apikey,
  });

  ///Send device data
  ///@param hardwareDeviceId hardware device id
  ///@param geocode do reverse geocoding
  ///@param lon longitude
  ///@param lat latitide
  ///@param body
  Future<chopper.Response<BaseResponse>> sendDeviceLocationData({
    String? hardwareDeviceId,
    bool? geocode,
    required num? lon,
    required num? lat,
    Object? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        BaseResponse, () => BaseResponse.fromJsonFactory);

    return _sendDeviceLocationData(
        hardwareDeviceId: hardwareDeviceId?.toString(),
        geocode: geocode?.toString(),
        lon: lon,
        lat: lat,
        body: body,
        apikey: apikey?.toString());
  }

  ///Send device data
  ///@param hardwareDeviceId hardware device id
  ///@param geocode do reverse geocoding
  ///@param lon longitude
  ///@param lat latitide
  ///@param body
  @Post(path: '/DeviceData/location/send/{lon}/{lat}')
  Future<chopper.Response<BaseResponse>> _sendDeviceLocationData({
    @Header('hardwareDeviceId') String? hardwareDeviceId,
    @Header('geocode') String? geocode,
    @Path('lon') required num? lon,
    @Path('lat') required num? lat,
    @Body() Object? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search triggered events
  ///@param modelId
  ///@param deviceId
  ///@param userId
  ///@param body
  Future<chopper.Response<TriggeredEventArrayRes>> seearchTriggeredEvents({
    String? modelId,
    String? deviceId,
    String? userId,
    required FilterSearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TriggeredEventArrayRes, () => TriggeredEventArrayRes.fromJsonFactory);

    return _seearchTriggeredEvents(
        modelId: modelId?.toString(),
        deviceId: deviceId?.toString(),
        userId: userId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search triggered events
  ///@param modelId
  ///@param deviceId
  ///@param userId
  ///@param body
  @Post(path: '/DeviceData/triggered/events/search')
  Future<chopper.Response<TriggeredEventArrayRes>> _seearchTriggeredEvents({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Header('userId') String? userId,
    @Body() required FilterSearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search triggered controls
  ///@param modelId
  ///@param deviceId
  ///@param body
  Future<chopper.Response<TriggeredControlArrayRes>> seearchTriggeredControls({
    String? modelId,
    String? deviceId,
    required FilterSearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(TriggeredControlArrayRes,
        () => TriggeredControlArrayRes.fromJsonFactory);

    return _seearchTriggeredControls(
        modelId: modelId?.toString(),
        deviceId: deviceId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search triggered controls
  ///@param modelId
  ///@param deviceId
  ///@param body
  @Post(path: '/DeviceData/triggered/controls/search')
  Future<chopper.Response<TriggeredControlArrayRes>> _seearchTriggeredControls({
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Body() required FilterSearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Cleanup entire data
  ///@param body
  Future<chopper.Response<BaseResponse>> cleanupDeviceData({
    required CleanReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(CleanReq, () => CleanReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        BaseResponse, () => BaseResponse.fromJsonFactory);

    return _cleanupDeviceData(body: body, apikey: apikey?.toString());
  }

  ///Cleanup entire data
  ///@param body
  @Post(path: '/DeviceData/cleanup')
  Future<chopper.Response<BaseResponse>> _cleanupDeviceData({
    @Body() required CleanReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Cleanup entire data
  ///@param deviceId
  ///@param field
  ///@param filter
  ///@param interval
  ///@param beginStamp required if filter is set
  ///@param endStamp required if filter is set
  ///@param tz Timezone
  Future<chopper.Response<TrendValueArrayRes>> getDeviceTrends({
    required String? deviceId,
    required String? field,
    enums.DeviceDataTrendsDeviceIdFieldGetFilter? filter,
    enums.DeviceDataTrendsDeviceIdFieldGetInterval? interval,
    int? beginStamp,
    int? endStamp,
    String? tz,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TrendValueArrayRes, () => TrendValueArrayRes.fromJsonFactory);

    return _getDeviceTrends(
        deviceId: deviceId,
        field: field,
        filter: filter?.value?.toString(),
        interval: interval?.value?.toString(),
        beginStamp: beginStamp,
        endStamp: endStamp,
        tz: tz,
        apikey: apikey?.toString());
  }

  ///Cleanup entire data
  ///@param deviceId
  ///@param field
  ///@param filter
  ///@param interval
  ///@param beginStamp required if filter is set
  ///@param endStamp required if filter is set
  ///@param tz Timezone
  @Get(path: '/DeviceData/trends/{deviceId}/{field}')
  Future<chopper.Response<TrendValueArrayRes>> _getDeviceTrends({
    @Path('deviceId') required String? deviceId,
    @Path('field') required String? field,
    @Query('filter') String? filter,
    @Query('interval') String? interval,
    @Query('beginStamp') int? beginStamp,
    @Query('endStamp') int? endStamp,
    @Query('tz') String? tz,
    @Header('APIKEY') String? apikey,
  });

  ///Cleanup entire data
  ///@param deviceId
  ///@param field
  ///@param page
  ///@param size
  ///@param filter
  ///@param beginStamp required if filter is set
  ///@param endStamp required if filter is set
  ///@param tz Timezone
  Future<chopper.Response<TimeSeriesValueArrayRes>> getDeviceTimeSeries({
    required String? deviceId,
    required String? field,
    required int? page,
    required int? size,
    enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter? filter,
    int? beginStamp,
    int? endStamp,
    String? tz,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TimeSeriesValueArrayRes, () => TimeSeriesValueArrayRes.fromJsonFactory);

    return _getDeviceTimeSeries(
        deviceId: deviceId,
        field: field,
        page: page,
        size: size,
        filter: filter?.value?.toString(),
        beginStamp: beginStamp,
        endStamp: endStamp,
        tz: tz,
        apikey: apikey?.toString());
  }

  ///Cleanup entire data
  ///@param deviceId
  ///@param field
  ///@param page
  ///@param size
  ///@param filter
  ///@param beginStamp required if filter is set
  ///@param endStamp required if filter is set
  ///@param tz Timezone
  @Get(path: '/DeviceData/series/{deviceId}/{field}/{page}/{size}')
  Future<chopper.Response<TimeSeriesValueArrayRes>> _getDeviceTimeSeries({
    @Path('deviceId') required String? deviceId,
    @Path('field') required String? field,
    @Path('page') required int? page,
    @Path('size') required int? size,
    @Query('filter') String? filter,
    @Query('beginStamp') int? beginStamp,
    @Query('endStamp') int? endStamp,
    @Query('tz') String? tz,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<DeviceDataArrayRes>> searchEqlDeviceData({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceDataArrayRes, () => DeviceDataArrayRes.fromJsonFactory);

    return _searchEqlDeviceData(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/DeviceData/eql')
  Future<chopper.Response<DeviceDataArrayRes>> _searchEqlDeviceData({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Filter recent device data
  ///@param page
  ///@param size
  ///@param filterId
  Future<chopper.Response<DeviceDataArrayRes>> filterRecentDeviceData({
    int? page,
    int? size,
    required String? filterId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceDataArrayRes, () => DeviceDataArrayRes.fromJsonFactory);

    return _filterRecentDeviceData(
        page: page?.toString(),
        size: size?.toString(),
        filterId: filterId,
        apikey: apikey?.toString());
  }

  ///Filter recent device data
  ///@param page
  ///@param size
  ///@param filterId
  @Get(path: '/DeviceData/filter/{filterId}')
  Future<chopper.Response<DeviceDataArrayRes>> _filterRecentDeviceData({
    @Header('page') String? page,
    @Header('size') String? size,
    @Path('filterId') required String? filterId,
    @Header('APIKEY') String? apikey,
  });

  ///Get reported asset ids
  ///@param size
  Future<chopper.Response<IDListEntityRes>> getReportedAssetIds({
    required int? size,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        IDListEntityRes, () => IDListEntityRes.fromJsonFactory);

    return _getReportedAssetIds(size: size, apikey: apikey?.toString());
  }

  ///Get reported asset ids
  ///@param size
  @Get(path: '/DeviceData/reported/assets/{size}')
  Future<chopper.Response<IDListEntityRes>> _getReportedAssetIds({
    @Path('size') required int? size,
    @Header('APIKEY') String? apikey,
  });

  ///Search reported assets
  ///@param search
  Future<chopper.Response<IDListEntityRes>> searchReportedAssets({
    required SearchReq? search,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        IDListEntityRes, () => IDListEntityRes.fromJsonFactory);

    return _searchReportedAssets(search: search, apikey: apikey?.toString());
  }

  ///Search reported assets
  ///@param search
  @Post(path: '/DeviceData/search/reported/assets')
  Future<chopper.Response<IDListEntityRes>> _searchReportedAssets({
    @Body() required SearchReq? search,
    @Header('APIKEY') String? apikey,
  });

  ///Field filter recent device data
  ///@param page
  ///@param size
  ///@param fieldFilterId
  Future<chopper.Response<DeviceDataArrayRes>> fieldFilterRecentDeviceData({
    int? page,
    int? size,
    required String? fieldFilterId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceDataArrayRes, () => DeviceDataArrayRes.fromJsonFactory);

    return _fieldFilterRecentDeviceData(
        page: page?.toString(),
        size: size?.toString(),
        fieldFilterId: fieldFilterId,
        apikey: apikey?.toString());
  }

  ///Field filter recent device data
  ///@param page
  ///@param size
  ///@param fieldFilterId
  @Get(path: '/DeviceData/field/filter/{fieldFilterId}')
  Future<chopper.Response<DeviceDataArrayRes>> _fieldFilterRecentDeviceData({
    @Header('page') String? page,
    @Header('size') String? size,
    @Path('fieldFilterId') required String? fieldFilterId,
    @Header('APIKEY') String? apikey,
  });

  ///query data
  ///@param body
  Future<chopper.Response<QueryRes>> queryDeviceData({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDeviceData(body: body, apikey: apikey?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/DeviceData/query')
  Future<chopper.Response<QueryRes>> _queryDeviceData({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///query history data
  ///@param body
  Future<chopper.Response<QueryRes>> queryDeviceHistoryData({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryDeviceHistoryData(body: body, apikey: apikey?.toString());
  }

  ///query history data
  ///@param body
  @Post(path: '/DeviceData/history/query')
  Future<chopper.Response<QueryRes>> _queryDeviceHistoryData({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///count by query
  ///@param body
  Future<chopper.Response<CountRes>> queryCountDeviceData({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _queryCountDeviceData(body: body, apikey: apikey?.toString());
  }

  ///count by query
  ///@param body
  @Post(path: '/DeviceData/count/query')
  Future<chopper.Response<CountRes>> _queryCountDeviceData({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///county history by query
  ///@param body
  Future<chopper.Response<CountRes>> queryCountHistoryDeviceData({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _queryCountHistoryDeviceData(body: body, apikey: apikey?.toString());
  }

  ///county history by query
  ///@param body
  @Post(path: '/DeviceData/count/history/query')
  Future<chopper.Response<CountRes>> _queryCountHistoryDeviceData({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///query data
  ///@param body
  Future<chopper.Response<DeviceDataArrayRes>> queryEqlDeviceData({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceDataArrayRes, () => DeviceDataArrayRes.fromJsonFactory);

    return _queryEqlDeviceData(body: body, apikey: apikey?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/DeviceData/query/eql')
  Future<chopper.Response<DeviceDataArrayRes>> _queryEqlDeviceData({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///query data
  ///@param body
  Future<chopper.Response<DeviceDataArrayRes>> queryEqlDeviceHistoryData({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceDataArrayRes, () => DeviceDataArrayRes.fromJsonFactory);

    return _queryEqlDeviceHistoryData(body: body, apikey: apikey?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/DeviceData/history/query/eql')
  Future<chopper.Response<DeviceDataArrayRes>> _queryEqlDeviceHistoryData({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///Create device view
  ///@param body
  Future<chopper.Response<DeviceViewEntityRes>> createDeviceView({
    required DeviceViewInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceViewInfo, () => DeviceViewInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceViewEntityRes, () => DeviceViewEntityRes.fromJsonFactory);

    return _createDeviceView(body: body, apikey: apikey?.toString());
  }

  ///Create device view
  ///@param body
  @Post(path: '/DeviceView/create')
  Future<chopper.Response<DeviceViewEntityRes>> _createDeviceView({
    @Body() required DeviceViewInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update device view
  ///@param deviceViewId
  ///@param body
  Future<chopper.Response<DeviceViewEntityRes>> updateDeviceView({
    String? deviceViewId,
    required DeviceViewInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceViewInfo, () => DeviceViewInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceViewEntityRes, () => DeviceViewEntityRes.fromJsonFactory);

    return _updateDeviceView(
        deviceViewId: deviceViewId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update device view
  ///@param deviceViewId
  ///@param body
  @Post(path: '/DeviceView/update')
  Future<chopper.Response<DeviceViewEntityRes>> _updateDeviceView({
    @Header('deviceViewId') String? deviceViewId,
    @Body() required DeviceViewInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete device view
  ///@param deviceViewId
  Future<chopper.Response<DeviceViewEntityRes>> deleteDeviceView({
    String? deviceViewId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceViewEntityRes, () => DeviceViewEntityRes.fromJsonFactory);

    return _deleteDeviceView(
        deviceViewId: deviceViewId?.toString(), apikey: apikey?.toString());
  }

  ///Delete device view
  ///@param deviceViewId
  @Delete(path: '/DeviceView/remove')
  Future<chopper.Response<DeviceViewEntityRes>> _deleteDeviceView({
    @Header('deviceViewId') String? deviceViewId,
    @Header('APIKEY') String? apikey,
  });

  ///List device views
  ///@param modelId
  ///@param body
  Future<chopper.Response<DeviceViewArrayRes>> listDeviceViews({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceViewArrayRes, () => DeviceViewArrayRes.fromJsonFactory);

    return _listDeviceViews(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List device views
  ///@param modelId
  ///@param body
  @Post(path: '/DeviceView/list')
  Future<chopper.Response<DeviceViewArrayRes>> _listDeviceViews({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search device views
  ///@param modelId
  ///@param body
  Future<chopper.Response<DeviceViewArrayRes>> searchDeviceViews({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceViewArrayRes, () => DeviceViewArrayRes.fromJsonFactory);

    return _searchDeviceViews(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search device views
  ///@param modelId
  ///@param body
  @Post(path: '/DeviceView/search')
  Future<chopper.Response<DeviceViewArrayRes>> _searchDeviceViews({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get device views
  ///@param body
  Future<chopper.Response<DeviceViewArrayRes>> getDeviceViews({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceViewArrayRes, () => DeviceViewArrayRes.fromJsonFactory);

    return _getDeviceViews(body: body, apikey: apikey?.toString());
  }

  ///Get device views
  ///@param body
  @Post(path: '/DeviceView/get')
  Future<chopper.Response<DeviceViewArrayRes>> _getDeviceViews({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get device view by id
  ///@param deviceViewId
  Future<chopper.Response<DeviceViewEntityRes>> getDeviceView({
    required String? deviceViewId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceViewEntityRes, () => DeviceViewEntityRes.fromJsonFactory);

    return _getDeviceView(
        deviceViewId: deviceViewId, apikey: apikey?.toString());
  }

  ///get device view by id
  ///@param deviceViewId
  @Get(path: '/DeviceView/one/{deviceViewId}')
  Future<chopper.Response<DeviceViewEntityRes>> _getDeviceView({
    @Path('deviceViewId') required String? deviceViewId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using EQL
  ///@param eql
  Future<chopper.Response<DeviceViewArrayRes>> searchEqlDeviceView({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceViewArrayRes, () => DeviceViewArrayRes.fromJsonFactory);

    return _searchEqlDeviceView(eql: eql, apikey: apikey?.toString());
  }

  ///Search using EQL
  ///@param eql
  @Post(path: '/DeviceView/eql')
  Future<chopper.Response<DeviceViewArrayRes>> _searchEqlDeviceView({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create dashboard screen
  ///@param body
  Future<chopper.Response<DashboardScreenEntityRes>> createDashboardScreen({
    required DashboardScreenInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DashboardScreenInfo, () => DashboardScreenInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(DashboardScreenEntityRes,
        () => DashboardScreenEntityRes.fromJsonFactory);

    return _createDashboardScreen(body: body, apikey: apikey?.toString());
  }

  ///Create dashboard screen
  ///@param body
  @Post(path: '/DashboardScreen/create')
  Future<chopper.Response<DashboardScreenEntityRes>> _createDashboardScreen({
    @Body() required DashboardScreenInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update dashboard screen
  ///@param screenId
  ///@param body
  Future<chopper.Response<DashboardScreenEntityRes>> updateDashboardScreen({
    String? screenId,
    required DashboardScreenInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DashboardScreenInfo, () => DashboardScreenInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(DashboardScreenEntityRes,
        () => DashboardScreenEntityRes.fromJsonFactory);

    return _updateDashboardScreen(
        screenId: screenId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update dashboard screen
  ///@param screenId
  ///@param body
  @Post(path: '/DashboardScreen/update')
  Future<chopper.Response<DashboardScreenEntityRes>> _updateDashboardScreen({
    @Header('screenId') String? screenId,
    @Body() required DashboardScreenInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete dashboard screen
  ///@param screenId
  Future<chopper.Response<DashboardScreenEntityRes>> deleteDashboardScreen({
    String? screenId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(DashboardScreenEntityRes,
        () => DashboardScreenEntityRes.fromJsonFactory);

    return _deleteDashboardScreen(
        screenId: screenId?.toString(), apikey: apikey?.toString());
  }

  ///Delete dashboard screen
  ///@param screenId
  @Delete(path: '/DashboardScreen/remove')
  Future<chopper.Response<DashboardScreenEntityRes>> _deleteDashboardScreen({
    @Header('screenId') String? screenId,
    @Header('APIKEY') String? apikey,
  });

  ///List dashboard screens
  ///@param modelId
  ///@param body
  Future<chopper.Response<DashboardScreenArrayRes>> listDashboardScreens({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DashboardScreenArrayRes, () => DashboardScreenArrayRes.fromJsonFactory);

    return _listDashboardScreens(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List dashboard screens
  ///@param modelId
  ///@param body
  @Post(path: '/DashboardScreen/list')
  Future<chopper.Response<DashboardScreenArrayRes>> _listDashboardScreens({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search dashboard screens
  ///@param modelId
  ///@param body
  Future<chopper.Response<DashboardScreenArrayRes>> searchDashboardScreens({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DashboardScreenArrayRes, () => DashboardScreenArrayRes.fromJsonFactory);

    return _searchDashboardScreens(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search dashboard screens
  ///@param modelId
  ///@param body
  @Post(path: '/DashboardScreen/search')
  Future<chopper.Response<DashboardScreenArrayRes>> _searchDashboardScreens({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get dashboard screens
  ///@param body
  Future<chopper.Response<DashboardScreenArrayRes>> getDashboardScreens({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DashboardScreenArrayRes, () => DashboardScreenArrayRes.fromJsonFactory);

    return _getDashboardScreens(body: body, apikey: apikey?.toString());
  }

  ///Get dashboard screens
  ///@param body
  @Post(path: '/DashboardScreen/get')
  Future<chopper.Response<DashboardScreenArrayRes>> _getDashboardScreens({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get dashboard screen by id
  ///@param screenId
  Future<chopper.Response<DashboardScreenEntityRes>> getDashboardScreen({
    required String? screenId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(DashboardScreenEntityRes,
        () => DashboardScreenEntityRes.fromJsonFactory);

    return _getDashboardScreen(screenId: screenId, apikey: apikey?.toString());
  }

  ///get dashboard screen by id
  ///@param screenId
  @Get(path: '/DashboardScreen/one/{screenId}')
  Future<chopper.Response<DashboardScreenEntityRes>> _getDashboardScreen({
    @Path('screenId') required String? screenId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<DashboardScreenArrayRes>> searchEqlDashboardScreen({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DashboardScreenArrayRes, () => DashboardScreenArrayRes.fromJsonFactory);

    return _searchEqlDashboardScreen(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/DashboardScreen/eql')
  Future<chopper.Response<DashboardScreenArrayRes>> _searchEqlDashboardScreen({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///count
  Future<chopper.Response<CountRes>> countDashboards({dynamic apikey}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countDashboards(apikey: apikey?.toString());
  }

  ///count
  @Get(path: '/DashboardScreen/count')
  Future<chopper.Response<CountRes>> _countDashboards(
      {@Header('APIKEY') String? apikey});

  ///Create dashboard menu
  ///@param body
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
      createDashboardMenuGroup({
    required DashboardMenuGroupInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DashboardMenuGroupInfo, () => DashboardMenuGroupInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(DashboardMenuGroupEntityRes,
        () => DashboardMenuGroupEntityRes.fromJsonFactory);

    return _createDashboardMenuGroup(body: body, apikey: apikey?.toString());
  }

  ///Create dashboard menu
  ///@param body
  @Post(path: '/DashboardMenu/create')
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
      _createDashboardMenuGroup({
    @Body() required DashboardMenuGroupInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update dashboard menu
  ///@param menuGroupId
  ///@param body
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
      updateDashboardMenuGroup({
    String? menuGroupId,
    required DashboardMenuGroupInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DashboardMenuGroupInfo, () => DashboardMenuGroupInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(DashboardMenuGroupEntityRes,
        () => DashboardMenuGroupEntityRes.fromJsonFactory);

    return _updateDashboardMenuGroup(
        menuGroupId: menuGroupId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update dashboard menu
  ///@param menuGroupId
  ///@param body
  @Post(path: '/DashboardMenu/update')
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
      _updateDashboardMenuGroup({
    @Header('menuGroupId') String? menuGroupId,
    @Body() required DashboardMenuGroupInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete dashboard menu
  ///@param menuGroupId
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
      deleteDashboardMenuGroup({
    String? menuGroupId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(DashboardMenuGroupEntityRes,
        () => DashboardMenuGroupEntityRes.fromJsonFactory);

    return _deleteDashboardMenuGroup(
        menuGroupId: menuGroupId?.toString(), apikey: apikey?.toString());
  }

  ///Delete dashboard menu
  ///@param menuGroupId
  @Delete(path: '/DashboardMenu/remove')
  Future<chopper.Response<DashboardMenuGroupEntityRes>>
      _deleteDashboardMenuGroup({
    @Header('menuGroupId') String? menuGroupId,
    @Header('APIKEY') String? apikey,
  });

  ///List dashboard menus
  ///@param modelId
  ///@param body
  Future<chopper.Response<DashboardMenuGroupArrayRes>> listDashboardMenuGroups({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(DashboardMenuGroupArrayRes,
        () => DashboardMenuGroupArrayRes.fromJsonFactory);

    return _listDashboardMenuGroups(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List dashboard menus
  ///@param modelId
  ///@param body
  @Post(path: '/DashboardMenu/list')
  Future<chopper.Response<DashboardMenuGroupArrayRes>>
      _listDashboardMenuGroups({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search dashboard menus
  ///@param body
  Future<chopper.Response<DashboardMenuGroupArrayRes>>
      searchDashboardMenuGroups({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(DashboardMenuGroupArrayRes,
        () => DashboardMenuGroupArrayRes.fromJsonFactory);

    return _searchDashboardMenuGroups(body: body, apikey: apikey?.toString());
  }

  ///Search dashboard menus
  ///@param body
  @Post(path: '/DashboardMenu/search')
  Future<chopper.Response<DashboardMenuGroupArrayRes>>
      _searchDashboardMenuGroups({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get dashboard menus
  ///@param body
  Future<chopper.Response<DashboardMenuGroupArrayRes>> getDashboardMenuGroups({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(DashboardMenuGroupArrayRes,
        () => DashboardMenuGroupArrayRes.fromJsonFactory);

    return _getDashboardMenuGroups(body: body, apikey: apikey?.toString());
  }

  ///Get dashboard menus
  ///@param body
  @Post(path: '/DashboardMenu/get')
  Future<chopper.Response<DashboardMenuGroupArrayRes>> _getDashboardMenuGroups({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get dashboard menu by id
  ///@param menuGroupId
  Future<chopper.Response<DashboardMenuGroupEntityRes>> getDashboardMenuGroup({
    required String? menuGroupId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(DashboardMenuGroupEntityRes,
        () => DashboardMenuGroupEntityRes.fromJsonFactory);

    return _getDashboardMenuGroup(
        menuGroupId: menuGroupId, apikey: apikey?.toString());
  }

  ///get dashboard menu by id
  ///@param menuGroupId
  @Get(path: '/DashboardMenu/one/{menuGroupId}')
  Future<chopper.Response<DashboardMenuGroupEntityRes>> _getDashboardMenuGroup({
    @Path('menuGroupId') required String? menuGroupId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<DashboardMenuGroupArrayRes>> searchEqlDashboardMenu({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(DashboardMenuGroupArrayRes,
        () => DashboardMenuGroupArrayRes.fromJsonFactory);

    return _searchEqlDashboardMenu(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/DashboardMenu/eql')
  Future<chopper.Response<DashboardMenuGroupArrayRes>> _searchEqlDashboardMenu({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create event registration
  ///@param body
  Future<chopper.Response<EventRegistrationEntityRes>> createEventRegistration({
    required EventRegistrationInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        EventRegistrationInfo, () => EventRegistrationInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(EventRegistrationEntityRes,
        () => EventRegistrationEntityRes.fromJsonFactory);

    return _createEventRegistration(body: body, apikey: apikey?.toString());
  }

  ///Create event registration
  ///@param body
  @Post(path: '/EventRegistration/create')
  Future<chopper.Response<EventRegistrationEntityRes>>
      _createEventRegistration({
    @Body() required EventRegistrationInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update event registration
  ///@param eventRegistrationId
  ///@param body
  Future<chopper.Response<EventRegistrationEntityRes>> updateEventRegistration({
    String? eventRegistrationId,
    required EventRegistrationInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        EventRegistrationInfo, () => EventRegistrationInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(EventRegistrationEntityRes,
        () => EventRegistrationEntityRes.fromJsonFactory);

    return _updateEventRegistration(
        eventRegistrationId: eventRegistrationId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update event registration
  ///@param eventRegistrationId
  ///@param body
  @Post(path: '/EventRegistration/update')
  Future<chopper.Response<EventRegistrationEntityRes>>
      _updateEventRegistration({
    @Header('eventRegistrationId') String? eventRegistrationId,
    @Body() required EventRegistrationInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete event registration
  ///@param eventRegistrationId
  Future<chopper.Response<EventRegistrationEntityRes>> deleteEventRegistration({
    String? eventRegistrationId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EventRegistrationEntityRes,
        () => EventRegistrationEntityRes.fromJsonFactory);

    return _deleteEventRegistration(
        eventRegistrationId: eventRegistrationId?.toString(),
        apikey: apikey?.toString());
  }

  ///Delete event registration
  ///@param eventRegistrationId
  @Delete(path: '/EventRegistration/remove')
  Future<chopper.Response<EventRegistrationEntityRes>>
      _deleteEventRegistration({
    @Header('eventRegistrationId') String? eventRegistrationId,
    @Header('APIKEY') String? apikey,
  });

  ///List event registrations
  ///@param body
  Future<chopper.Response<EventRegistrationArrayRes>> listEventRegistrations({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(EventRegistrationArrayRes,
        () => EventRegistrationArrayRes.fromJsonFactory);

    return _listEventRegistrations(body: body, apikey: apikey?.toString());
  }

  ///List event registrations
  ///@param body
  @Post(path: '/EventRegistration/list')
  Future<chopper.Response<EventRegistrationArrayRes>> _listEventRegistrations({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<EventRegistrationArrayRes>>
      searchEqlEventRegistration({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EventRegistrationArrayRes,
        () => EventRegistrationArrayRes.fromJsonFactory);

    return _searchEqlEventRegistration(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/EventRegistration/eql')
  Future<chopper.Response<EventRegistrationArrayRes>>
      _searchEqlEventRegistration({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create device model
  ///@param body
  Future<chopper.Response<DeviceModelEntityRes>> createDeviceModel({
    required DeviceModelInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceModelInfo, () => DeviceModelInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceModelEntityRes, () => DeviceModelEntityRes.fromJsonFactory);

    return _createDeviceModel(body: body, apikey: apikey?.toString());
  }

  ///Create device model
  ///@param body
  @Post(path: '/DeviceModel/create')
  Future<chopper.Response<DeviceModelEntityRes>> _createDeviceModel({
    @Body() required DeviceModelInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update device model
  ///@param modelId
  ///@param body
  Future<chopper.Response<DeviceModelEntityRes>> updateDeviceModel({
    String? modelId,
    required DeviceModelInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceModelInfo, () => DeviceModelInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceModelEntityRes, () => DeviceModelEntityRes.fromJsonFactory);

    return _updateDeviceModel(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update device model
  ///@param modelId
  ///@param body
  @Post(path: '/DeviceModel/update')
  Future<chopper.Response<DeviceModelEntityRes>> _updateDeviceModel({
    @Header('modelId') String? modelId,
    @Body() required DeviceModelInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete device model
  ///@param modelId
  Future<chopper.Response<DeviceModelEntityRes>> deleteDeviceModel({
    String? modelId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceModelEntityRes, () => DeviceModelEntityRes.fromJsonFactory);

    return _deleteDeviceModel(
        modelId: modelId?.toString(), apikey: apikey?.toString());
  }

  ///Delete device model
  ///@param modelId
  @Delete(path: '/DeviceModel/remove')
  Future<chopper.Response<DeviceModelEntityRes>> _deleteDeviceModel({
    @Header('modelId') String? modelId,
    @Header('APIKEY') String? apikey,
  });

  ///List device models
  ///@param body
  Future<chopper.Response<DeviceModelArrayRes>> listDeviceModels({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceModelArrayRes, () => DeviceModelArrayRes.fromJsonFactory);

    return _listDeviceModels(body: body, apikey: apikey?.toString());
  }

  ///List device models
  ///@param body
  @Post(path: '/DeviceModel/list')
  Future<chopper.Response<DeviceModelArrayRes>> _listDeviceModels({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search device models
  ///@param body
  Future<chopper.Response<DeviceModelArrayRes>> searchDeviceModels({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceModelArrayRes, () => DeviceModelArrayRes.fromJsonFactory);

    return _searchDeviceModels(body: body, apikey: apikey?.toString());
  }

  ///Search device models
  ///@param body
  @Post(path: '/DeviceModel/search')
  Future<chopper.Response<DeviceModelArrayRes>> _searchDeviceModels({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get device models by list of id's
  ///@param body
  Future<chopper.Response<DeviceModelArrayRes>> getDeviceModels({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceModelArrayRes, () => DeviceModelArrayRes.fromJsonFactory);

    return _getDeviceModels(body: body, apikey: apikey?.toString());
  }

  ///get device models by list of id's
  ///@param body
  @Post(path: '/DeviceModel/get')
  Future<chopper.Response<DeviceModelArrayRes>> _getDeviceModels({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get device models by id
  ///@param modelId
  Future<chopper.Response<DeviceModelEntityRes>> getDeviceModel({
    required String? modelId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceModelEntityRes, () => DeviceModelEntityRes.fromJsonFactory);

    return _getDeviceModel(modelId: modelId, apikey: apikey?.toString());
  }

  ///get device models by id
  ///@param modelId
  @Get(path: '/DeviceModel/one/{modelId}')
  Future<chopper.Response<DeviceModelEntityRes>> _getDeviceModel({
    @Path('modelId') required String? modelId,
    @Header('APIKEY') String? apikey,
  });

  ///export device model
  ///@param modelId device model id
  Future<chopper.Response<List<int>>> exportDeviceModel(
      {required String? modelId}) {
    return _exportDeviceModel(modelId: modelId);
  }

  ///export device model
  ///@param modelId device model id
  @Get(path: '/DeviceModel/export/{modelId}')
  Future<chopper.Response<List<int>>> _exportDeviceModel(
      {@Path('modelId') required String? modelId});

  ///import device model exported data
  ///@param file
  Future<chopper.Response<BaseResponse>> importDeviceModel({
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        BaseResponse, () => BaseResponse.fromJsonFactory);

    return _importDeviceModel(file: file, apikey: apikey?.toString());
  }

  ///import device model exported data
  ///@param file
  @Post(
    path: '/DeviceModel/import',
    optionalBody: true,
  )
  Future<chopper.Response<BaseResponse>> _importDeviceModel({
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<DeviceModelArrayRes>> searchEqlDeviceModel({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceModelArrayRes, () => DeviceModelArrayRes.fromJsonFactory);

    return _searchEqlDeviceModel(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/DeviceModel/eql')
  Future<chopper.Response<DeviceModelArrayRes>> _searchEqlDeviceModel({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///list all device model's parameters
  ///@param modelId
  Future<chopper.Response<ParameterArrayRes>> listAllParameters({
    String? modelId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ParameterArrayRes, () => ParameterArrayRes.fromJsonFactory);

    return _listAllParameters(
        modelId: modelId?.toString(), apikey: apikey?.toString());
  }

  ///list all device model's parameters
  ///@param modelId
  @Get(path: '/DeviceModel/param/list')
  Future<chopper.Response<ParameterArrayRes>> _listAllParameters({
    @Header('modelId') String? modelId,
    @Header('APIKEY') String? apikey,
  });

  ///count
  Future<chopper.Response<CountRes>> countDeviceModels({dynamic apikey}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countDeviceModels(apikey: apikey?.toString());
  }

  ///count
  @Get(path: '/DeviceModel/count')
  Future<chopper.Response<CountRes>> _countDeviceModels(
      {@Header('APIKEY') String? apikey});

  ///get parameter units
  Future<chopper.Response<ParameterUnitsEntityRes>> getParameterUnits(
      {dynamic apikey}) {
    generatedMapping.putIfAbsent(
        ParameterUnitsEntityRes, () => ParameterUnitsEntityRes.fromJsonFactory);

    return _getParameterUnits(apikey: apikey?.toString());
  }

  ///get parameter units
  @Get(path: '/DeviceModel/param/units')
  Future<chopper.Response<ParameterUnitsEntityRes>> _getParameterUnits(
      {@Header('APIKEY') String? apikey});

  ///Create device
  ///@param body
  Future<chopper.Response<DeviceEntityRes>> createDevice({
    required DeviceInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(DeviceInfo, () => DeviceInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceEntityRes, () => DeviceEntityRes.fromJsonFactory);

    return _createDevice(body: body, apikey: apikey?.toString());
  }

  ///Create device
  ///@param body
  @Post(path: '/Device/create')
  Future<chopper.Response<DeviceEntityRes>> _createDevice({
    @Body() required DeviceInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update device
  ///@param deviceId
  ///@param body
  Future<chopper.Response<DeviceEntityRes>> updateDevice({
    String? deviceId,
    required DeviceInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(DeviceInfo, () => DeviceInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceEntityRes, () => DeviceEntityRes.fromJsonFactory);

    return _updateDevice(
        deviceId: deviceId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update device
  ///@param deviceId
  ///@param body
  @Post(path: '/Device/update')
  Future<chopper.Response<DeviceEntityRes>> _updateDevice({
    @Header('deviceId') String? deviceId,
    @Body() required DeviceInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete device
  ///@param deviceId
  Future<chopper.Response<DeviceEntityRes>> deleteDevice({
    String? deviceId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceEntityRes, () => DeviceEntityRes.fromJsonFactory);

    return _deleteDevice(
        deviceId: deviceId?.toString(), apikey: apikey?.toString());
  }

  ///Delete device
  ///@param deviceId
  @Delete(path: '/Device/remove')
  Future<chopper.Response<DeviceEntityRes>> _deleteDevice({
    @Header('deviceId') String? deviceId,
    @Header('APIKEY') String? apikey,
  });

  ///List devices
  ///@param modelId
  ///@param body
  Future<chopper.Response<DeviceArrayRes>> listDevices({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceArrayRes, () => DeviceArrayRes.fromJsonFactory);

    return _listDevices(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List devices
  ///@param modelId
  ///@param body
  @Post(path: '/Device/list')
  Future<chopper.Response<DeviceArrayRes>> _listDevices({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search devices
  ///@param modelId
  ///@param assetId
  ///@param floorId
  ///@param facilityId
  ///@param premiseId
  ///@param body
  Future<chopper.Response<DeviceArrayRes>> searchDevices({
    String? modelId,
    String? assetId,
    String? floorId,
    String? facilityId,
    String? premiseId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceArrayRes, () => DeviceArrayRes.fromJsonFactory);

    return _searchDevices(
        modelId: modelId?.toString(),
        assetId: assetId?.toString(),
        floorId: floorId?.toString(),
        facilityId: facilityId?.toString(),
        premiseId: premiseId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search devices
  ///@param modelId
  ///@param assetId
  ///@param floorId
  ///@param facilityId
  ///@param premiseId
  ///@param body
  @Post(path: '/Device/search')
  Future<chopper.Response<DeviceArrayRes>> _searchDevices({
    @Header('modelId') String? modelId,
    @Header('assetId') String? assetId,
    @Header('floorId') String? floorId,
    @Header('facilityId') String? facilityId,
    @Header('premiseId') String? premiseId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get devices
  ///@param body
  Future<chopper.Response<DeviceArrayRes>> getDevices({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DeviceArrayRes, () => DeviceArrayRes.fromJsonFactory);

    return _getDevices(body: body, apikey: apikey?.toString());
  }

  ///get devices
  ///@param body
  @Post(path: '/Device/get')
  Future<chopper.Response<DeviceArrayRes>> _getDevices({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get device by id
  ///@param deviceId
  ///@param isHardwareDevice
  Future<chopper.Response<DeviceEntityRes>> getDevice({
    required String? deviceId,
    bool? isHardwareDevice,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceEntityRes, () => DeviceEntityRes.fromJsonFactory);

    return _getDevice(
        deviceId: deviceId,
        isHardwareDevice: isHardwareDevice?.toString(),
        apikey: apikey?.toString());
  }

  ///get device by id
  ///@param deviceId
  ///@param isHardwareDevice
  @Get(path: '/Device/one/{deviceId}')
  Future<chopper.Response<DeviceEntityRes>> _getDevice({
    @Path('deviceId') required String? deviceId,
    @Header('isHardwareDevice') String? isHardwareDevice,
    @Header('APIKEY') String? apikey,
  });

  ///Reset API key of a device
  ///@param deviceId
  ///@param apiKey
  Future<chopper.Response<DeviceEntityRes>> resetDeviceApiKey({
    String? deviceId,
    String? apiKey,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceEntityRes, () => DeviceEntityRes.fromJsonFactory);

    return _resetDeviceApiKey(
        deviceId: deviceId?.toString(),
        apiKey: apiKey?.toString(),
        apikey: apikey?.toString());
  }

  ///Reset API key of a device
  ///@param deviceId
  ///@param apiKey
  @Put(
    path: '/Device/reset_key',
    optionalBody: true,
  )
  Future<chopper.Response<DeviceEntityRes>> _resetDeviceApiKey({
    @Header('deviceId') String? deviceId,
    @Header('apiKey') String? apiKey,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<DeviceArrayRes>> searchEqlDevice({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DeviceArrayRes, () => DeviceArrayRes.fromJsonFactory);

    return _searchEqlDevice(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Device/eql')
  Future<chopper.Response<DeviceArrayRes>> _searchEqlDevice({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///count
  Future<chopper.Response<CountRes>> countDevices({dynamic apikey}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countDevices(apikey: apikey?.toString());
  }

  ///count
  @Get(path: '/Device/count')
  Future<chopper.Response<CountRes>> _countDevices(
      {@Header('APIKEY') String? apikey});

  ///Create condition
  ///@param body
  Future<chopper.Response<ConditionEntityRes>> createCondition({
    required ConditionInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ConditionInfo, () => ConditionInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ConditionEntityRes, () => ConditionEntityRes.fromJsonFactory);

    return _createCondition(body: body, apikey: apikey?.toString());
  }

  ///Create condition
  ///@param body
  @Post(path: '/Condition/create')
  Future<chopper.Response<ConditionEntityRes>> _createCondition({
    @Body() required ConditionInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update condition
  ///@param conditionId
  ///@param body
  Future<chopper.Response<ConditionEntityRes>> updateCondition({
    String? conditionId,
    required ConditionInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ConditionInfo, () => ConditionInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ConditionEntityRes, () => ConditionEntityRes.fromJsonFactory);

    return _updateCondition(
        conditionId: conditionId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update condition
  ///@param conditionId
  ///@param body
  @Post(path: '/Condition/update')
  Future<chopper.Response<ConditionEntityRes>> _updateCondition({
    @Header('conditionId') String? conditionId,
    @Body() required ConditionInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete condition
  ///@param conditionId
  Future<chopper.Response<ConditionEntityRes>> deleteCondition({
    String? conditionId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ConditionEntityRes, () => ConditionEntityRes.fromJsonFactory);

    return _deleteCondition(
        conditionId: conditionId?.toString(), apikey: apikey?.toString());
  }

  ///Delete condition
  ///@param conditionId
  @Delete(path: '/Condition/remove')
  Future<chopper.Response<ConditionEntityRes>> _deleteCondition({
    @Header('conditionId') String? conditionId,
    @Header('APIKEY') String? apikey,
  });

  ///List conditions
  ///@param modelId
  ///@param body
  Future<chopper.Response<ConditionArrayRes>> listConditions({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ConditionArrayRes, () => ConditionArrayRes.fromJsonFactory);

    return _listConditions(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List conditions
  ///@param modelId
  ///@param body
  @Post(path: '/Condition/list')
  Future<chopper.Response<ConditionArrayRes>> _listConditions({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search conditions
  ///@param modelId
  ///@param body
  Future<chopper.Response<ConditionArrayRes>> searchConditions({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ConditionArrayRes, () => ConditionArrayRes.fromJsonFactory);

    return _searchConditions(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search conditions
  ///@param modelId
  ///@param body
  @Post(path: '/Condition/search')
  Future<chopper.Response<ConditionArrayRes>> _searchConditions({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get conditions
  ///@param body
  Future<chopper.Response<ConditionArrayRes>> getConditions({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ConditionArrayRes, () => ConditionArrayRes.fromJsonFactory);

    return _getConditions(body: body, apikey: apikey?.toString());
  }

  ///Get conditions
  ///@param body
  @Post(path: '/Condition/get')
  Future<chopper.Response<ConditionArrayRes>> _getConditions({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get condition by id
  ///@param conditionId
  Future<chopper.Response<ConditionEntityRes>> getCondition({
    required String? conditionId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ConditionEntityRes, () => ConditionEntityRes.fromJsonFactory);

    return _getCondition(conditionId: conditionId, apikey: apikey?.toString());
  }

  ///get condition by id
  ///@param conditionId
  @Get(path: '/Condition/one/{conditionId}')
  Future<chopper.Response<ConditionEntityRes>> _getCondition({
    @Path('conditionId') required String? conditionId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<ConditionArrayRes>> searchEqlCondition({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ConditionArrayRes, () => ConditionArrayRes.fromJsonFactory);

    return _searchEqlCondition(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Condition/eql')
  Future<chopper.Response<ConditionArrayRes>> _searchEqlCondition({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create alarm
  ///@param body
  Future<chopper.Response<AlarmEntityRes>> createAlarm({
    required AlarmInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(AlarmInfo, () => AlarmInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AlarmEntityRes, () => AlarmEntityRes.fromJsonFactory);

    return _createAlarm(body: body, apikey: apikey?.toString());
  }

  ///Create alarm
  ///@param body
  @Post(path: '/Alarm/create')
  Future<chopper.Response<AlarmEntityRes>> _createAlarm({
    @Body() required AlarmInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update alarm
  ///@param alarmId
  ///@param body
  Future<chopper.Response<AlarmEntityRes>> updateAlarm({
    String? alarmId,
    required AlarmInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(AlarmInfo, () => AlarmInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AlarmEntityRes, () => AlarmEntityRes.fromJsonFactory);

    return _updateAlarm(
        alarmId: alarmId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update alarm
  ///@param alarmId
  ///@param body
  @Post(path: '/Alarm/update')
  Future<chopper.Response<AlarmEntityRes>> _updateAlarm({
    @Header('alarmId') String? alarmId,
    @Body() required AlarmInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete alarm
  ///@param alarmId
  Future<chopper.Response<AlarmEntityRes>> deleteAlarm({
    String? alarmId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AlarmEntityRes, () => AlarmEntityRes.fromJsonFactory);

    return _deleteAlarm(
        alarmId: alarmId?.toString(), apikey: apikey?.toString());
  }

  ///Delete alarm
  ///@param alarmId
  @Delete(path: '/Alarm/remove')
  Future<chopper.Response<AlarmEntityRes>> _deleteAlarm({
    @Header('alarmId') String? alarmId,
    @Header('APIKEY') String? apikey,
  });

  ///List alarms
  ///@param modelId
  ///@param body
  Future<chopper.Response<AlarmArrayRes>> listAlarms({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AlarmArrayRes, () => AlarmArrayRes.fromJsonFactory);

    return _listAlarms(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List alarms
  ///@param modelId
  ///@param body
  @Post(path: '/Alarm/list')
  Future<chopper.Response<AlarmArrayRes>> _listAlarms({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search alarms
  ///@param modelId
  ///@param body
  Future<chopper.Response<AlarmArrayRes>> searchAlarms({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AlarmArrayRes, () => AlarmArrayRes.fromJsonFactory);

    return _searchAlarms(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search alarms
  ///@param modelId
  ///@param body
  @Post(path: '/Alarm/search')
  Future<chopper.Response<AlarmArrayRes>> _searchAlarms({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get alarms
  ///@param body
  Future<chopper.Response<AlarmArrayRes>> getAlarms({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AlarmArrayRes, () => AlarmArrayRes.fromJsonFactory);

    return _getAlarms(body: body, apikey: apikey?.toString());
  }

  ///Get alarms
  ///@param body
  @Post(path: '/Alarm/get')
  Future<chopper.Response<AlarmArrayRes>> _getAlarms({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get alarm by id
  ///@param alarmId
  Future<chopper.Response<AlarmEntityRes>> getAlarm({
    required String? alarmId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AlarmEntityRes, () => AlarmEntityRes.fromJsonFactory);

    return _getAlarm(alarmId: alarmId, apikey: apikey?.toString());
  }

  ///get alarm by id
  ///@param alarmId
  @Get(path: '/Alarm/one/{alarmId}')
  Future<chopper.Response<AlarmEntityRes>> _getAlarm({
    @Path('alarmId') required String? alarmId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<AlarmArrayRes>> searchEqlAlarm({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AlarmArrayRes, () => AlarmArrayRes.fromJsonFactory);

    return _searchEqlAlarm(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Alarm/eql')
  Future<chopper.Response<AlarmArrayRes>> _searchEqlAlarm({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create display
  ///@param body
  Future<chopper.Response<DisplayEntityRes>> createDisplay({
    required DisplayInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayInfo, () => DisplayInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DisplayEntityRes, () => DisplayEntityRes.fromJsonFactory);

    return _createDisplay(body: body, apikey: apikey?.toString());
  }

  ///Create display
  ///@param body
  @Post(path: '/Display/create')
  Future<chopper.Response<DisplayEntityRes>> _createDisplay({
    @Body() required DisplayInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update display
  ///@param displayId
  ///@param body
  Future<chopper.Response<DisplayEntityRes>> updateDisplay({
    String? displayId,
    required DisplayInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayInfo, () => DisplayInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DisplayEntityRes, () => DisplayEntityRes.fromJsonFactory);

    return _updateDisplay(
        displayId: displayId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update display
  ///@param displayId
  ///@param body
  @Post(path: '/Display/update')
  Future<chopper.Response<DisplayEntityRes>> _updateDisplay({
    @Header('displayId') String? displayId,
    @Body() required DisplayInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete display
  ///@param displayId
  Future<chopper.Response<DisplayEntityRes>> deleteDisplay({
    String? displayId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayEntityRes, () => DisplayEntityRes.fromJsonFactory);

    return _deleteDisplay(
        displayId: displayId?.toString(), apikey: apikey?.toString());
  }

  ///Delete display
  ///@param displayId
  @Delete(path: '/Display/remove')
  Future<chopper.Response<DisplayEntityRes>> _deleteDisplay({
    @Header('displayId') String? displayId,
    @Header('APIKEY') String? apikey,
  });

  ///List displays
  ///@param modelId
  ///@param body
  Future<chopper.Response<DisplayArrayRes>> listDisplays({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DisplayArrayRes, () => DisplayArrayRes.fromJsonFactory);

    return _listDisplays(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List displays
  ///@param modelId
  ///@param body
  @Post(path: '/Display/list')
  Future<chopper.Response<DisplayArrayRes>> _listDisplays({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search displays
  ///@param modelId
  ///@param body
  Future<chopper.Response<DisplayArrayRes>> searchDisplays({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayArrayRes, () => DisplayArrayRes.fromJsonFactory);

    return _searchDisplays(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search displays
  ///@param modelId
  ///@param body
  @Post(path: '/Display/search')
  Future<chopper.Response<DisplayArrayRes>> _searchDisplays({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get displays
  ///@param body
  Future<chopper.Response<DisplayArrayRes>> getDisplays({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DisplayArrayRes, () => DisplayArrayRes.fromJsonFactory);

    return _getDisplays(body: body, apikey: apikey?.toString());
  }

  ///Get displays
  ///@param body
  @Post(path: '/Display/get')
  Future<chopper.Response<DisplayArrayRes>> _getDisplays({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get display by id
  ///@param displayId
  Future<chopper.Response<DisplayEntityRes>> getDisplay({
    required String? displayId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayEntityRes, () => DisplayEntityRes.fromJsonFactory);

    return _getDisplay(displayId: displayId, apikey: apikey?.toString());
  }

  ///get display by id
  ///@param displayId
  @Get(path: '/Display/one/{displayId}')
  Future<chopper.Response<DisplayEntityRes>> _getDisplay({
    @Path('displayId') required String? displayId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<DisplayArrayRes>> searchEqlDisplay({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayArrayRes, () => DisplayArrayRes.fromJsonFactory);

    return _searchEqlDisplay(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Display/eql')
  Future<chopper.Response<DisplayArrayRes>> _searchEqlDisplay({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create control
  ///@param body
  Future<chopper.Response<ControlEntityRes>> createControl({
    required ControlInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ControlInfo, () => ControlInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ControlEntityRes, () => ControlEntityRes.fromJsonFactory);

    return _createControl(body: body, apikey: apikey?.toString());
  }

  ///Create control
  ///@param body
  @Post(path: '/Control/create')
  Future<chopper.Response<ControlEntityRes>> _createControl({
    @Body() required ControlInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update control
  ///@param controlId
  ///@param body
  Future<chopper.Response<ControlEntityRes>> updateControl({
    String? controlId,
    required ControlInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ControlInfo, () => ControlInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ControlEntityRes, () => ControlEntityRes.fromJsonFactory);

    return _updateControl(
        controlId: controlId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update control
  ///@param controlId
  ///@param body
  @Post(path: '/Control/update')
  Future<chopper.Response<ControlEntityRes>> _updateControl({
    @Header('controlId') String? controlId,
    @Body() required ControlInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete control
  ///@param modelId
  ///@param controlId
  Future<chopper.Response<ControlEntityRes>> deleteControl({
    String? modelId,
    String? controlId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ControlEntityRes, () => ControlEntityRes.fromJsonFactory);

    return _deleteControl(
        modelId: modelId?.toString(),
        controlId: controlId?.toString(),
        apikey: apikey?.toString());
  }

  ///Delete control
  ///@param modelId
  ///@param controlId
  @Delete(path: '/Control/remove')
  Future<chopper.Response<ControlEntityRes>> _deleteControl({
    @Header('modelId') String? modelId,
    @Header('controlId') String? controlId,
    @Header('APIKEY') String? apikey,
  });

  ///List controls
  ///@param modelId
  ///@param body
  Future<chopper.Response<ControlArrayRes>> listControls({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ControlArrayRes, () => ControlArrayRes.fromJsonFactory);

    return _listControls(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List controls
  ///@param modelId
  ///@param body
  @Post(path: '/Control/list')
  Future<chopper.Response<ControlArrayRes>> _listControls({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search controls
  ///@param modelId
  ///@param body
  Future<chopper.Response<ControlArrayRes>> searchControls({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ControlArrayRes, () => ControlArrayRes.fromJsonFactory);

    return _searchControls(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search controls
  ///@param modelId
  ///@param body
  @Post(path: '/Control/search')
  Future<chopper.Response<ControlArrayRes>> _searchControls({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get controls
  ///@param body
  Future<chopper.Response<ControlArrayRes>> getControls({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ControlArrayRes, () => ControlArrayRes.fromJsonFactory);

    return _getControls(body: body, apikey: apikey?.toString());
  }

  ///Get controls
  ///@param body
  @Post(path: '/Control/get')
  Future<chopper.Response<ControlArrayRes>> _getControls({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get control by id
  ///@param controlId
  Future<chopper.Response<ControlEntityRes>> getControl({
    required String? controlId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ControlEntityRes, () => ControlEntityRes.fromJsonFactory);

    return _getControl(controlId: controlId, apikey: apikey?.toString());
  }

  ///get control by id
  ///@param controlId
  @Get(path: '/Control/one/{controlId}')
  Future<chopper.Response<ControlEntityRes>> _getControl({
    @Path('controlId') required String? controlId,
    @Header('APIKEY') String? apikey,
  });

  ///Fire control
  ///@param body
  Future<chopper.Response<ControlEntityRes>> fireControl({
    required FireReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(FireReq, () => FireReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ControlEntityRes, () => ControlEntityRes.fromJsonFactory);

    return _fireControl(body: body, apikey: apikey?.toString());
  }

  ///Fire control
  ///@param body
  @Post(path: '/Control/fire')
  Future<chopper.Response<ControlEntityRes>> _fireControl({
    @Body() required FireReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///set control state
  ///@param deviceId
  ///@param controlId
  ///@param state
  Future<chopper.Response<ControlEntityRes>> setControlState({
    required String? deviceId,
    required String? controlId,
    required int? state,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ControlEntityRes, () => ControlEntityRes.fromJsonFactory);

    return _setControlState(
        deviceId: deviceId,
        controlId: controlId,
        state: state,
        apikey: apikey?.toString());
  }

  ///set control state
  ///@param deviceId
  ///@param controlId
  ///@param state
  @Get(path: '/Control/set/state/{deviceId}/{controlId}/{state}')
  Future<chopper.Response<ControlEntityRes>> _setControlState({
    @Path('deviceId') required String? deviceId,
    @Path('controlId') required String? controlId,
    @Path('state') required int? state,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<ControlArrayRes>> searchEqlControl({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ControlArrayRes, () => ControlArrayRes.fromJsonFactory);

    return _searchEqlControl(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Control/eql')
  Future<chopper.Response<ControlArrayRes>> _searchEqlControl({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create display widget
  ///@param body
  Future<chopper.Response<DisplayWidgetEntityRes>> createDisplayWidget({
    required DisplayWidgetInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayWidgetInfo, () => DisplayWidgetInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DisplayWidgetEntityRes, () => DisplayWidgetEntityRes.fromJsonFactory);

    return _createDisplayWidget(body: body, apikey: apikey?.toString());
  }

  ///Create display widget
  ///@param body
  @Post(path: '/DisplayWidget/create')
  Future<chopper.Response<DisplayWidgetEntityRes>> _createDisplayWidget({
    @Body() required DisplayWidgetInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update display widget
  ///@param displayWidgetId
  ///@param body
  Future<chopper.Response<DisplayWidgetEntityRes>> updateDisplayWidget({
    String? displayWidgetId,
    required DisplayWidgetInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayWidgetInfo, () => DisplayWidgetInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DisplayWidgetEntityRes, () => DisplayWidgetEntityRes.fromJsonFactory);

    return _updateDisplayWidget(
        displayWidgetId: displayWidgetId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update display widget
  ///@param displayWidgetId
  ///@param body
  @Post(path: '/DisplayWidget/update')
  Future<chopper.Response<DisplayWidgetEntityRes>> _updateDisplayWidget({
    @Header('displayWidgetId') String? displayWidgetId,
    @Body() required DisplayWidgetInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete display widget
  ///@param displayWidgetId
  Future<chopper.Response<DisplayWidgetEntityRes>> deleteDisplayWidget({
    String? displayWidgetId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayWidgetEntityRes, () => DisplayWidgetEntityRes.fromJsonFactory);

    return _deleteDisplayWidget(
        displayWidgetId: displayWidgetId?.toString(),
        apikey: apikey?.toString());
  }

  ///Delete display widget
  ///@param displayWidgetId
  @Delete(path: '/DisplayWidget/remove')
  Future<chopper.Response<DisplayWidgetEntityRes>> _deleteDisplayWidget({
    @Header('displayWidgetId') String? displayWidgetId,
    @Header('APIKEY') String? apikey,
  });

  ///List display widgets
  ///@param modelId
  ///@param body
  Future<chopper.Response<DisplayWidgetArrayRes>> listDisplayWidgets({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DisplayWidgetArrayRes, () => DisplayWidgetArrayRes.fromJsonFactory);

    return _listDisplayWidgets(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List display widgets
  ///@param modelId
  ///@param body
  @Post(path: '/DisplayWidget/list')
  Future<chopper.Response<DisplayWidgetArrayRes>> _listDisplayWidgets({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search display widgets
  ///@param modelId
  ///@param body
  Future<chopper.Response<DisplayWidgetArrayRes>> searchDisplayWidgets({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayWidgetArrayRes, () => DisplayWidgetArrayRes.fromJsonFactory);

    return _searchDisplayWidgets(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search display widgets
  ///@param modelId
  ///@param body
  @Post(path: '/DisplayWidget/search')
  Future<chopper.Response<DisplayWidgetArrayRes>> _searchDisplayWidgets({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get display widgets
  ///@param body
  Future<chopper.Response<DisplayWidgetArrayRes>> getDisplayWidgets({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DisplayWidgetArrayRes, () => DisplayWidgetArrayRes.fromJsonFactory);

    return _getDisplayWidgets(body: body, apikey: apikey?.toString());
  }

  ///Get display widgets
  ///@param body
  @Post(path: '/DisplayWidget/get')
  Future<chopper.Response<DisplayWidgetArrayRes>> _getDisplayWidgets({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get display widget by id
  ///@param displayWidgetId
  Future<chopper.Response<DisplayWidgetEntityRes>> getDisplayWidget({
    required String? displayWidgetId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayWidgetEntityRes, () => DisplayWidgetEntityRes.fromJsonFactory);

    return _getDisplayWidget(
        displayWidgetId: displayWidgetId, apikey: apikey?.toString());
  }

  ///get display widget by id
  ///@param displayWidgetId
  @Get(path: '/DisplayWidget/one/{displayWidgetId}')
  Future<chopper.Response<DisplayWidgetEntityRes>> _getDisplayWidget({
    @Path('displayWidgetId') required String? displayWidgetId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<DisplayWidgetArrayRes>> searchEqlDisplayWidget({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DisplayWidgetArrayRes, () => DisplayWidgetArrayRes.fromJsonFactory);

    return _searchEqlDisplayWidget(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/DisplayWidget/eql')
  Future<chopper.Response<DisplayWidgetArrayRes>> _searchEqlDisplayWidget({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create screen widget
  ///@param body
  Future<chopper.Response<ScreenWidgetEntityRes>> createScreenWidget({
    required ScreenWidgetInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScreenWidgetInfo, () => ScreenWidgetInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ScreenWidgetEntityRes, () => ScreenWidgetEntityRes.fromJsonFactory);

    return _createScreenWidget(body: body, apikey: apikey?.toString());
  }

  ///Create screen widget
  ///@param body
  @Post(path: '/ScreenWidget/create')
  Future<chopper.Response<ScreenWidgetEntityRes>> _createScreenWidget({
    @Body() required ScreenWidgetInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update screen widget
  ///@param screenWidgetId
  ///@param body
  Future<chopper.Response<ScreenWidgetEntityRes>> updateScreenWidget({
    String? screenWidgetId,
    required ScreenWidgetInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScreenWidgetInfo, () => ScreenWidgetInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ScreenWidgetEntityRes, () => ScreenWidgetEntityRes.fromJsonFactory);

    return _updateScreenWidget(
        screenWidgetId: screenWidgetId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update screen widget
  ///@param screenWidgetId
  ///@param body
  @Post(path: '/ScreenWidget/update')
  Future<chopper.Response<ScreenWidgetEntityRes>> _updateScreenWidget({
    @Header('screenWidgetId') String? screenWidgetId,
    @Body() required ScreenWidgetInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete screen widget
  ///@param screenWidgetId
  Future<chopper.Response<ScreenWidgetEntityRes>> deleteScreenWidget({
    String? screenWidgetId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScreenWidgetEntityRes, () => ScreenWidgetEntityRes.fromJsonFactory);

    return _deleteScreenWidget(
        screenWidgetId: screenWidgetId?.toString(), apikey: apikey?.toString());
  }

  ///Delete screen widget
  ///@param screenWidgetId
  @Delete(path: '/ScreenWidget/remove')
  Future<chopper.Response<ScreenWidgetEntityRes>> _deleteScreenWidget({
    @Header('screenWidgetId') String? screenWidgetId,
    @Header('APIKEY') String? apikey,
  });

  ///List screen widgets
  ///@param target
  ///@param body
  Future<chopper.Response<ScreenWidgetArrayRes>> listScreenWidgets({
    required enums.ScreenWidgetListTargetPostTarget? target,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ScreenWidgetArrayRes, () => ScreenWidgetArrayRes.fromJsonFactory);

    return _listScreenWidgets(
        target: target?.value?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///List screen widgets
  ///@param target
  ///@param body
  @Post(path: '/ScreenWidget/list/{target}')
  Future<chopper.Response<ScreenWidgetArrayRes>> _listScreenWidgets({
    @Path('target') required String? target,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search screen widgets
  ///@param target
  ///@param body
  Future<chopper.Response<ScreenWidgetArrayRes>> searchScreenWidgets({
    required enums.ScreenWidgetSearchTargetPostTarget? target,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScreenWidgetArrayRes, () => ScreenWidgetArrayRes.fromJsonFactory);

    return _searchScreenWidgets(
        target: target?.value?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search screen widgets
  ///@param target
  ///@param body
  @Post(path: '/ScreenWidget/search/{target}')
  Future<chopper.Response<ScreenWidgetArrayRes>> _searchScreenWidgets({
    @Path('target') required String? target,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get screen widgets
  ///@param body
  Future<chopper.Response<ScreenWidgetArrayRes>> getScreenWidgets({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ScreenWidgetArrayRes, () => ScreenWidgetArrayRes.fromJsonFactory);

    return _getScreenWidgets(body: body, apikey: apikey?.toString());
  }

  ///Get screen widgets
  ///@param body
  @Post(path: '/ScreenWidget/get')
  Future<chopper.Response<ScreenWidgetArrayRes>> _getScreenWidgets({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get screen widget by id
  ///@param screenWidgetId
  Future<chopper.Response<ScreenWidgetEntityRes>> getScreenWidget({
    required String? screenWidgetId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScreenWidgetEntityRes, () => ScreenWidgetEntityRes.fromJsonFactory);

    return _getScreenWidget(
        screenWidgetId: screenWidgetId, apikey: apikey?.toString());
  }

  ///get screen widget by id
  ///@param screenWidgetId
  @Get(path: '/ScreenWidget/one/{screenWidgetId}')
  Future<chopper.Response<ScreenWidgetEntityRes>> _getScreenWidget({
    @Path('screenWidgetId') required String? screenWidgetId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<ScreenWidgetArrayRes>> searchEqlScreenWidget({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScreenWidgetArrayRes, () => ScreenWidgetArrayRes.fromJsonFactory);

    return _searchEqlScreenWidget(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/ScreenWidget/eql')
  Future<chopper.Response<ScreenWidgetArrayRes>> _searchEqlScreenWidget({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create event
  ///@param body
  Future<chopper.Response<EventEntityRes>> createEvent({
    required EventInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EventInfo, () => EventInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        EventEntityRes, () => EventEntityRes.fromJsonFactory);

    return _createEvent(body: body, apikey: apikey?.toString());
  }

  ///Create event
  ///@param body
  @Post(path: '/Event/create')
  Future<chopper.Response<EventEntityRes>> _createEvent({
    @Body() required EventInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update event
  ///@param eventId
  ///@param body
  Future<chopper.Response<EventEntityRes>> updateEvent({
    String? eventId,
    required EventInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EventInfo, () => EventInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        EventEntityRes, () => EventEntityRes.fromJsonFactory);

    return _updateEvent(
        eventId: eventId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update event
  ///@param eventId
  ///@param body
  @Post(path: '/Event/update')
  Future<chopper.Response<EventEntityRes>> _updateEvent({
    @Header('eventId') String? eventId,
    @Body() required EventInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete event
  ///@param eventId
  Future<chopper.Response<EventEntityRes>> deleteEvent({
    String? eventId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        EventEntityRes, () => EventEntityRes.fromJsonFactory);

    return _deleteEvent(
        eventId: eventId?.toString(), apikey: apikey?.toString());
  }

  ///Delete event
  ///@param eventId
  @Delete(path: '/Event/remove')
  Future<chopper.Response<EventEntityRes>> _deleteEvent({
    @Header('eventId') String? eventId,
    @Header('APIKEY') String? apikey,
  });

  ///List events
  ///@param modelId
  ///@param body
  Future<chopper.Response<EventArrayRes>> listEvents({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        EventArrayRes, () => EventArrayRes.fromJsonFactory);

    return _listEvents(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List events
  ///@param modelId
  ///@param body
  @Post(path: '/Event/list')
  Future<chopper.Response<EventArrayRes>> _listEvents({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search events
  ///@param modelId
  ///@param body
  Future<chopper.Response<EventArrayRes>> searchEvents({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        EventArrayRes, () => EventArrayRes.fromJsonFactory);

    return _searchEvents(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search events
  ///@param modelId
  ///@param body
  @Post(path: '/Event/search')
  Future<chopper.Response<EventArrayRes>> _searchEvents({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get events
  ///@param body
  Future<chopper.Response<EventArrayRes>> getEvents({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        EventArrayRes, () => EventArrayRes.fromJsonFactory);

    return _getEvents(body: body, apikey: apikey?.toString());
  }

  ///Get events
  ///@param body
  @Post(path: '/Event/get')
  Future<chopper.Response<EventArrayRes>> _getEvents({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get event by id
  ///@param eventId
  Future<chopper.Response<EventEntityRes>> getEvent({
    required String? eventId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        EventEntityRes, () => EventEntityRes.fromJsonFactory);

    return _getEvent(eventId: eventId, apikey: apikey?.toString());
  }

  ///get event by id
  ///@param eventId
  @Get(path: '/Event/one/{eventId}')
  Future<chopper.Response<EventEntityRes>> _getEvent({
    @Path('eventId') required String? eventId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<EventArrayRes>> searchEqlEvent({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        EventArrayRes, () => EventArrayRes.fromJsonFactory);

    return _searchEqlEvent(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Event/eql')
  Future<chopper.Response<EventArrayRes>> _searchEqlEvent({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create trigger
  ///@param body
  Future<chopper.Response<TriggerEntityRes>> createTrigger({
    required TriggerInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TriggerInfo, () => TriggerInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TriggerEntityRes, () => TriggerEntityRes.fromJsonFactory);

    return _createTrigger(body: body, apikey: apikey?.toString());
  }

  ///Create trigger
  ///@param body
  @Post(path: '/Trigger/create')
  Future<chopper.Response<TriggerEntityRes>> _createTrigger({
    @Body() required TriggerInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update trigger
  ///@param triggerId
  ///@param body
  Future<chopper.Response<TriggerEntityRes>> updateTrigger({
    String? triggerId,
    required TriggerInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TriggerInfo, () => TriggerInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TriggerEntityRes, () => TriggerEntityRes.fromJsonFactory);

    return _updateTrigger(
        triggerId: triggerId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update trigger
  ///@param triggerId
  ///@param body
  @Post(path: '/Trigger/update')
  Future<chopper.Response<TriggerEntityRes>> _updateTrigger({
    @Header('triggerId') String? triggerId,
    @Body() required TriggerInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete trigger
  ///@param triggerId
  Future<chopper.Response<TriggerEntityRes>> deleteTrigger({
    String? triggerId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TriggerEntityRes, () => TriggerEntityRes.fromJsonFactory);

    return _deleteTrigger(
        triggerId: triggerId?.toString(), apikey: apikey?.toString());
  }

  ///Delete trigger
  ///@param triggerId
  @Delete(path: '/Trigger/remove')
  Future<chopper.Response<TriggerEntityRes>> _deleteTrigger({
    @Header('triggerId') String? triggerId,
    @Header('APIKEY') String? apikey,
  });

  ///List triggers
  ///@param modelId
  ///@param body
  Future<chopper.Response<TriggerArrayRes>> listTrigger({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TriggerArrayRes, () => TriggerArrayRes.fromJsonFactory);

    return _listTrigger(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List triggers
  ///@param modelId
  ///@param body
  @Post(path: '/Trigger/list')
  Future<chopper.Response<TriggerArrayRes>> _listTrigger({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search triggers
  ///@param modelId
  ///@param body
  Future<chopper.Response<TriggerArrayRes>> searchTriggers({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TriggerArrayRes, () => TriggerArrayRes.fromJsonFactory);

    return _searchTriggers(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search triggers
  ///@param modelId
  ///@param body
  @Post(path: '/Trigger/search')
  Future<chopper.Response<TriggerArrayRes>> _searchTriggers({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get triggers
  ///@param body
  Future<chopper.Response<TriggerArrayRes>> getTriggers({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TriggerArrayRes, () => TriggerArrayRes.fromJsonFactory);

    return _getTriggers(body: body, apikey: apikey?.toString());
  }

  ///Get triggers
  ///@param body
  @Post(path: '/Trigger/get')
  Future<chopper.Response<TriggerArrayRes>> _getTriggers({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get trigger by id
  ///@param triggerId
  Future<chopper.Response<TriggerEntityRes>> getTrigger({
    required String? triggerId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TriggerEntityRes, () => TriggerEntityRes.fromJsonFactory);

    return _getTrigger(triggerId: triggerId, apikey: apikey?.toString());
  }

  ///get trigger by id
  ///@param triggerId
  @Get(path: '/Trigger/one/{triggerId}')
  Future<chopper.Response<TriggerEntityRes>> _getTrigger({
    @Path('triggerId') required String? triggerId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<TriggerArrayRes>> searchEqlTrigger({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TriggerArrayRes, () => TriggerArrayRes.fromJsonFactory);

    return _searchEqlTrigger(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Trigger/eql')
  Future<chopper.Response<TriggerArrayRes>> _searchEqlTrigger({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create preprocessor
  ///@param body
  Future<chopper.Response<PreprocessorEntityRes>> createPreprocessor({
    required PreprocessorInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PreprocessorInfo, () => PreprocessorInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        PreprocessorEntityRes, () => PreprocessorEntityRes.fromJsonFactory);

    return _createPreprocessor(body: body, apikey: apikey?.toString());
  }

  ///Create preprocessor
  ///@param body
  @Post(path: '/Preprocessor/create')
  Future<chopper.Response<PreprocessorEntityRes>> _createPreprocessor({
    @Body() required PreprocessorInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update preprocessor
  ///@param preprocessorId
  ///@param body
  Future<chopper.Response<PreprocessorEntityRes>> updatePreprocessor({
    String? preprocessorId,
    required PreprocessorInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PreprocessorInfo, () => PreprocessorInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        PreprocessorEntityRes, () => PreprocessorEntityRes.fromJsonFactory);

    return _updatePreprocessor(
        preprocessorId: preprocessorId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update preprocessor
  ///@param preprocessorId
  ///@param body
  @Post(path: '/Preprocessor/update')
  Future<chopper.Response<PreprocessorEntityRes>> _updatePreprocessor({
    @Header('preprocessorId') String? preprocessorId,
    @Body() required PreprocessorInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete preprocessor
  ///@param preprocessorId
  Future<chopper.Response<PreprocessorEntityRes>> deletePreprocessor({
    String? preprocessorId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PreprocessorEntityRes, () => PreprocessorEntityRes.fromJsonFactory);

    return _deletePreprocessor(
        preprocessorId: preprocessorId?.toString(), apikey: apikey?.toString());
  }

  ///Delete preprocessor
  ///@param preprocessorId
  @Delete(path: '/Preprocessor/remove')
  Future<chopper.Response<PreprocessorEntityRes>> _deletePreprocessor({
    @Header('preprocessorId') String? preprocessorId,
    @Header('APIKEY') String? apikey,
  });

  ///List preprocessors
  ///@param body
  Future<chopper.Response<PreprocessorArrayRes>> listPreprocessors({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        PreprocessorArrayRes, () => PreprocessorArrayRes.fromJsonFactory);

    return _listPreprocessors(body: body, apikey: apikey?.toString());
  }

  ///List preprocessors
  ///@param body
  @Post(path: '/Preprocessor/list')
  Future<chopper.Response<PreprocessorArrayRes>> _listPreprocessors({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search preprocessors
  ///@param body
  Future<chopper.Response<PreprocessorArrayRes>> searchPreprocessors({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PreprocessorArrayRes, () => PreprocessorArrayRes.fromJsonFactory);

    return _searchPreprocessors(body: body, apikey: apikey?.toString());
  }

  ///Search preprocessors
  ///@param body
  @Post(path: '/Preprocessor/search')
  Future<chopper.Response<PreprocessorArrayRes>> _searchPreprocessors({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get preprocessors
  ///@param body
  Future<chopper.Response<PreprocessorArrayRes>> getPreprocessors({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        PreprocessorArrayRes, () => PreprocessorArrayRes.fromJsonFactory);

    return _getPreprocessors(body: body, apikey: apikey?.toString());
  }

  ///Get preprocessors
  ///@param body
  @Post(path: '/Preprocessor/get')
  Future<chopper.Response<PreprocessorArrayRes>> _getPreprocessors({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get preprocessor by id
  ///@param preprocessorId
  Future<chopper.Response<PreprocessorEntityRes>> getPreprocessor({
    required String? preprocessorId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PreprocessorEntityRes, () => PreprocessorEntityRes.fromJsonFactory);

    return _getPreprocessor(
        preprocessorId: preprocessorId, apikey: apikey?.toString());
  }

  ///get preprocessor by id
  ///@param preprocessorId
  @Get(path: '/Preprocessor/one/{preprocessorId}')
  Future<chopper.Response<PreprocessorEntityRes>> _getPreprocessor({
    @Path('preprocessorId') required String? preprocessorId,
    @Header('APIKEY') String? apikey,
  });

  ///Create dataFilter
  ///@param body
  Future<chopper.Response<DataFilterEntityRes>> createDataFilter({
    required DataFilterInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DataFilterInfo, () => DataFilterInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DataFilterEntityRes, () => DataFilterEntityRes.fromJsonFactory);

    return _createDataFilter(body: body, apikey: apikey?.toString());
  }

  ///Create dataFilter
  ///@param body
  @Post(path: '/DataFilter/create')
  Future<chopper.Response<DataFilterEntityRes>> _createDataFilter({
    @Body() required DataFilterInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update dataFilter
  ///@param dataFilterId
  ///@param body
  Future<chopper.Response<DataFilterEntityRes>> updateDataFilter({
    String? dataFilterId,
    required DataFilterInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DataFilterInfo, () => DataFilterInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DataFilterEntityRes, () => DataFilterEntityRes.fromJsonFactory);

    return _updateDataFilter(
        dataFilterId: dataFilterId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update dataFilter
  ///@param dataFilterId
  ///@param body
  @Post(path: '/DataFilter/update')
  Future<chopper.Response<DataFilterEntityRes>> _updateDataFilter({
    @Header('dataFilterId') String? dataFilterId,
    @Body() required DataFilterInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete dataFilter
  ///@param dataFilterId
  Future<chopper.Response<DataFilterEntityRes>> deleteDataFilter({
    String? dataFilterId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DataFilterEntityRes, () => DataFilterEntityRes.fromJsonFactory);

    return _deleteDataFilter(
        dataFilterId: dataFilterId?.toString(), apikey: apikey?.toString());
  }

  ///Delete dataFilter
  ///@param dataFilterId
  @Delete(path: '/DataFilter/remove')
  Future<chopper.Response<DataFilterEntityRes>> _deleteDataFilter({
    @Header('dataFilterId') String? dataFilterId,
    @Header('APIKEY') String? apikey,
  });

  ///List dataFilters
  ///@param modelId
  ///@param body
  Future<chopper.Response<DataFilterArrayRes>> listDataFilters({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DataFilterArrayRes, () => DataFilterArrayRes.fromJsonFactory);

    return _listDataFilters(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List dataFilters
  ///@param modelId
  ///@param body
  @Post(path: '/DataFilter/list')
  Future<chopper.Response<DataFilterArrayRes>> _listDataFilters({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search dataFilters
  ///@param modelId
  ///@param body
  Future<chopper.Response<DataFilterArrayRes>> searchDataFilters({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DataFilterArrayRes, () => DataFilterArrayRes.fromJsonFactory);

    return _searchDataFilters(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search dataFilters
  ///@param modelId
  ///@param body
  @Post(path: '/DataFilter/search')
  Future<chopper.Response<DataFilterArrayRes>> _searchDataFilters({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get dataFilters
  ///@param body
  Future<chopper.Response<DataFilterArrayRes>> getDataFilters({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        DataFilterArrayRes, () => DataFilterArrayRes.fromJsonFactory);

    return _getDataFilters(body: body, apikey: apikey?.toString());
  }

  ///Get dataFilters
  ///@param body
  @Post(path: '/DataFilter/get')
  Future<chopper.Response<DataFilterArrayRes>> _getDataFilters({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get dataFilter by id
  ///@param dataFilterId
  Future<chopper.Response<DataFilterEntityRes>> getDataFilter({
    required String? dataFilterId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        DataFilterEntityRes, () => DataFilterEntityRes.fromJsonFactory);

    return _getDataFilter(
        dataFilterId: dataFilterId, apikey: apikey?.toString());
  }

  ///get dataFilter by id
  ///@param dataFilterId
  @Get(path: '/DataFilter/one/{dataFilterId}')
  Future<chopper.Response<DataFilterEntityRes>> _getDataFilter({
    @Path('dataFilterId') required String? dataFilterId,
    @Header('APIKEY') String? apikey,
  });

  ///Create geoFence
  ///@param body
  Future<chopper.Response<GeoFenceEntityRes>> createGeoFence({
    required GeoFenceInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        GeoFenceInfo, () => GeoFenceInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        GeoFenceEntityRes, () => GeoFenceEntityRes.fromJsonFactory);

    return _createGeoFence(body: body, apikey: apikey?.toString());
  }

  ///Create geoFence
  ///@param body
  @Post(path: '/GeoFence/create')
  Future<chopper.Response<GeoFenceEntityRes>> _createGeoFence({
    @Body() required GeoFenceInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update geoFence
  ///@param geoFenceId
  ///@param body
  Future<chopper.Response<GeoFenceEntityRes>> updateGeoFence({
    String? geoFenceId,
    required GeoFenceInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        GeoFenceInfo, () => GeoFenceInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        GeoFenceEntityRes, () => GeoFenceEntityRes.fromJsonFactory);

    return _updateGeoFence(
        geoFenceId: geoFenceId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update geoFence
  ///@param geoFenceId
  ///@param body
  @Post(path: '/GeoFence/update')
  Future<chopper.Response<GeoFenceEntityRes>> _updateGeoFence({
    @Header('geoFenceId') String? geoFenceId,
    @Body() required GeoFenceInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete geoFence
  ///@param geoFenceId
  Future<chopper.Response<GeoFenceEntityRes>> deleteGeoFence({
    String? geoFenceId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        GeoFenceEntityRes, () => GeoFenceEntityRes.fromJsonFactory);

    return _deleteGeoFence(
        geoFenceId: geoFenceId?.toString(), apikey: apikey?.toString());
  }

  ///Delete geoFence
  ///@param geoFenceId
  @Delete(path: '/GeoFence/remove')
  Future<chopper.Response<GeoFenceEntityRes>> _deleteGeoFence({
    @Header('geoFenceId') String? geoFenceId,
    @Header('APIKEY') String? apikey,
  });

  ///List geoFences
  ///@param body
  Future<chopper.Response<GeoFenceArrayRes>> listGeoFences({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        GeoFenceArrayRes, () => GeoFenceArrayRes.fromJsonFactory);

    return _listGeoFences(body: body, apikey: apikey?.toString());
  }

  ///List geoFences
  ///@param body
  @Post(path: '/GeoFence/list')
  Future<chopper.Response<GeoFenceArrayRes>> _listGeoFences({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search geoFences
  ///@param body
  Future<chopper.Response<GeoFenceArrayRes>> searchGeoFences({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        GeoFenceArrayRes, () => GeoFenceArrayRes.fromJsonFactory);

    return _searchGeoFences(body: body, apikey: apikey?.toString());
  }

  ///Search geoFences
  ///@param body
  @Post(path: '/GeoFence/search')
  Future<chopper.Response<GeoFenceArrayRes>> _searchGeoFences({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get geoFences
  ///@param body
  Future<chopper.Response<GeoFenceArrayRes>> getGeoFences({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        GeoFenceArrayRes, () => GeoFenceArrayRes.fromJsonFactory);

    return _getGeoFences(body: body, apikey: apikey?.toString());
  }

  ///Get geoFences
  ///@param body
  @Post(path: '/GeoFence/get')
  Future<chopper.Response<GeoFenceArrayRes>> _getGeoFences({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get geoFence by id
  ///@param geoFenceId
  Future<chopper.Response<GeoFenceEntityRes>> getGeoFence({
    required String? geoFenceId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        GeoFenceEntityRes, () => GeoFenceEntityRes.fromJsonFactory);

    return _getGeoFence(geoFenceId: geoFenceId, apikey: apikey?.toString());
  }

  ///get geoFence by id
  ///@param geoFenceId
  @Get(path: '/GeoFence/one/{geoFenceId}')
  Future<chopper.Response<GeoFenceEntityRes>> _getGeoFence({
    @Path('geoFenceId') required String? geoFenceId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<GeoFenceArrayRes>> searchEqlGeoFence({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        GeoFenceArrayRes, () => GeoFenceArrayRes.fromJsonFactory);

    return _searchEqlGeoFence(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/GeoFence/eql')
  Future<chopper.Response<GeoFenceArrayRes>> _searchEqlGeoFence({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create analytics screen
  ///@param body
  Future<chopper.Response<AnalyticsScreenEntityRes>> createAnalyticsScreen({
    required AnalyticsScreenInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AnalyticsScreenInfo, () => AnalyticsScreenInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(AnalyticsScreenEntityRes,
        () => AnalyticsScreenEntityRes.fromJsonFactory);

    return _createAnalyticsScreen(body: body, apikey: apikey?.toString());
  }

  ///Create analytics screen
  ///@param body
  @Post(path: '/AnalyticsScreen/create')
  Future<chopper.Response<AnalyticsScreenEntityRes>> _createAnalyticsScreen({
    @Body() required AnalyticsScreenInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update analytics screen
  ///@param analyticsScreenId
  ///@param body
  Future<chopper.Response<AnalyticsScreenEntityRes>> updateAnalyticsScreen({
    String? analyticsScreenId,
    required AnalyticsScreenInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AnalyticsScreenInfo, () => AnalyticsScreenInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(AnalyticsScreenEntityRes,
        () => AnalyticsScreenEntityRes.fromJsonFactory);

    return _updateAnalyticsScreen(
        analyticsScreenId: analyticsScreenId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update analytics screen
  ///@param analyticsScreenId
  ///@param body
  @Post(path: '/AnalyticsScreen/update')
  Future<chopper.Response<AnalyticsScreenEntityRes>> _updateAnalyticsScreen({
    @Header('analyticsScreenId') String? analyticsScreenId,
    @Body() required AnalyticsScreenInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete analytics screen
  ///@param analyticsScreenId
  Future<chopper.Response<AnalyticsScreenEntityRes>> deleteAnalyticsScreen({
    String? analyticsScreenId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(AnalyticsScreenEntityRes,
        () => AnalyticsScreenEntityRes.fromJsonFactory);

    return _deleteAnalyticsScreen(
        analyticsScreenId: analyticsScreenId?.toString(),
        apikey: apikey?.toString());
  }

  ///Delete analytics screen
  ///@param analyticsScreenId
  @Delete(path: '/AnalyticsScreen/remove')
  Future<chopper.Response<AnalyticsScreenEntityRes>> _deleteAnalyticsScreen({
    @Header('analyticsScreenId') String? analyticsScreenId,
    @Header('APIKEY') String? apikey,
  });

  ///List analytics screens
  ///@param body
  Future<chopper.Response<AnalyticsScreenArrayRes>> listAnalyticsScreens({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AnalyticsScreenArrayRes, () => AnalyticsScreenArrayRes.fromJsonFactory);

    return _listAnalyticsScreens(body: body, apikey: apikey?.toString());
  }

  ///List analytics screens
  ///@param body
  @Post(path: '/AnalyticsScreen/list')
  Future<chopper.Response<AnalyticsScreenArrayRes>> _listAnalyticsScreens({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search analytics screens
  ///@param body
  Future<chopper.Response<AnalyticsScreenArrayRes>> searchAnalyticsScreens({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AnalyticsScreenArrayRes, () => AnalyticsScreenArrayRes.fromJsonFactory);

    return _searchAnalyticsScreens(body: body, apikey: apikey?.toString());
  }

  ///Search analytics screens
  ///@param body
  @Post(path: '/AnalyticsScreen/search')
  Future<chopper.Response<AnalyticsScreenArrayRes>> _searchAnalyticsScreens({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get analytics screens
  ///@param body
  Future<chopper.Response<AnalyticsScreenArrayRes>> getAnalyticsScreens({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AnalyticsScreenArrayRes, () => AnalyticsScreenArrayRes.fromJsonFactory);

    return _getAnalyticsScreens(body: body, apikey: apikey?.toString());
  }

  ///Get analytics screens
  ///@param body
  @Post(path: '/AnalyticsScreen/get')
  Future<chopper.Response<AnalyticsScreenArrayRes>> _getAnalyticsScreens({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get analytics screen by id
  ///@param analyticsScreenId
  Future<chopper.Response<AnalyticsScreenEntityRes>> getAnalyticsScreen({
    required String? analyticsScreenId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(AnalyticsScreenEntityRes,
        () => AnalyticsScreenEntityRes.fromJsonFactory);

    return _getAnalyticsScreen(
        analyticsScreenId: analyticsScreenId, apikey: apikey?.toString());
  }

  ///get analytics screen by id
  ///@param analyticsScreenId
  @Get(path: '/AnalyticsScreen/one/{analyticsScreenId}')
  Future<chopper.Response<AnalyticsScreenEntityRes>> _getAnalyticsScreen({
    @Path('analyticsScreenId') required String? analyticsScreenId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<AnalyticsScreenArrayRes>> searchEqlAnalyticsScreen({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AnalyticsScreenArrayRes, () => AnalyticsScreenArrayRes.fromJsonFactory);

    return _searchEqlAnalyticsScreen(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/AnalyticsScreen/eql')
  Future<chopper.Response<AnalyticsScreenArrayRes>> _searchEqlAnalyticsScreen({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Upload device model image
  ///@param imageType
  ///@param modelId Device Model ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadModelFile({
    required enums.TwinImageUploadModelImageTypeModelIdPostImageType? imageType,
    required String? modelId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadModelFile(
        imageType: imageType?.value?.toString(),
        modelId: modelId,
        file: file,
        apikey: apikey?.toString());
  }

  ///Upload device model image
  ///@param imageType
  ///@param modelId Device Model ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/model/{imageType}/{modelId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadModelFile({
    @Path('imageType') required String? imageType,
    @Path('modelId') required String? modelId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload condition image
  ///@param conditionId Condition ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadConditionFile({
    required String? conditionId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadConditionFile(
        conditionId: conditionId, file: file, apikey: apikey?.toString());
  }

  ///Upload condition image
  ///@param conditionId Condition ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/condition/{conditionId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadConditionFile({
    @Path('conditionId') required String? conditionId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload alarm image
  ///@param imageType
  ///@param alarmId Alarm ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadAlarmFile({
    required enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType? imageType,
    required String? alarmId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadAlarmFile(
        imageType: imageType?.value?.toString(),
        alarmId: alarmId,
        file: file,
        apikey: apikey?.toString());
  }

  ///Upload alarm image
  ///@param imageType
  ///@param alarmId Alarm ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/alarm/{imageType}/{alarmId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadAlarmFile({
    @Path('imageType') required String? imageType,
    @Path('alarmId') required String? alarmId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload display image
  ///@param displayId Display ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadDisplayFile({
    required String? displayId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadDisplayFile(
        displayId: displayId, file: file, apikey: apikey?.toString());
  }

  ///Upload display image
  ///@param displayId Display ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/display/{displayId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadDisplayFile({
    @Path('displayId') required String? displayId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload control image
  ///@param controlId Control ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadControlFile({
    required String? controlId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadControlFile(
        controlId: controlId, file: file, apikey: apikey?.toString());
  }

  ///Upload control image
  ///@param controlId Control ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/control/{controlId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadControlFile({
    @Path('controlId') required String? controlId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload event image
  ///@param eventId Event ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadEventFile({
    required String? eventId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadEventFile(
        eventId: eventId, file: file, apikey: apikey?.toString());
  }

  ///Upload event image
  ///@param eventId Event ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/event/{eventId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadEventFile({
    @Path('eventId') required String? eventId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload trigger image
  ///@param triggerId Trigger ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadTriggerFile({
    required String? triggerId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadTriggerFile(
        triggerId: triggerId, file: file, apikey: apikey?.toString());
  }

  ///Upload trigger image
  ///@param triggerId Trigger ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/trigger/{triggerId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadTriggerFile({
    @Path('triggerId') required String? triggerId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload device image
  ///@param imageType
  ///@param deviceId Device ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadDeviceFile({
    required enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType?
        imageType,
    required String? deviceId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadDeviceFile(
        imageType: imageType?.value?.toString(),
        deviceId: deviceId,
        file: file,
        apikey: apikey?.toString());
  }

  ///Upload device image
  ///@param imageType
  ///@param deviceId Device ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/device/{imageType}/{deviceId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadDeviceFile({
    @Path('imageType') required String? imageType,
    @Path('deviceId') required String? deviceId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload menu image
  ///@param menuGroupId Menu Group ID
  ///@param menuIndex
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadMenuFile({
    required String? menuGroupId,
    required int? menuIndex,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadMenuFile(
        menuGroupId: menuGroupId,
        menuIndex: menuIndex,
        file: file,
        apikey: apikey?.toString());
  }

  ///Upload menu image
  ///@param menuGroupId Menu Group ID
  ///@param menuIndex
  ///@param file
  @Post(
    path: '/TwinImage/upload/menu/{menuGroupId}/{menuIndex}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadMenuFile({
    @Path('menuGroupId') required String? menuGroupId,
    @Path('menuIndex') required int? menuIndex,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload menu group image
  ///@param menuGroupId Menu Group ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadMenuGroupFile({
    required String? menuGroupId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadMenuGroupFile(
        menuGroupId: menuGroupId, file: file, apikey: apikey?.toString());
  }

  ///Upload menu group image
  ///@param menuGroupId Menu Group ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/menugroup/{menuGroupId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadMenuGroupFile({
    @Path('menuGroupId') required String? menuGroupId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload screen image
  ///@param screenId Screen ID
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadScreenFile({
    required String? screenId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadScreenFile(
        screenId: screenId, file: file, apikey: apikey?.toString());
  }

  ///Upload screen image
  ///@param screenId Screen ID
  ///@param file
  @Post(
    path: '/TwinImage/upload/screen/{screenId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadScreenFile({
    @Path('screenId') required String? screenId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload domain image
  ///@param imageType
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadDomainFile({
    required enums.TwinImageUploadDomainImageTypePostImageType? imageType,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadDomainFile(
        imageType: imageType?.value?.toString(),
        file: file,
        apikey: apikey?.toString());
  }

  ///Upload domain image
  ///@param imageType
  ///@param file
  @Post(
    path: '/TwinImage/upload/domain/{imageType}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadDomainFile({
    @Path('imageType') required String? imageType,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload user image
  ///@param userId
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadUserImage({
    required String? userId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadUserImage(
        userId: userId, file: file, apikey: apikey?.toString());
  }

  ///Upload user image
  ///@param userId
  ///@param file
  @Post(
    path: '/TwinImage/upload/user/{userId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadUserImage({
    @Path('userId') required String? userId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload floor image
  ///@param floorId
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadFloorImage({
    required String? floorId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadFloorImage(
        floorId: floorId, file: file, apikey: apikey?.toString());
  }

  ///Upload floor image
  ///@param floorId
  ///@param file
  @Post(
    path: '/TwinImage/upload/floor/{floorId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadFloorImage({
    @Path('floorId') required String? floorId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload asset image
  ///@param assetId
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadAssetImage({
    required String? assetId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadAssetImage(
        assetId: assetId, file: file, apikey: apikey?.toString());
  }

  ///Upload asset image
  ///@param assetId
  ///@param file
  @Post(
    path: '/TwinImage/upload/asset/{assetId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadAssetImage({
    @Path('assetId') required String? assetId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload facility image
  ///@param facilityId
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadFacilityImage({
    required String? facilityId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadFacilityImage(
        facilityId: facilityId, file: file, apikey: apikey?.toString());
  }

  ///Upload facility image
  ///@param facilityId
  ///@param file
  @Post(
    path: '/TwinImage/upload/facility/{facilityId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadFacilityImage({
    @Path('facilityId') required String? facilityId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Upload premise image
  ///@param premiseId
  ///@param file
  Future<chopper.Response<ImageFileEntityRes>> uploadPremiseImage({
    required String? premiseId,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _uploadPremiseImage(
        premiseId: premiseId, file: file, apikey: apikey?.toString());
  }

  ///Upload premise image
  ///@param premiseId
  ///@param file
  @Post(
    path: '/TwinImage/upload/premise/{premiseId}',
    optionalBody: true,
  )
  Future<chopper.Response<ImageFileEntityRes>> _uploadPremiseImage({
    @Path('premiseId') required String? premiseId,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Delete image
  ///@param id Image ID
  Future<chopper.Response<ImageFileEntityRes>> deleteImage({
    required String? id,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileEntityRes, () => ImageFileEntityRes.fromJsonFactory);

    return _deleteImage(id: id, apikey: apikey?.toString());
  }

  ///Delete image
  ///@param id Image ID
  @Delete(path: '/TwinImage/remove/{id}')
  Future<chopper.Response<ImageFileEntityRes>> _deleteImage({
    @Path('id') required String? id,
    @Header('APIKEY') String? apikey,
  });

  ///Get image
  ///@param domainKey Domain key
  ///@param id Image ID
  Future<chopper.Response<List<int>>> domanloadImage({
    required String? domainKey,
    required String? id,
  }) {
    return _domanloadImage(domainKey: domainKey, id: id);
  }

  ///Get image
  ///@param domainKey Domain key
  ///@param id Image ID
  @Get(path: '/TwinImage/download/{domainKey}/{id}')
  Future<chopper.Response<List<int>>> _domanloadImage({
    @Path('domainKey') required String? domainKey,
    @Path('id') required String? id,
  });

  ///Search images
  ///@param imageType
  ///@param modelId Devie Model ID
  ///@param deviceId Device ID
  ///@param conditionid Condition ID
  ///@param alarmId Alarm ID
  ///@param controlId Control ID
  ///@param eventId Event ID
  ///@param triggerId Trigger ID
  ///@param displayId Display ID
  ///@param userId User ID
  ///@param floorId Floor ID
  ///@param assetId Asset ID
  ///@param facilityId Facility ID
  ///@param body
  Future<chopper.Response<ImageFileArrayRes>> searchImages({
    required enums.TwinImageSearchImageTypePostImageType? imageType,
    String? modelId,
    String? deviceId,
    String? conditionid,
    String? alarmId,
    String? controlId,
    String? eventId,
    String? triggerId,
    String? displayId,
    String? userId,
    String? floorId,
    String? assetId,
    String? facilityId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ImageFileArrayRes, () => ImageFileArrayRes.fromJsonFactory);

    return _searchImages(
        imageType: imageType?.value?.toString(),
        modelId: modelId?.toString(),
        deviceId: deviceId?.toString(),
        conditionid: conditionid?.toString(),
        alarmId: alarmId?.toString(),
        controlId: controlId?.toString(),
        eventId: eventId?.toString(),
        triggerId: triggerId?.toString(),
        displayId: displayId?.toString(),
        userId: userId?.toString(),
        floorId: floorId?.toString(),
        assetId: assetId?.toString(),
        facilityId: facilityId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search images
  ///@param imageType
  ///@param modelId Devie Model ID
  ///@param deviceId Device ID
  ///@param conditionid Condition ID
  ///@param alarmId Alarm ID
  ///@param controlId Control ID
  ///@param eventId Event ID
  ///@param triggerId Trigger ID
  ///@param displayId Display ID
  ///@param userId User ID
  ///@param floorId Floor ID
  ///@param assetId Asset ID
  ///@param facilityId Facility ID
  ///@param body
  @Post(path: '/TwinImage/search/{imageType}')
  Future<chopper.Response<ImageFileArrayRes>> _searchImages({
    @Path('imageType') required String? imageType,
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Header('conditionid') String? conditionid,
    @Header('alarmId') String? alarmId,
    @Header('controlId') String? controlId,
    @Header('eventId') String? eventId,
    @Header('triggerId') String? triggerId,
    @Header('displayId') String? displayId,
    @Header('userId') String? userId,
    @Header('floorId') String? floorId,
    @Header('assetId') String? assetId,
    @Header('facilityId') String? facilityId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///List images
  ///@param imageType
  ///@param modelId Devie Model ID
  ///@param deviceId Device ID
  ///@param conditionid Condition ID
  ///@param alarmId Alarm ID
  ///@param controlId Control ID
  ///@param eventId Event ID
  ///@param triggerId Trigger ID
  ///@param body
  Future<chopper.Response<ImageFileArrayRes>> listImages({
    required enums.TwinImageListImageTypePostImageType? imageType,
    String? modelId,
    String? deviceId,
    String? conditionid,
    String? alarmId,
    String? controlId,
    String? eventId,
    String? triggerId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ImageFileArrayRes, () => ImageFileArrayRes.fromJsonFactory);

    return _listImages(
        imageType: imageType?.value?.toString(),
        modelId: modelId?.toString(),
        deviceId: deviceId?.toString(),
        conditionid: conditionid?.toString(),
        alarmId: alarmId?.toString(),
        controlId: controlId?.toString(),
        eventId: eventId?.toString(),
        triggerId: triggerId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///List images
  ///@param imageType
  ///@param modelId Devie Model ID
  ///@param deviceId Device ID
  ///@param conditionid Condition ID
  ///@param alarmId Alarm ID
  ///@param controlId Control ID
  ///@param eventId Event ID
  ///@param triggerId Trigger ID
  ///@param body
  @Post(path: '/TwinImage/list/{imageType}')
  Future<chopper.Response<ImageFileArrayRes>> _listImages({
    @Path('imageType') required String? imageType,
    @Header('modelId') String? modelId,
    @Header('deviceId') String? deviceId,
    @Header('conditionid') String? conditionid,
    @Header('alarmId') String? alarmId,
    @Header('controlId') String? controlId,
    @Header('eventId') String? eventId,
    @Header('triggerId') String? triggerId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Receive Events
  ///@param body
  Future<chopper.Response<Object>> receiveStripeEvents(
      {required Object? body}) {
    return _receiveStripeEvents(body: body);
  }

  ///Receive Events
  ///@param body
  @Post(path: '/stripe/webhook')
  Future<chopper.Response<Object>> _receiveStripeEvents(
      {@Body() required Object? body});

  ///Create role
  ///@param body
  Future<chopper.Response<RoleEntityRes>> createRole({
    required RoleInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(RoleInfo, () => RoleInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        RoleEntityRes, () => RoleEntityRes.fromJsonFactory);

    return _createRole(body: body, apikey: apikey?.toString());
  }

  ///Create role
  ///@param body
  @Post(path: '/Role/create')
  Future<chopper.Response<RoleEntityRes>> _createRole({
    @Body() required RoleInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update role
  ///@param roleId
  ///@param body
  Future<chopper.Response<RoleEntityRes>> updateRole({
    String? roleId,
    required RoleInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(RoleInfo, () => RoleInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        RoleEntityRes, () => RoleEntityRes.fromJsonFactory);

    return _updateRole(
        roleId: roleId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update role
  ///@param roleId
  ///@param body
  @Post(path: '/Role/update')
  Future<chopper.Response<RoleEntityRes>> _updateRole({
    @Header('roleId') String? roleId,
    @Body() required RoleInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete role
  ///@param roleId
  Future<chopper.Response<RoleEntityRes>> deleteRole({
    String? roleId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        RoleEntityRes, () => RoleEntityRes.fromJsonFactory);

    return _deleteRole(roleId: roleId?.toString(), apikey: apikey?.toString());
  }

  ///Delete role
  ///@param roleId
  @Delete(path: '/Role/remove')
  Future<chopper.Response<RoleEntityRes>> _deleteRole({
    @Header('roleId') String? roleId,
    @Header('APIKEY') String? apikey,
  });

  ///List roles
  ///@param modelId
  ///@param body
  Future<chopper.Response<RoleArrayRes>> listRoles({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        RoleArrayRes, () => RoleArrayRes.fromJsonFactory);

    return _listRoles(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List roles
  ///@param modelId
  ///@param body
  @Post(path: '/Role/list')
  Future<chopper.Response<RoleArrayRes>> _listRoles({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search roles
  ///@param modelId
  ///@param body
  Future<chopper.Response<RoleArrayRes>> searchRoles({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        RoleArrayRes, () => RoleArrayRes.fromJsonFactory);

    return _searchRoles(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search roles
  ///@param modelId
  ///@param body
  @Post(path: '/Role/search')
  Future<chopper.Response<RoleArrayRes>> _searchRoles({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get roles
  ///@param body
  Future<chopper.Response<RoleArrayRes>> getRoles({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        RoleArrayRes, () => RoleArrayRes.fromJsonFactory);

    return _getRoles(body: body, apikey: apikey?.toString());
  }

  ///Get roles
  ///@param body
  @Post(path: '/Role/get')
  Future<chopper.Response<RoleArrayRes>> _getRoles({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get role by id
  ///@param roleId
  Future<chopper.Response<RoleEntityRes>> getRole({
    required String? roleId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        RoleEntityRes, () => RoleEntityRes.fromJsonFactory);

    return _getRole(roleId: roleId, apikey: apikey?.toString());
  }

  ///get role by id
  ///@param roleId
  @Get(path: '/Role/one/{roleId}')
  Future<chopper.Response<RoleEntityRes>> _getRole({
    @Path('roleId') required String? roleId,
    @Header('APIKEY') String? apikey,
  });

  ///Create floor
  ///@param body
  Future<chopper.Response<FloorEntityRes>> createFloor({
    required FloorInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(FloorInfo, () => FloorInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FloorEntityRes, () => FloorEntityRes.fromJsonFactory);

    return _createFloor(body: body, apikey: apikey?.toString());
  }

  ///Create floor
  ///@param body
  @Post(path: '/Floor/create')
  Future<chopper.Response<FloorEntityRes>> _createFloor({
    @Body() required FloorInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update floor
  ///@param floorId
  ///@param body
  Future<chopper.Response<FloorEntityRes>> updateFloor({
    String? floorId,
    required FloorInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(FloorInfo, () => FloorInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FloorEntityRes, () => FloorEntityRes.fromJsonFactory);

    return _updateFloor(
        floorId: floorId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update floor
  ///@param floorId
  ///@param body
  @Post(path: '/Floor/update')
  Future<chopper.Response<FloorEntityRes>> _updateFloor({
    @Header('floorId') String? floorId,
    @Body() required FloorInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete floor
  ///@param floorId
  Future<chopper.Response<FloorEntityRes>> deleteFloor({
    String? floorId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FloorEntityRes, () => FloorEntityRes.fromJsonFactory);

    return _deleteFloor(
        floorId: floorId?.toString(), apikey: apikey?.toString());
  }

  ///Delete floor
  ///@param floorId
  @Delete(path: '/Floor/remove')
  Future<chopper.Response<FloorEntityRes>> _deleteFloor({
    @Header('floorId') String? floorId,
    @Header('APIKEY') String? apikey,
  });

  ///List floors
  ///@param facilityId
  ///@param body
  Future<chopper.Response<FloorArrayRes>> listFloors({
    String? facilityId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FloorArrayRes, () => FloorArrayRes.fromJsonFactory);

    return _listFloors(
        facilityId: facilityId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///List floors
  ///@param facilityId
  ///@param body
  @Post(path: '/Floor/list')
  Future<chopper.Response<FloorArrayRes>> _listFloors({
    @Header('facilityId') String? facilityId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search floors
  ///@param facilityId
  ///@param premiseId
  ///@param body
  Future<chopper.Response<FloorArrayRes>> searchFloors({
    String? facilityId,
    String? premiseId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FloorArrayRes, () => FloorArrayRes.fromJsonFactory);

    return _searchFloors(
        facilityId: facilityId?.toString(),
        premiseId: premiseId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search floors
  ///@param facilityId
  ///@param premiseId
  ///@param body
  @Post(path: '/Floor/search')
  Future<chopper.Response<FloorArrayRes>> _searchFloors({
    @Header('facilityId') String? facilityId,
    @Header('premiseId') String? premiseId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get floors
  ///@param body
  Future<chopper.Response<FloorArrayRes>> getFloors({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FloorArrayRes, () => FloorArrayRes.fromJsonFactory);

    return _getFloors(body: body, apikey: apikey?.toString());
  }

  ///Get floors
  ///@param body
  @Post(path: '/Floor/get')
  Future<chopper.Response<FloorArrayRes>> _getFloors({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get floor by id
  ///@param floorId
  Future<chopper.Response<FloorEntityRes>> getFloor({
    required String? floorId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FloorEntityRes, () => FloorEntityRes.fromJsonFactory);

    return _getFloor(floorId: floorId, apikey: apikey?.toString());
  }

  ///get floor by id
  ///@param floorId
  @Get(path: '/Floor/one/{floorId}')
  Future<chopper.Response<FloorEntityRes>> _getFloor({
    @Path('floorId') required String? floorId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<FloorArrayRes>> searchEqlFloor({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FloorArrayRes, () => FloorArrayRes.fromJsonFactory);

    return _searchEqlFloor(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Floor/eql')
  Future<chopper.Response<FloorArrayRes>> _searchEqlFloor({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Get stats
  ///@param floorId
  Future<chopper.Response<FloorStatsEntityRes>> getFloorStats({
    required String? floorId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FloorStatsEntityRes, () => FloorStatsEntityRes.fromJsonFactory);

    return _getFloorStats(floorId: floorId, apikey: apikey?.toString());
  }

  ///Get stats
  ///@param floorId
  @Get(path: '/Floor/stats/{floorId}')
  Future<chopper.Response<FloorStatsEntityRes>> _getFloorStats({
    @Path('floorId') required String? floorId,
    @Header('APIKEY') String? apikey,
  });

  ///query data
  ///@param body
  Future<chopper.Response<QueryRes>> queryFloor({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryFloor(body: body, apikey: apikey?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/Floor/query')
  Future<chopper.Response<QueryRes>> _queryFloor({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///count by query
  ///@param body
  Future<chopper.Response<CountRes>> queryCountFloor({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _queryCountFloor(body: body, apikey: apikey?.toString());
  }

  ///count by query
  ///@param body
  @Post(path: '/Floor/count/query')
  Future<chopper.Response<CountRes>> _queryCountFloor({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///Create asset
  ///@param body
  Future<chopper.Response<AssetEntityRes>> createAsset({
    required AssetInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(AssetInfo, () => AssetInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetEntityRes, () => AssetEntityRes.fromJsonFactory);

    return _createAsset(body: body, apikey: apikey?.toString());
  }

  ///Create asset
  ///@param body
  @Post(path: '/Asset/create')
  Future<chopper.Response<AssetEntityRes>> _createAsset({
    @Body() required AssetInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update asset
  ///@param assetId
  ///@param body
  Future<chopper.Response<AssetEntityRes>> updateAsset({
    String? assetId,
    required AssetInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(AssetInfo, () => AssetInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetEntityRes, () => AssetEntityRes.fromJsonFactory);

    return _updateAsset(
        assetId: assetId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update asset
  ///@param assetId
  ///@param body
  @Post(path: '/Asset/update')
  Future<chopper.Response<AssetEntityRes>> _updateAsset({
    @Header('assetId') String? assetId,
    @Body() required AssetInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete asset
  ///@param assetId
  Future<chopper.Response<AssetEntityRes>> deleteAsset({
    String? assetId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetEntityRes, () => AssetEntityRes.fromJsonFactory);

    return _deleteAsset(
        assetId: assetId?.toString(), apikey: apikey?.toString());
  }

  ///Delete asset
  ///@param assetId
  @Delete(path: '/Asset/remove')
  Future<chopper.Response<AssetEntityRes>> _deleteAsset({
    @Header('assetId') String? assetId,
    @Header('APIKEY') String? apikey,
  });

  ///List assets
  ///@param floorId
  ///@param body
  Future<chopper.Response<AssetArrayRes>> listAssets({
    String? floorId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetArrayRes, () => AssetArrayRes.fromJsonFactory);

    return _listAssets(
        floorId: floorId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List assets
  ///@param floorId
  ///@param body
  @Post(path: '/Asset/list')
  Future<chopper.Response<AssetArrayRes>> _listAssets({
    @Header('floorId') String? floorId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search assets
  ///@param floorId
  ///@param facilityId
  ///@param premiseId
  ///@param body
  Future<chopper.Response<AssetArrayRes>> searchAssets({
    String? floorId,
    String? facilityId,
    String? premiseId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetArrayRes, () => AssetArrayRes.fromJsonFactory);

    return _searchAssets(
        floorId: floorId?.toString(),
        facilityId: facilityId?.toString(),
        premiseId: premiseId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search assets
  ///@param floorId
  ///@param facilityId
  ///@param premiseId
  ///@param body
  @Post(path: '/Asset/search')
  Future<chopper.Response<AssetArrayRes>> _searchAssets({
    @Header('floorId') String? floorId,
    @Header('facilityId') String? facilityId,
    @Header('premiseId') String? premiseId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get assets
  ///@param body
  Future<chopper.Response<AssetArrayRes>> getAssets({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetArrayRes, () => AssetArrayRes.fromJsonFactory);

    return _getAssets(body: body, apikey: apikey?.toString());
  }

  ///Get assets
  ///@param body
  @Post(path: '/Asset/get')
  Future<chopper.Response<AssetArrayRes>> _getAssets({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get asset by id
  ///@param assetId
  Future<chopper.Response<AssetEntityRes>> getAsset({
    required String? assetId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetEntityRes, () => AssetEntityRes.fromJsonFactory);

    return _getAsset(assetId: assetId, apikey: apikey?.toString());
  }

  ///get asset by id
  ///@param assetId
  @Get(path: '/Asset/one/{assetId}')
  Future<chopper.Response<AssetEntityRes>> _getAsset({
    @Path('assetId') required String? assetId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<AssetArrayRes>> searchEqlAsset({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetArrayRes, () => AssetArrayRes.fromJsonFactory);

    return _searchEqlAsset(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Asset/eql')
  Future<chopper.Response<AssetArrayRes>> _searchEqlAsset({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///query data
  ///@param body
  Future<chopper.Response<QueryRes>> queryAsset({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryAsset(body: body, apikey: apikey?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/Asset/query')
  Future<chopper.Response<QueryRes>> _queryAsset({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///count by query
  ///@param body
  Future<chopper.Response<CountRes>> queryCountAsset({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _queryCountAsset(body: body, apikey: apikey?.toString());
  }

  ///count by query
  ///@param body
  @Post(path: '/Asset/count/query')
  Future<chopper.Response<CountRes>> _queryCountAsset({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///bulk upload assets
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetModelId
  ///@param deviceModelId
  ///@param clientIds
  ///@param roleIds
  ///@param file
  Future<chopper.Response<AssetBulkUploadRes>> bulkUploadAssets({
    String? premiseId,
    String? facilityId,
    String? floorId,
    String? assetModelId,
    String? deviceModelId,
    String? clientIds,
    String? roleIds,
    required List<int>? file,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetBulkUploadRes, () => AssetBulkUploadRes.fromJsonFactory);

    return _bulkUploadAssets(
        premiseId: premiseId?.toString(),
        facilityId: facilityId?.toString(),
        floorId: floorId?.toString(),
        assetModelId: assetModelId?.toString(),
        deviceModelId: deviceModelId?.toString(),
        clientIds: clientIds?.toString(),
        roleIds: roleIds?.toString(),
        file: file,
        apikey: apikey?.toString());
  }

  ///bulk upload assets
  ///@param premiseId
  ///@param facilityId
  ///@param floorId
  ///@param assetModelId
  ///@param deviceModelId
  ///@param clientIds
  ///@param roleIds
  ///@param file
  @Post(
    path: '/Asset/bulk/upload',
    optionalBody: true,
  )
  Future<chopper.Response<AssetBulkUploadRes>> _bulkUploadAssets({
    @Header('premiseId') String? premiseId,
    @Header('facilityId') String? facilityId,
    @Header('floorId') String? floorId,
    @Header('assetModelId') String? assetModelId,
    @Header('deviceModelId') String? deviceModelId,
    @Header('clientIds') String? clientIds,
    @Header('roleIds') String? roleIds,
    @Field('file') required List<int>? file,
    @Header('APIKEY') String? apikey,
  });

  ///Create facility
  ///@param body
  Future<chopper.Response<FacilityEntityRes>> createFacility({
    required FacilityInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FacilityInfo, () => FacilityInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FacilityEntityRes, () => FacilityEntityRes.fromJsonFactory);

    return _createFacility(body: body, apikey: apikey?.toString());
  }

  ///Create facility
  ///@param body
  @Post(path: '/Facility/create')
  Future<chopper.Response<FacilityEntityRes>> _createFacility({
    @Body() required FacilityInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update facility
  ///@param facilityId
  ///@param body
  Future<chopper.Response<FacilityEntityRes>> updateFacility({
    String? facilityId,
    required FacilityInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FacilityInfo, () => FacilityInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FacilityEntityRes, () => FacilityEntityRes.fromJsonFactory);

    return _updateFacility(
        facilityId: facilityId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update facility
  ///@param facilityId
  ///@param body
  @Post(path: '/Facility/update')
  Future<chopper.Response<FacilityEntityRes>> _updateFacility({
    @Header('facilityId') String? facilityId,
    @Body() required FacilityInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete facility
  ///@param facilityId
  Future<chopper.Response<FacilityEntityRes>> deleteFacility({
    String? facilityId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FacilityEntityRes, () => FacilityEntityRes.fromJsonFactory);

    return _deleteFacility(
        facilityId: facilityId?.toString(), apikey: apikey?.toString());
  }

  ///Delete facility
  ///@param facilityId
  @Delete(path: '/Facility/remove')
  Future<chopper.Response<FacilityEntityRes>> _deleteFacility({
    @Header('facilityId') String? facilityId,
    @Header('APIKEY') String? apikey,
  });

  ///List facilitys
  ///@param premiseId
  ///@param body
  Future<chopper.Response<FacilityArrayRes>> listFacilities({
    String? premiseId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FacilityArrayRes, () => FacilityArrayRes.fromJsonFactory);

    return _listFacilities(
        premiseId: premiseId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///List facilitys
  ///@param premiseId
  ///@param body
  @Post(path: '/Facility/list')
  Future<chopper.Response<FacilityArrayRes>> _listFacilities({
    @Header('premiseId') String? premiseId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search facilitys
  ///@param premiseId
  ///@param body
  Future<chopper.Response<FacilityArrayRes>> searchFacilities({
    String? premiseId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FacilityArrayRes, () => FacilityArrayRes.fromJsonFactory);

    return _searchFacilities(
        premiseId: premiseId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Search facilitys
  ///@param premiseId
  ///@param body
  @Post(path: '/Facility/search')
  Future<chopper.Response<FacilityArrayRes>> _searchFacilities({
    @Header('premiseId') String? premiseId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get facilitys
  ///@param body
  Future<chopper.Response<FacilityArrayRes>> getFacilities({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FacilityArrayRes, () => FacilityArrayRes.fromJsonFactory);

    return _getFacilities(body: body, apikey: apikey?.toString());
  }

  ///Get facilitys
  ///@param body
  @Post(path: '/Facility/get')
  Future<chopper.Response<FacilityArrayRes>> _getFacilities({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get facility by id
  ///@param facilityId
  Future<chopper.Response<FacilityEntityRes>> getFacility({
    required String? facilityId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FacilityEntityRes, () => FacilityEntityRes.fromJsonFactory);

    return _getFacility(facilityId: facilityId, apikey: apikey?.toString());
  }

  ///get facility by id
  ///@param facilityId
  @Get(path: '/Facility/one/{facilityId}')
  Future<chopper.Response<FacilityEntityRes>> _getFacility({
    @Path('facilityId') required String? facilityId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<FacilityArrayRes>> searchEqlFacility({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FacilityArrayRes, () => FacilityArrayRes.fromJsonFactory);

    return _searchEqlFacility(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Facility/eql')
  Future<chopper.Response<FacilityArrayRes>> _searchEqlFacility({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Get stats
  ///@param facilityId
  Future<chopper.Response<FacilityStatsEntityRes>> getFacilityStats({
    required String? facilityId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FacilityStatsEntityRes, () => FacilityStatsEntityRes.fromJsonFactory);

    return _getFacilityStats(
        facilityId: facilityId, apikey: apikey?.toString());
  }

  ///Get stats
  ///@param facilityId
  @Get(path: '/Facility/stats/{facilityId}')
  Future<chopper.Response<FacilityStatsEntityRes>> _getFacilityStats({
    @Path('facilityId') required String? facilityId,
    @Header('APIKEY') String? apikey,
  });

  ///query data
  ///@param body
  Future<chopper.Response<QueryRes>> queryFacility({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryFacility(body: body, apikey: apikey?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/Facility/query')
  Future<chopper.Response<QueryRes>> _queryFacility({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///count by query
  ///@param body
  Future<chopper.Response<CountRes>> queryCountFacility({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _queryCountFacility(body: body, apikey: apikey?.toString());
  }

  ///count by query
  ///@param body
  @Post(path: '/Facility/count/query')
  Future<chopper.Response<CountRes>> _queryCountFacility({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///Create twin user
  ///@param body
  Future<chopper.Response<TwinUserEntityRes>> createTwinUser({
    required TwinUserInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserInfo, () => TwinUserInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _createTwinUser(body: body, apikey: apikey?.toString());
  }

  ///Create twin user
  ///@param body
  @Post(path: '/TwinUser/create')
  Future<chopper.Response<TwinUserEntityRes>> _createTwinUser({
    @Body() required TwinUserInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update twin user
  ///@param twinUserId
  ///@param body
  Future<chopper.Response<TwinUserEntityRes>> updateTwinUser({
    String? twinUserId,
    required TwinUserInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserInfo, () => TwinUserInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _updateTwinUser(
        twinUserId: twinUserId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update twin user
  ///@param twinUserId
  ///@param body
  @Post(path: '/TwinUser/update')
  Future<chopper.Response<TwinUserEntityRes>> _updateTwinUser({
    @Header('twinUserId') String? twinUserId,
    @Body() required TwinUserInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete twin user
  ///@param twinUserId
  Future<chopper.Response<TwinUserEntityRes>> deleteTwinUser({
    String? twinUserId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _deleteTwinUser(
        twinUserId: twinUserId?.toString(), apikey: apikey?.toString());
  }

  ///Delete twin user
  ///@param twinUserId
  @Delete(path: '/TwinUser/remove')
  Future<chopper.Response<TwinUserEntityRes>> _deleteTwinUser({
    @Header('twinUserId') String? twinUserId,
    @Header('APIKEY') String? apikey,
  });

  ///List twin users
  ///@param body
  Future<chopper.Response<TwinUserArrayRes>> listTwinUsers({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TwinUserArrayRes, () => TwinUserArrayRes.fromJsonFactory);

    return _listTwinUsers(body: body, apikey: apikey?.toString());
  }

  ///List twin users
  ///@param body
  @Post(path: '/TwinUser/list')
  Future<chopper.Response<TwinUserArrayRes>> _listTwinUsers({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search twin users
  ///@param body
  Future<chopper.Response<TwinUserArrayRes>> searchTwinUsers({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserArrayRes, () => TwinUserArrayRes.fromJsonFactory);

    return _searchTwinUsers(body: body, apikey: apikey?.toString());
  }

  ///Search twin users
  ///@param body
  @Post(path: '/TwinUser/search')
  Future<chopper.Response<TwinUserArrayRes>> _searchTwinUsers({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get twin users
  ///@param body
  Future<chopper.Response<TwinUserArrayRes>> getTwinUsers({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        TwinUserArrayRes, () => TwinUserArrayRes.fromJsonFactory);

    return _getTwinUsers(body: body, apikey: apikey?.toString());
  }

  ///Get twin users
  ///@param body
  @Post(path: '/TwinUser/get')
  Future<chopper.Response<TwinUserArrayRes>> _getTwinUsers({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get twin user by id
  ///@param twinUserId
  Future<chopper.Response<TwinUserEntityRes>> getTwinUser({
    required String? twinUserId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _getTwinUser(twinUserId: twinUserId, apikey: apikey?.toString());
  }

  ///get twin user by id
  ///@param twinUserId
  @Get(path: '/TwinUser/one/{twinUserId}')
  Future<chopper.Response<TwinUserEntityRes>> _getTwinUser({
    @Path('twinUserId') required String? twinUserId,
    @Header('APIKEY') String? apikey,
  });

  ///get my profile
  Future<chopper.Response<TwinUserEntityRes>> getMyProfile({dynamic apikey}) {
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _getMyProfile(apikey: apikey?.toString());
  }

  ///get my profile
  @Get(path: '/TwinUser/myprofile')
  Future<chopper.Response<TwinUserEntityRes>> _getMyProfile(
      {@Header('APIKEY') String? apikey});

  ///reset user password
  ///@param twinUserId
  Future<chopper.Response<TwinUserEntityRes>> resetTwinUserPassword({
    String? twinUserId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _resetTwinUserPassword(
        twinUserId: twinUserId?.toString(), apikey: apikey?.toString());
  }

  ///reset user password
  ///@param twinUserId
  @Get(path: '/TwinUser/password/reset')
  Future<chopper.Response<TwinUserEntityRes>> _resetTwinUserPassword({
    @Header('twinUserId') String? twinUserId,
    @Header('APIKEY') String? apikey,
  });

  ///set twin user as admin
  ///@param twinUserId
  Future<chopper.Response<TwinUserEntityRes>> setAdmin({
    required String? twinUserId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _setAdmin(twinUserId: twinUserId, apikey: apikey?.toString());
  }

  ///set twin user as admin
  ///@param twinUserId
  @Get(path: '/TwinUser/set/admin/{twinUserId}')
  Future<chopper.Response<TwinUserEntityRes>> _setAdmin({
    @Path('twinUserId') required String? twinUserId,
    @Header('APIKEY') String? apikey,
  });

  ///set twin user as regular user
  ///@param twinUserId
  Future<chopper.Response<TwinUserEntityRes>> unsetAdmin({
    required String? twinUserId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _unsetAdmin(twinUserId: twinUserId, apikey: apikey?.toString());
  }

  ///set twin user as regular user
  ///@param twinUserId
  @Get(path: '/TwinUser/unset/admin/{twinUserId}')
  Future<chopper.Response<TwinUserEntityRes>> _unsetAdmin({
    @Path('twinUserId') required String? twinUserId,
    @Header('APIKEY') String? apikey,
  });

  ///set twin user as client admin
  ///@param twinUserId
  ///@param clientId
  Future<chopper.Response<TwinUserEntityRes>> setClientAdmin({
    required String? twinUserId,
    required String? clientId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _setClientAdmin(
        twinUserId: twinUserId, clientId: clientId, apikey: apikey?.toString());
  }

  ///set twin user as client admin
  ///@param twinUserId
  ///@param clientId
  @Get(path: '/TwinUser/set/client/admin/{twinUserId}/{clientId}')
  Future<chopper.Response<TwinUserEntityRes>> _setClientAdmin({
    @Path('twinUserId') required String? twinUserId,
    @Path('clientId') required String? clientId,
    @Header('APIKEY') String? apikey,
  });

  ///set twin user as regular client user
  ///@param twinUserId
  ///@param clientId
  Future<chopper.Response<TwinUserEntityRes>> unsetClientAdmin({
    required String? twinUserId,
    required String? clientId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        TwinUserEntityRes, () => TwinUserEntityRes.fromJsonFactory);

    return _unsetClientAdmin(
        twinUserId: twinUserId, clientId: clientId, apikey: apikey?.toString());
  }

  ///set twin user as regular client user
  ///@param twinUserId
  ///@param clientId
  @Get(path: '/TwinUser/unset/client/admin/{twinUserId}/{clientId}')
  Future<chopper.Response<TwinUserEntityRes>> _unsetClientAdmin({
    @Path('twinUserId') required String? twinUserId,
    @Path('clientId') required String? clientId,
    @Header('APIKEY') String? apikey,
  });

  ///Change password
  ///@param body
  Future<chopper.Response<BaseResponse>> changePassword({
    required ChangePassReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ChangePassReq, () => ChangePassReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        BaseResponse, () => BaseResponse.fromJsonFactory);

    return _changePassword(body: body, apikey: apikey?.toString());
  }

  ///Change password
  ///@param body
  @Post(path: '/TwinUser/change/password')
  Future<chopper.Response<BaseResponse>> _changePassword({
    @Body() required ChangePassReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///count
  Future<chopper.Response<CountRes>> countTwinUsers({dynamic apikey}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countTwinUsers(apikey: apikey?.toString());
  }

  ///count
  @Get(path: '/TwinUser/count')
  Future<chopper.Response<CountRes>> _countTwinUsers(
      {@Header('APIKEY') String? apikey});

  ///Create premise
  ///@param body
  Future<chopper.Response<PremiseEntityRes>> createPremise({
    required PremiseInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PremiseInfo, () => PremiseInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        PremiseEntityRes, () => PremiseEntityRes.fromJsonFactory);

    return _createPremise(body: body, apikey: apikey?.toString());
  }

  ///Create premise
  ///@param body
  @Post(path: '/Premise/create')
  Future<chopper.Response<PremiseEntityRes>> _createPremise({
    @Body() required PremiseInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update premise
  ///@param premiseId
  ///@param body
  Future<chopper.Response<PremiseEntityRes>> updatePremise({
    String? premiseId,
    required PremiseInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PremiseInfo, () => PremiseInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        PremiseEntityRes, () => PremiseEntityRes.fromJsonFactory);

    return _updatePremise(
        premiseId: premiseId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update premise
  ///@param premiseId
  ///@param body
  @Post(path: '/Premise/update')
  Future<chopper.Response<PremiseEntityRes>> _updatePremise({
    @Header('premiseId') String? premiseId,
    @Body() required PremiseInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete premise
  ///@param premiseId
  Future<chopper.Response<PremiseEntityRes>> deletePremise({
    String? premiseId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PremiseEntityRes, () => PremiseEntityRes.fromJsonFactory);

    return _deletePremise(
        premiseId: premiseId?.toString(), apikey: apikey?.toString());
  }

  ///Delete premise
  ///@param premiseId
  @Delete(path: '/Premise/remove')
  Future<chopper.Response<PremiseEntityRes>> _deletePremise({
    @Header('premiseId') String? premiseId,
    @Header('APIKEY') String? apikey,
  });

  ///List premises
  ///@param body
  Future<chopper.Response<PremiseArrayRes>> listPremises({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        PremiseArrayRes, () => PremiseArrayRes.fromJsonFactory);

    return _listPremises(body: body, apikey: apikey?.toString());
  }

  ///List premises
  ///@param body
  @Post(path: '/Premise/list')
  Future<chopper.Response<PremiseArrayRes>> _listPremises({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search premises
  ///@param body
  Future<chopper.Response<PremiseArrayRes>> searchPremises({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PremiseArrayRes, () => PremiseArrayRes.fromJsonFactory);

    return _searchPremises(body: body, apikey: apikey?.toString());
  }

  ///Search premises
  ///@param body
  @Post(path: '/Premise/search')
  Future<chopper.Response<PremiseArrayRes>> _searchPremises({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get premises
  ///@param body
  Future<chopper.Response<PremiseArrayRes>> getPremises({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        PremiseArrayRes, () => PremiseArrayRes.fromJsonFactory);

    return _getPremises(body: body, apikey: apikey?.toString());
  }

  ///Get premises
  ///@param body
  @Post(path: '/Premise/get')
  Future<chopper.Response<PremiseArrayRes>> _getPremises({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get premise by id
  ///@param premiseId
  Future<chopper.Response<PremiseEntityRes>> getPremise({
    required String? premiseId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PremiseEntityRes, () => PremiseEntityRes.fromJsonFactory);

    return _getPremise(premiseId: premiseId, apikey: apikey?.toString());
  }

  ///get premise by id
  ///@param premiseId
  @Get(path: '/Premise/one/{premiseId}')
  Future<chopper.Response<PremiseEntityRes>> _getPremise({
    @Path('premiseId') required String? premiseId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<PremiseArrayRes>> searchEqlPremise({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PremiseArrayRes, () => PremiseArrayRes.fromJsonFactory);

    return _searchEqlPremise(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Premise/eql')
  Future<chopper.Response<PremiseArrayRes>> _searchEqlPremise({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Get stats
  ///@param premiseId
  Future<chopper.Response<PremiseStatsEntityRes>> getPremiseStats({
    required String? premiseId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        PremiseStatsEntityRes, () => PremiseStatsEntityRes.fromJsonFactory);

    return _getPremiseStats(premiseId: premiseId, apikey: apikey?.toString());
  }

  ///Get stats
  ///@param premiseId
  @Get(path: '/Premise/stats/{premiseId}')
  Future<chopper.Response<PremiseStatsEntityRes>> _getPremiseStats({
    @Path('premiseId') required String? premiseId,
    @Header('APIKEY') String? apikey,
  });

  ///query data
  ///@param body
  Future<chopper.Response<QueryRes>> queryPremise({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(QueryRes, () => QueryRes.fromJsonFactory);

    return _queryPremise(body: body, apikey: apikey?.toString());
  }

  ///query data
  ///@param body
  @Post(path: '/Premise/query')
  Future<chopper.Response<QueryRes>> _queryPremise({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///count by query
  ///@param body
  Future<chopper.Response<CountRes>> queryCountPremise({
    required EqlSearch? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(EqlSearch, () => EqlSearch.fromJsonFactory);
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _queryCountPremise(body: body, apikey: apikey?.toString());
  }

  ///count by query
  ///@param body
  @Post(path: '/Premise/count/query')
  Future<chopper.Response<CountRes>> _queryCountPremise({
    @Body() required EqlSearch? body,
    @Header('APIKEY') String? apikey,
  });

  ///Create scrapping table
  ///@param body
  Future<chopper.Response<ScrappingTableEntityRes>> createScrappingTable({
    required ScrappingTableInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScrappingTableInfo, () => ScrappingTableInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ScrappingTableEntityRes, () => ScrappingTableEntityRes.fromJsonFactory);

    return _createScrappingTable(body: body, apikey: apikey?.toString());
  }

  ///Create scrapping table
  ///@param body
  @Post(path: '/ScrappingTable/create')
  Future<chopper.Response<ScrappingTableEntityRes>> _createScrappingTable({
    @Body() required ScrappingTableInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update scrapping table
  ///@param scrappingTableId
  ///@param body
  Future<chopper.Response<ScrappingTableEntityRes>> updateScrappingTable({
    String? scrappingTableId,
    required ScrappingTableInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScrappingTableInfo, () => ScrappingTableInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ScrappingTableEntityRes, () => ScrappingTableEntityRes.fromJsonFactory);

    return _updateScrappingTable(
        scrappingTableId: scrappingTableId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update scrapping table
  ///@param scrappingTableId
  ///@param body
  @Post(path: '/ScrappingTable/update')
  Future<chopper.Response<ScrappingTableEntityRes>> _updateScrappingTable({
    @Header('scrappingTableId') String? scrappingTableId,
    @Body() required ScrappingTableInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete scrappingTable
  ///@param scrappingTableid
  Future<chopper.Response<ScrappingTableEntityRes>> deleteScrappingTable({
    String? scrappingTableid,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScrappingTableEntityRes, () => ScrappingTableEntityRes.fromJsonFactory);

    return _deleteScrappingTable(
        scrappingTableid: scrappingTableid?.toString(),
        apikey: apikey?.toString());
  }

  ///Delete scrappingTable
  ///@param scrappingTableid
  @Delete(path: '/ScrappingTable/remove')
  Future<chopper.Response<ScrappingTableEntityRes>> _deleteScrappingTable({
    @Header('scrappingTableid') String? scrappingTableid,
    @Header('APIKEY') String? apikey,
  });

  ///List scrapping tables
  ///@param body
  Future<chopper.Response<ScrappingTableArrayRes>> listScrappingTables({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ScrappingTableArrayRes, () => ScrappingTableArrayRes.fromJsonFactory);

    return _listScrappingTables(body: body, apikey: apikey?.toString());
  }

  ///List scrapping tables
  ///@param body
  @Post(path: '/ScrappingTable/list')
  Future<chopper.Response<ScrappingTableArrayRes>> _listScrappingTables({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search scrapping tables
  ///@param body
  Future<chopper.Response<ScrappingTableArrayRes>> searchScrappingTables({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScrappingTableArrayRes, () => ScrappingTableArrayRes.fromJsonFactory);

    return _searchScrappingTables(body: body, apikey: apikey?.toString());
  }

  ///Search scrapping tables
  ///@param body
  @Post(path: '/ScrappingTable/search')
  Future<chopper.Response<ScrappingTableArrayRes>> _searchScrappingTables({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get scrapping tables
  ///@param body
  Future<chopper.Response<ScrappingTableArrayRes>> getScrappingTables({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ScrappingTableArrayRes, () => ScrappingTableArrayRes.fromJsonFactory);

    return _getScrappingTables(body: body, apikey: apikey?.toString());
  }

  ///Get scrapping tables
  ///@param body
  @Post(path: '/ScrappingTable/get')
  Future<chopper.Response<ScrappingTableArrayRes>> _getScrappingTables({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get scrapping table by id
  ///@param scrappingTableId
  Future<chopper.Response<ScrappingTableEntityRes>> getScrappingTable({
    required String? scrappingTableId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ScrappingTableEntityRes, () => ScrappingTableEntityRes.fromJsonFactory);

    return _getScrappingTable(
        scrappingTableId: scrappingTableId, apikey: apikey?.toString());
  }

  ///get scrapping table by id
  ///@param scrappingTableId
  @Get(path: '/ScrappingTable/one/{scrappingTableId}')
  Future<chopper.Response<ScrappingTableEntityRes>> _getScrappingTable({
    @Path('scrappingTableId') required String? scrappingTableId,
    @Header('APIKEY') String? apikey,
  });

  ///Create Asset Group
  ///@param body
  Future<chopper.Response<AssetGroupEntityRes>> createAssetGroup({
    required AssetGroupInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetGroupInfo, () => AssetGroupInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetGroupEntityRes, () => AssetGroupEntityRes.fromJsonFactory);

    return _createAssetGroup(body: body, apikey: apikey?.toString());
  }

  ///Create Asset Group
  ///@param body
  @Post(path: '/AssetGroup/create')
  Future<chopper.Response<AssetGroupEntityRes>> _createAssetGroup({
    @Body() required AssetGroupInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update Asset Group
  ///@param assetGroupId
  ///@param body
  Future<chopper.Response<AssetGroupEntityRes>> updateAssetGroup({
    String? assetGroupId,
    required AssetGroupInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetGroupInfo, () => AssetGroupInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetGroupEntityRes, () => AssetGroupEntityRes.fromJsonFactory);

    return _updateAssetGroup(
        assetGroupId: assetGroupId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update Asset Group
  ///@param assetGroupId
  ///@param body
  @Post(path: '/AssetGroup/update')
  Future<chopper.Response<AssetGroupEntityRes>> _updateAssetGroup({
    @Header('assetGroupId') String? assetGroupId,
    @Body() required AssetGroupInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete Asset Group
  ///@param assetGroupId
  Future<chopper.Response<AssetGroupEntityRes>> deleteAssetGroup({
    String? assetGroupId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetGroupEntityRes, () => AssetGroupEntityRes.fromJsonFactory);

    return _deleteAssetGroup(
        assetGroupId: assetGroupId?.toString(), apikey: apikey?.toString());
  }

  ///Delete Asset Group
  ///@param assetGroupId
  @Delete(path: '/AssetGroup/remove')
  Future<chopper.Response<AssetGroupEntityRes>> _deleteAssetGroup({
    @Header('assetGroupId') String? assetGroupId,
    @Header('APIKEY') String? apikey,
  });

  ///List Asset Groups
  ///@param myGroups
  ///@param body
  Future<chopper.Response<AssetGroupArrayRes>> listAssetGroups({
    bool? myGroups,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetGroupArrayRes, () => AssetGroupArrayRes.fromJsonFactory);

    return _listAssetGroups(
        myGroups: myGroups?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List Asset Groups
  ///@param myGroups
  ///@param body
  @Post(path: '/AssetGroup/list')
  Future<chopper.Response<AssetGroupArrayRes>> _listAssetGroups({
    @Header('myGroups') String? myGroups,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Create report
  ///@param body
  Future<chopper.Response<ReportEntityRes>> createReport({
    required ReportInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ReportInfo, () => ReportInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ReportEntityRes, () => ReportEntityRes.fromJsonFactory);

    return _createReport(body: body, apikey: apikey?.toString());
  }

  ///Create report
  ///@param body
  @Post(path: '/Report/create')
  Future<chopper.Response<ReportEntityRes>> _createReport({
    @Body() required ReportInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update report
  ///@param reportId
  ///@param body
  Future<chopper.Response<ReportEntityRes>> updateReport({
    String? reportId,
    required ReportInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ReportInfo, () => ReportInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ReportEntityRes, () => ReportEntityRes.fromJsonFactory);

    return _updateReport(
        reportId: reportId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update report
  ///@param reportId
  ///@param body
  @Post(path: '/Report/update')
  Future<chopper.Response<ReportEntityRes>> _updateReport({
    @Header('reportId') String? reportId,
    @Body() required ReportInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete report
  ///@param reportId
  Future<chopper.Response<ReportEntityRes>> deleteReport({
    String? reportId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ReportEntityRes, () => ReportEntityRes.fromJsonFactory);

    return _deleteReport(
        reportId: reportId?.toString(), apikey: apikey?.toString());
  }

  ///Delete report
  ///@param reportId
  @Delete(path: '/Report/remove')
  Future<chopper.Response<ReportEntityRes>> _deleteReport({
    @Header('reportId') String? reportId,
    @Header('APIKEY') String? apikey,
  });

  ///List reports
  ///@param modelId
  ///@param body
  Future<chopper.Response<ReportArrayRes>> listReports({
    String? modelId,
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ReportArrayRes, () => ReportArrayRes.fromJsonFactory);

    return _listReports(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///List reports
  ///@param modelId
  ///@param body
  @Post(path: '/Report/list')
  Future<chopper.Response<ReportArrayRes>> _listReports({
    @Header('modelId') String? modelId,
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search reports
  ///@param modelId
  ///@param body
  Future<chopper.Response<ReportArrayRes>> searchReports({
    String? modelId,
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ReportArrayRes, () => ReportArrayRes.fromJsonFactory);

    return _searchReports(
        modelId: modelId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Search reports
  ///@param modelId
  ///@param body
  @Post(path: '/Report/search')
  Future<chopper.Response<ReportArrayRes>> _searchReports({
    @Header('modelId') String? modelId,
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get reports
  ///@param body
  Future<chopper.Response<ReportArrayRes>> getReports({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ReportArrayRes, () => ReportArrayRes.fromJsonFactory);

    return _getReports(body: body, apikey: apikey?.toString());
  }

  ///Get reports
  ///@param body
  @Post(path: '/Report/get')
  Future<chopper.Response<ReportArrayRes>> _getReports({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get report by id
  ///@param reportId
  Future<chopper.Response<ReportEntityRes>> getReport({
    required String? reportId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ReportEntityRes, () => ReportEntityRes.fromJsonFactory);

    return _getReport(reportId: reportId, apikey: apikey?.toString());
  }

  ///get report by id
  ///@param reportId
  @Get(path: '/Report/one/{reportId}')
  Future<chopper.Response<ReportEntityRes>> _getReport({
    @Path('reportId') required String? reportId,
    @Header('APIKEY') String? apikey,
  });

  ///Create asset model
  ///@param body
  Future<chopper.Response<AssetModelEntityRes>> createAssetModel({
    required AssetModelInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetModelInfo, () => AssetModelInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetModelEntityRes, () => AssetModelEntityRes.fromJsonFactory);

    return _createAssetModel(body: body, apikey: apikey?.toString());
  }

  ///Create asset model
  ///@param body
  @Post(path: '/AssetModel/create')
  Future<chopper.Response<AssetModelEntityRes>> _createAssetModel({
    @Body() required AssetModelInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update asset model
  ///@param assetModelId
  ///@param body
  Future<chopper.Response<AssetModelEntityRes>> updateAssetModel({
    String? assetModelId,
    required AssetModelInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetModelInfo, () => AssetModelInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetModelEntityRes, () => AssetModelEntityRes.fromJsonFactory);

    return _updateAssetModel(
        assetModelId: assetModelId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update asset model
  ///@param assetModelId
  ///@param body
  @Post(path: '/AssetModel/update')
  Future<chopper.Response<AssetModelEntityRes>> _updateAssetModel({
    @Header('assetModelId') String? assetModelId,
    @Body() required AssetModelInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete asset model
  ///@param assetModelId
  Future<chopper.Response<AssetModelEntityRes>> deleteAssetModel({
    String? assetModelId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetModelEntityRes, () => AssetModelEntityRes.fromJsonFactory);

    return _deleteAssetModel(
        assetModelId: assetModelId?.toString(), apikey: apikey?.toString());
  }

  ///Delete asset model
  ///@param assetModelId
  @Delete(path: '/AssetModel/remove')
  Future<chopper.Response<AssetModelEntityRes>> _deleteAssetModel({
    @Header('assetModelId') String? assetModelId,
    @Header('APIKEY') String? apikey,
  });

  ///List asset models
  ///@param body
  Future<chopper.Response<AssetModelArrayRes>> listAssetModels({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetModelArrayRes, () => AssetModelArrayRes.fromJsonFactory);

    return _listAssetModels(body: body, apikey: apikey?.toString());
  }

  ///List asset models
  ///@param body
  @Post(path: '/AssetModel/list')
  Future<chopper.Response<AssetModelArrayRes>> _listAssetModels({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search asset models
  ///@param body
  Future<chopper.Response<AssetModelArrayRes>> searchAssetModels({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetModelArrayRes, () => AssetModelArrayRes.fromJsonFactory);

    return _searchAssetModels(body: body, apikey: apikey?.toString());
  }

  ///Search asset models
  ///@param body
  @Post(path: '/AssetModel/search')
  Future<chopper.Response<AssetModelArrayRes>> _searchAssetModels({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get asset models
  ///@param body
  Future<chopper.Response<AssetModelArrayRes>> getAssetModels({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        AssetModelArrayRes, () => AssetModelArrayRes.fromJsonFactory);

    return _getAssetModels(body: body, apikey: apikey?.toString());
  }

  ///Get asset models
  ///@param body
  @Post(path: '/AssetModel/get')
  Future<chopper.Response<AssetModelArrayRes>> _getAssetModels({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get asset model by id
  ///@param assetModelId
  Future<chopper.Response<AssetModelEntityRes>> getAssetModel({
    required String? assetModelId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetModelEntityRes, () => AssetModelEntityRes.fromJsonFactory);

    return _getAssetModel(
        assetModelId: assetModelId, apikey: apikey?.toString());
  }

  ///get asset model by id
  ///@param assetModelId
  @Get(path: '/AssetModel/one/{assetModelId}')
  Future<chopper.Response<AssetModelEntityRes>> _getAssetModel({
    @Path('assetModelId') required String? assetModelId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<AssetModelArrayRes>> searchEqlAssetModel({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        AssetModelArrayRes, () => AssetModelArrayRes.fromJsonFactory);

    return _searchEqlAssetModel(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/AssetModel/eql')
  Future<chopper.Response<AssetModelArrayRes>> _searchEqlAssetModel({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create field filter
  ///@param body
  Future<chopper.Response<FieldFilterEntityRes>> createFieldFilter({
    required FieldFilterInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FieldFilterInfo, () => FieldFilterInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FieldFilterEntityRes, () => FieldFilterEntityRes.fromJsonFactory);

    return _createFieldFilter(body: body, apikey: apikey?.toString());
  }

  ///Create field filter
  ///@param body
  @Post(path: '/FieldFilter/create')
  Future<chopper.Response<FieldFilterEntityRes>> _createFieldFilter({
    @Body() required FieldFilterInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update field filter
  ///@param fieldFilterId
  ///@param body
  Future<chopper.Response<FieldFilterEntityRes>> updateFieldFilter({
    String? fieldFilterId,
    required FieldFilterInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FieldFilterInfo, () => FieldFilterInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FieldFilterEntityRes, () => FieldFilterEntityRes.fromJsonFactory);

    return _updateFieldFilter(
        fieldFilterId: fieldFilterId?.toString(),
        body: body,
        apikey: apikey?.toString());
  }

  ///Update field filter
  ///@param fieldFilterId
  ///@param body
  @Post(path: '/FieldFilter/update')
  Future<chopper.Response<FieldFilterEntityRes>> _updateFieldFilter({
    @Header('fieldFilterId') String? fieldFilterId,
    @Body() required FieldFilterInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete field filter
  ///@param fieldFilterId
  Future<chopper.Response<FieldFilterEntityRes>> deleteFieldFilter({
    String? fieldFilterId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FieldFilterEntityRes, () => FieldFilterEntityRes.fromJsonFactory);

    return _deleteFieldFilter(
        fieldFilterId: fieldFilterId?.toString(), apikey: apikey?.toString());
  }

  ///Delete field filter
  ///@param fieldFilterId
  @Delete(path: '/FieldFilter/remove')
  Future<chopper.Response<FieldFilterEntityRes>> _deleteFieldFilter({
    @Header('fieldFilterId') String? fieldFilterId,
    @Header('APIKEY') String? apikey,
  });

  ///List field filters
  ///@param body
  Future<chopper.Response<FieldFilterArrayRes>> listFieldFilters({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FieldFilterArrayRes, () => FieldFilterArrayRes.fromJsonFactory);

    return _listFieldFilters(body: body, apikey: apikey?.toString());
  }

  ///List field filters
  ///@param body
  @Post(path: '/FieldFilter/list')
  Future<chopper.Response<FieldFilterArrayRes>> _listFieldFilters({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search field filters
  ///@param body
  Future<chopper.Response<FieldFilterArrayRes>> searchFieldFilters({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FieldFilterArrayRes, () => FieldFilterArrayRes.fromJsonFactory);

    return _searchFieldFilters(body: body, apikey: apikey?.toString());
  }

  ///Search field filters
  ///@param body
  @Post(path: '/FieldFilter/search')
  Future<chopper.Response<FieldFilterArrayRes>> _searchFieldFilters({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get field filters
  ///@param body
  Future<chopper.Response<FieldFilterArrayRes>> getFieldFilters({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        FieldFilterArrayRes, () => FieldFilterArrayRes.fromJsonFactory);

    return _getFieldFilters(body: body, apikey: apikey?.toString());
  }

  ///Get field filters
  ///@param body
  @Post(path: '/FieldFilter/get')
  Future<chopper.Response<FieldFilterArrayRes>> _getFieldFilters({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get field filter by id
  ///@param fieldFilterId
  Future<chopper.Response<FieldFilterEntityRes>> getFieldFilter({
    required String? fieldFilterId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FieldFilterEntityRes, () => FieldFilterEntityRes.fromJsonFactory);

    return _getFieldFilter(
        fieldFilterId: fieldFilterId, apikey: apikey?.toString());
  }

  ///get field filter by id
  ///@param fieldFilterId
  @Get(path: '/FieldFilter/one/{fieldFilterId}')
  Future<chopper.Response<FieldFilterEntityRes>> _getFieldFilter({
    @Path('fieldFilterId') required String? fieldFilterId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<FieldFilterArrayRes>> searchEqlFieldFilter({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        FieldFilterArrayRes, () => FieldFilterArrayRes.fromJsonFactory);

    return _searchEqlFieldFilter(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/FieldFilter/eql')
  Future<chopper.Response<FieldFilterArrayRes>> _searchEqlFieldFilter({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///Create client
  ///@param body
  Future<chopper.Response<ClientEntityRes>> createClient({
    required ClientInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ClientInfo, () => ClientInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ClientEntityRes, () => ClientEntityRes.fromJsonFactory);

    return _createClient(body: body, apikey: apikey?.toString());
  }

  ///Create client
  ///@param body
  @Post(path: '/Client/create')
  Future<chopper.Response<ClientEntityRes>> _createClient({
    @Body() required ClientInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Update client
  ///@param clientId
  ///@param body
  Future<chopper.Response<ClientEntityRes>> updateClient({
    String? clientId,
    required ClientInfo? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ClientInfo, () => ClientInfo.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ClientEntityRes, () => ClientEntityRes.fromJsonFactory);

    return _updateClient(
        clientId: clientId?.toString(), body: body, apikey: apikey?.toString());
  }

  ///Update client
  ///@param clientId
  ///@param body
  @Post(path: '/Client/update')
  Future<chopper.Response<ClientEntityRes>> _updateClient({
    @Header('clientId') String? clientId,
    @Body() required ClientInfo? body,
    @Header('APIKEY') String? apikey,
  });

  ///Delete client
  ///@param clientId
  Future<chopper.Response<ClientEntityRes>> deleteClient({
    String? clientId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ClientEntityRes, () => ClientEntityRes.fromJsonFactory);

    return _deleteClient(
        clientId: clientId?.toString(), apikey: apikey?.toString());
  }

  ///Delete client
  ///@param clientId
  @Delete(path: '/Client/remove')
  Future<chopper.Response<ClientEntityRes>> _deleteClient({
    @Header('clientId') String? clientId,
    @Header('APIKEY') String? apikey,
  });

  ///List clients
  ///@param body
  Future<chopper.Response<ClientArrayRes>> listClients({
    required ListReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(ListReq, () => ListReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ClientArrayRes, () => ClientArrayRes.fromJsonFactory);

    return _listClients(body: body, apikey: apikey?.toString());
  }

  ///List clients
  ///@param body
  @Post(path: '/Client/list')
  Future<chopper.Response<ClientArrayRes>> _listClients({
    @Body() required ListReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Search clients
  ///@param body
  Future<chopper.Response<ClientArrayRes>> searchClients({
    required SearchReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ClientArrayRes, () => ClientArrayRes.fromJsonFactory);

    return _searchClients(body: body, apikey: apikey?.toString());
  }

  ///Search clients
  ///@param body
  @Post(path: '/Client/search')
  Future<chopper.Response<ClientArrayRes>> _searchClients({
    @Body() required SearchReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///Get clients
  ///@param body
  Future<chopper.Response<ClientArrayRes>> getClients({
    required GetReq? body,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(GetReq, () => GetReq.fromJsonFactory);
    generatedMapping.putIfAbsent(
        ClientArrayRes, () => ClientArrayRes.fromJsonFactory);

    return _getClients(body: body, apikey: apikey?.toString());
  }

  ///Get clients
  ///@param body
  @Post(path: '/Client/get')
  Future<chopper.Response<ClientArrayRes>> _getClients({
    @Body() required GetReq? body,
    @Header('APIKEY') String? apikey,
  });

  ///get client by id
  ///@param clientId
  Future<chopper.Response<ClientEntityRes>> getClient({
    required String? clientId,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ClientEntityRes, () => ClientEntityRes.fromJsonFactory);

    return _getClient(clientId: clientId, apikey: apikey?.toString());
  }

  ///get client by id
  ///@param clientId
  @Get(path: '/Client/one/{clientId}')
  Future<chopper.Response<ClientEntityRes>> _getClient({
    @Path('clientId') required String? clientId,
    @Header('APIKEY') String? apikey,
  });

  ///Search using SQL
  ///@param eql
  Future<chopper.Response<ClientArrayRes>> searchEqlClient({
    required Object? eql,
    dynamic apikey,
  }) {
    generatedMapping.putIfAbsent(
        ClientArrayRes, () => ClientArrayRes.fromJsonFactory);

    return _searchEqlClient(eql: eql, apikey: apikey?.toString());
  }

  ///Search using SQL
  ///@param eql
  @Post(path: '/Client/eql')
  Future<chopper.Response<ClientArrayRes>> _searchEqlClient({
    @Body() required Object? eql,
    @Header('APIKEY') String? apikey,
  });

  ///count
  Future<chopper.Response<CountRes>> countClients({dynamic apikey}) {
    generatedMapping.putIfAbsent(CountRes, () => CountRes.fromJsonFactory);

    return _countClients(apikey: apikey?.toString());
  }

  ///count
  @Get(path: '/Client/count')
  Future<chopper.Response<CountRes>> _countClients(
      {@Header('APIKEY') String? apikey});
}

@JsonSerializable(explicitToJson: true)
class BaseResponse {
  const BaseResponse({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory BaseResponse.fromJson(Map<String, dynamic> json) =>
      _$BaseResponseFromJson(json);

  static const toJsonFactory = _$BaseResponseToJson;
  Map<String, dynamic> toJson() => _$BaseResponseToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$BaseResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseResponse &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $BaseResponseExtension on BaseResponse {
  BaseResponse copyWith(
      {bool? ok, String? msg, String? trace, String? errorCode}) {
    return BaseResponse(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode);
  }

  BaseResponse copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode}) {
    return BaseResponse(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode));
  }
}

@JsonSerializable(explicitToJson: true)
class BaseEntity {
  const BaseEntity({
    required this.domainKey,
    required this.id,
    required this.name,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
    this.tags,
  });

  factory BaseEntity.fromJson(Map<String, dynamic> json) =>
      _$BaseEntityFromJson(json);

  static const toJsonFactory = _$BaseEntityToJson;
  Map<String, dynamic> toJson() => _$BaseEntityToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$BaseEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseEntity &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $BaseEntityExtension on BaseEntity {
  BaseEntity copyWith(
      {String? domainKey,
      String? id,
      String? name,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      List<String>? tags}) {
    return BaseEntity(
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        name: name ?? this.name,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        tags: tags ?? this.tags);
  }

  BaseEntity copyWithWrapped(
      {Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp,
      Wrapped<List<String>?>? tags}) {
    return BaseEntity(
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayableEntity {
  const DisplayableEntity({
    this.description,
    this.icon,
    this.selectedImage,
    this.selectedBanner,
    this.images,
    this.banners,
  });

  factory DisplayableEntity.fromJson(Map<String, dynamic> json) =>
      _$DisplayableEntityFromJson(json);

  static const toJsonFactory = _$DisplayableEntityToJson;
  Map<String, dynamic> toJson() => _$DisplayableEntityToJson(this);

  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'selectedBanner', includeIfNull: false)
  final int? selectedBanner;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'banners', includeIfNull: false, defaultValue: <String>[])
  final List<String>? banners;
  static const fromJsonFactory = _$DisplayableEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayableEntity &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.selectedBanner, selectedBanner) ||
                const DeepCollectionEquality()
                    .equals(other.selectedBanner, selectedBanner)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.banners, banners) ||
                const DeepCollectionEquality().equals(other.banners, banners)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(selectedBanner) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(banners) ^
      runtimeType.hashCode;
}

extension $DisplayableEntityExtension on DisplayableEntity {
  DisplayableEntity copyWith(
      {String? description,
      String? icon,
      int? selectedImage,
      int? selectedBanner,
      List<String>? images,
      List<String>? banners}) {
    return DisplayableEntity(
        description: description ?? this.description,
        icon: icon ?? this.icon,
        selectedImage: selectedImage ?? this.selectedImage,
        selectedBanner: selectedBanner ?? this.selectedBanner,
        images: images ?? this.images,
        banners: banners ?? this.banners);
  }

  DisplayableEntity copyWithWrapped(
      {Wrapped<String?>? description,
      Wrapped<String?>? icon,
      Wrapped<int?>? selectedImage,
      Wrapped<int?>? selectedBanner,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? banners}) {
    return DisplayableEntity(
        description:
            (description != null ? description.value : this.description),
        icon: (icon != null ? icon.value : this.icon),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        selectedBanner: (selectedBanner != null
            ? selectedBanner.value
            : this.selectedBanner),
        images: (images != null ? images.value : this.images),
        banners: (banners != null ? banners.value : this.banners));
  }
}

@JsonSerializable(explicitToJson: true)
class FireReq {
  const FireReq({
    required this.deviceId,
    required this.controlId,
    required this.controlState,
    this.arguments,
  });

  factory FireReq.fromJson(Map<String, dynamic> json) =>
      _$FireReqFromJson(json);

  static const toJsonFactory = _$FireReqToJson;
  Map<String, dynamic> toJson() => _$FireReqToJson(this);

  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String controlId;
  @JsonKey(name: 'controlState', includeIfNull: false)
  final int controlState;
  @JsonKey(name: 'arguments', includeIfNull: false)
  final Object? arguments;
  static const fromJsonFactory = _$FireReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FireReq &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality()
                    .equals(other.controlId, controlId)) &&
            (identical(other.controlState, controlState) ||
                const DeepCollectionEquality()
                    .equals(other.controlState, controlState)) &&
            (identical(other.arguments, arguments) ||
                const DeepCollectionEquality()
                    .equals(other.arguments, arguments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(controlState) ^
      const DeepCollectionEquality().hash(arguments) ^
      runtimeType.hashCode;
}

extension $FireReqExtension on FireReq {
  FireReq copyWith(
      {String? deviceId,
      String? controlId,
      int? controlState,
      Object? arguments}) {
    return FireReq(
        deviceId: deviceId ?? this.deviceId,
        controlId: controlId ?? this.controlId,
        controlState: controlState ?? this.controlState,
        arguments: arguments ?? this.arguments);
  }

  FireReq copyWithWrapped(
      {Wrapped<String>? deviceId,
      Wrapped<String>? controlId,
      Wrapped<int>? controlState,
      Wrapped<Object?>? arguments}) {
    return FireReq(
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        controlId: (controlId != null ? controlId.value : this.controlId),
        controlState:
            (controlState != null ? controlState.value : this.controlState),
        arguments: (arguments != null ? arguments.value : this.arguments));
  }
}

@JsonSerializable(explicitToJson: true)
class GetReq {
  const GetReq({
    required this.ids,
  });

  factory GetReq.fromJson(Map<String, dynamic> json) => _$GetReqFromJson(json);

  static const toJsonFactory = _$GetReqToJson;
  Map<String, dynamic> toJson() => _$GetReqToJson(this);

  @JsonKey(name: 'ids', includeIfNull: false, defaultValue: <String>[])
  final List<String> ids;
  static const fromJsonFactory = _$GetReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetReq &&
            (identical(other.ids, ids) ||
                const DeepCollectionEquality().equals(other.ids, ids)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ids) ^ runtimeType.hashCode;
}

extension $GetReqExtension on GetReq {
  GetReq copyWith({List<String>? ids}) {
    return GetReq(ids: ids ?? this.ids);
  }

  GetReq copyWithWrapped({Wrapped<List<String>>? ids}) {
    return GetReq(ids: (ids != null ? ids.value : this.ids));
  }
}

@JsonSerializable(explicitToJson: true)
class ListReq {
  const ListReq({
    required this.page,
    required this.size,
  });

  factory ListReq.fromJson(Map<String, dynamic> json) =>
      _$ListReqFromJson(json);

  static const toJsonFactory = _$ListReqToJson;
  Map<String, dynamic> toJson() => _$ListReqToJson(this);

  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  static const fromJsonFactory = _$ListReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListReq &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $ListReqExtension on ListReq {
  ListReq copyWith({int? page, int? size}) {
    return ListReq(page: page ?? this.page, size: size ?? this.size);
  }

  ListReq copyWithWrapped({Wrapped<int>? page, Wrapped<int>? size}) {
    return ListReq(
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size));
  }
}

@JsonSerializable(explicitToJson: true)
class ListRes {
  const ListRes({
    required this.page,
    required this.size,
    required this.total,
  });

  factory ListRes.fromJson(Map<String, dynamic> json) =>
      _$ListResFromJson(json);

  static const toJsonFactory = _$ListResToJson;
  Map<String, dynamic> toJson() => _$ListResToJson(this);

  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  static const fromJsonFactory = _$ListResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListRes &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $ListResExtension on ListRes {
  ListRes copyWith({int? page, int? size, int? total}) {
    return ListRes(
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total);
  }

  ListRes copyWithWrapped(
      {Wrapped<int>? page, Wrapped<int>? size, Wrapped<int>? total}) {
    return ListRes(
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class SearchReqBase {
  const SearchReqBase({
    required this.search,
  });

  factory SearchReqBase.fromJson(Map<String, dynamic> json) =>
      _$SearchReqBaseFromJson(json);

  static const toJsonFactory = _$SearchReqBaseToJson;
  Map<String, dynamic> toJson() => _$SearchReqBaseToJson(this);

  @JsonKey(name: 'search', includeIfNull: false, defaultValue: '')
  final String search;
  static const fromJsonFactory = _$SearchReqBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchReqBase &&
            (identical(other.search, search) ||
                const DeepCollectionEquality().equals(other.search, search)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(search) ^ runtimeType.hashCode;
}

extension $SearchReqBaseExtension on SearchReqBase {
  SearchReqBase copyWith({String? search}) {
    return SearchReqBase(search: search ?? this.search);
  }

  SearchReqBase copyWithWrapped({Wrapped<String>? search}) {
    return SearchReqBase(search: (search != null ? search.value : this.search));
  }
}

@JsonSerializable(explicitToJson: true)
class SearchReq {
  const SearchReq({
    required this.search,
    required this.page,
    required this.size,
  });

  factory SearchReq.fromJson(Map<String, dynamic> json) =>
      _$SearchReqFromJson(json);

  static const toJsonFactory = _$SearchReqToJson;
  Map<String, dynamic> toJson() => _$SearchReqToJson(this);

  @JsonKey(name: 'search', includeIfNull: false, defaultValue: '')
  final String search;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  static const fromJsonFactory = _$SearchReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchReq &&
            (identical(other.search, search) ||
                const DeepCollectionEquality().equals(other.search, search)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(search) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $SearchReqExtension on SearchReq {
  SearchReq copyWith({String? search, int? page, int? size}) {
    return SearchReq(
        search: search ?? this.search,
        page: page ?? this.page,
        size: size ?? this.size);
  }

  SearchReq copyWithWrapped(
      {Wrapped<String>? search, Wrapped<int>? page, Wrapped<int>? size}) {
    return SearchReq(
        search: (search != null ? search.value : this.search),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size));
  }
}

@JsonSerializable(explicitToJson: true)
class RangeFilter {
  const RangeFilter({
    this.tz,
    this.filter,
    this.beginStamp,
    this.endStamp,
  });

  factory RangeFilter.fromJson(Map<String, dynamic> json) =>
      _$RangeFilterFromJson(json);

  static const toJsonFactory = _$RangeFilterToJson;
  Map<String, dynamic> toJson() => _$RangeFilterToJson(this);

  @JsonKey(name: 'tz', includeIfNull: false, defaultValue: '')
  final String? tz;
  @JsonKey(
    name: 'filter',
    includeIfNull: false,
    toJson: rangeFilterFilterNullableToJson,
    fromJson: rangeFilterFilterNullableFromJson,
  )
  final enums.RangeFilterFilter? filter;
  @JsonKey(name: 'beginStamp', includeIfNull: false)
  final int? beginStamp;
  @JsonKey(name: 'endStamp', includeIfNull: false)
  final int? endStamp;
  static const fromJsonFactory = _$RangeFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RangeFilter &&
            (identical(other.tz, tz) ||
                const DeepCollectionEquality().equals(other.tz, tz)) &&
            (identical(other.filter, filter) ||
                const DeepCollectionEquality().equals(other.filter, filter)) &&
            (identical(other.beginStamp, beginStamp) ||
                const DeepCollectionEquality()
                    .equals(other.beginStamp, beginStamp)) &&
            (identical(other.endStamp, endStamp) ||
                const DeepCollectionEquality()
                    .equals(other.endStamp, endStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tz) ^
      const DeepCollectionEquality().hash(filter) ^
      const DeepCollectionEquality().hash(beginStamp) ^
      const DeepCollectionEquality().hash(endStamp) ^
      runtimeType.hashCode;
}

extension $RangeFilterExtension on RangeFilter {
  RangeFilter copyWith(
      {String? tz,
      enums.RangeFilterFilter? filter,
      int? beginStamp,
      int? endStamp}) {
    return RangeFilter(
        tz: tz ?? this.tz,
        filter: filter ?? this.filter,
        beginStamp: beginStamp ?? this.beginStamp,
        endStamp: endStamp ?? this.endStamp);
  }

  RangeFilter copyWithWrapped(
      {Wrapped<String?>? tz,
      Wrapped<enums.RangeFilterFilter?>? filter,
      Wrapped<int?>? beginStamp,
      Wrapped<int?>? endStamp}) {
    return RangeFilter(
        tz: (tz != null ? tz.value : this.tz),
        filter: (filter != null ? filter.value : this.filter),
        beginStamp: (beginStamp != null ? beginStamp.value : this.beginStamp),
        endStamp: (endStamp != null ? endStamp.value : this.endStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class FilterReqBase {
  const FilterReqBase({
    this.filter,
  });

  factory FilterReqBase.fromJson(Map<String, dynamic> json) =>
      _$FilterReqBaseFromJson(json);

  static const toJsonFactory = _$FilterReqBaseToJson;
  Map<String, dynamic> toJson() => _$FilterReqBaseToJson(this);

  @JsonKey(name: 'filter', includeIfNull: false)
  final RangeFilter? filter;
  static const fromJsonFactory = _$FilterReqBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterReqBase &&
            (identical(other.filter, filter) ||
                const DeepCollectionEquality().equals(other.filter, filter)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(filter) ^ runtimeType.hashCode;
}

extension $FilterReqBaseExtension on FilterReqBase {
  FilterReqBase copyWith({RangeFilter? filter}) {
    return FilterReqBase(filter: filter ?? this.filter);
  }

  FilterReqBase copyWithWrapped({Wrapped<RangeFilter?>? filter}) {
    return FilterReqBase(filter: (filter != null ? filter.value : this.filter));
  }
}

@JsonSerializable(explicitToJson: true)
class FilterSearchReq {
  const FilterSearchReq({
    required this.search,
    this.filter,
    required this.page,
    required this.size,
  });

  factory FilterSearchReq.fromJson(Map<String, dynamic> json) =>
      _$FilterSearchReqFromJson(json);

  static const toJsonFactory = _$FilterSearchReqToJson;
  Map<String, dynamic> toJson() => _$FilterSearchReqToJson(this);

  @JsonKey(name: 'search', includeIfNull: false, defaultValue: '')
  final String search;
  @JsonKey(name: 'filter', includeIfNull: false)
  final RangeFilter? filter;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  static const fromJsonFactory = _$FilterSearchReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterSearchReq &&
            (identical(other.search, search) ||
                const DeepCollectionEquality().equals(other.search, search)) &&
            (identical(other.filter, filter) ||
                const DeepCollectionEquality().equals(other.filter, filter)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(search) ^
      const DeepCollectionEquality().hash(filter) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $FilterSearchReqExtension on FilterSearchReq {
  FilterSearchReq copyWith(
      {String? search, RangeFilter? filter, int? page, int? size}) {
    return FilterSearchReq(
        search: search ?? this.search,
        filter: filter ?? this.filter,
        page: page ?? this.page,
        size: size ?? this.size);
  }

  FilterSearchReq copyWithWrapped(
      {Wrapped<String>? search,
      Wrapped<RangeFilter?>? filter,
      Wrapped<int>? page,
      Wrapped<int>? size}) {
    return FilterSearchReq(
        search: (search != null ? search.value : this.search),
        filter: (filter != null ? filter.value : this.filter),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size));
  }
}

@JsonSerializable(explicitToJson: true)
class CleanReq {
  const CleanReq({
    this.type,
    this.modelId,
    this.deviceId,
  });

  factory CleanReq.fromJson(Map<String, dynamic> json) =>
      _$CleanReqFromJson(json);

  static const toJsonFactory = _$CleanReqToJson;
  Map<String, dynamic> toJson() => _$CleanReqToJson(this);

  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: cleanReqTypeNullableToJson,
    fromJson: cleanReqTypeTypeNullableFromJson,
  )
  final enums.CleanReqType? type;
  static enums.CleanReqType? cleanReqTypeTypeNullableFromJson(Object? value) =>
      cleanReqTypeNullableFromJson(value, enums.CleanReqType.all);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String? modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  static const fromJsonFactory = _$CleanReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CleanReq &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      runtimeType.hashCode;
}

extension $CleanReqExtension on CleanReq {
  CleanReq copyWith(
      {enums.CleanReqType? type, String? modelId, String? deviceId}) {
    return CleanReq(
        type: type ?? this.type,
        modelId: modelId ?? this.modelId,
        deviceId: deviceId ?? this.deviceId);
  }

  CleanReq copyWithWrapped(
      {Wrapped<enums.CleanReqType?>? type,
      Wrapped<String?>? modelId,
      Wrapped<String?>? deviceId}) {
    return CleanReq(
        type: (type != null ? type.value : this.type),
        modelId: (modelId != null ? modelId.value : this.modelId),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId));
  }
}

@JsonSerializable(explicitToJson: true)
class Parameter {
  const Parameter({
    required this.name,
    this.description,
    this.label,
    required this.parameterType,
    required this.required,
    this.defaultValue,
    this.enableTrend,
    this.enableTimeSeries,
    this.unit,
    this.icon,
    this.sensorWidget,
  });

  factory Parameter.fromJson(Map<String, dynamic> json) =>
      _$ParameterFromJson(json);

  static const toJsonFactory = _$ParameterToJson;
  Map<String, dynamic> toJson() => _$ParameterToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(
    name: 'parameterType',
    includeIfNull: false,
    toJson: parameterParameterTypeToJson,
    fromJson: parameterParameterTypeFromJson,
  )
  final enums.ParameterParameterType parameterType;
  @JsonKey(name: 'required', includeIfNull: false, defaultValue: false)
  final bool required;
  @JsonKey(name: 'defaultValue', includeIfNull: false, defaultValue: '')
  final String? defaultValue;
  @JsonKey(name: 'enableTrend', includeIfNull: false, defaultValue: false)
  final bool? enableTrend;
  @JsonKey(name: 'enableTimeSeries', includeIfNull: false, defaultValue: false)
  final bool? enableTimeSeries;
  @JsonKey(name: 'unit', includeIfNull: false, defaultValue: '')
  final String? unit;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'sensorWidget', includeIfNull: false)
  final SensorWidget? sensorWidget;
  static const fromJsonFactory = _$ParameterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Parameter &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.parameterType, parameterType) ||
                const DeepCollectionEquality()
                    .equals(other.parameterType, parameterType)) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality()
                    .equals(other.required, required)) &&
            (identical(other.defaultValue, defaultValue) ||
                const DeepCollectionEquality()
                    .equals(other.defaultValue, defaultValue)) &&
            (identical(other.enableTrend, enableTrend) ||
                const DeepCollectionEquality()
                    .equals(other.enableTrend, enableTrend)) &&
            (identical(other.enableTimeSeries, enableTimeSeries) ||
                const DeepCollectionEquality()
                    .equals(other.enableTimeSeries, enableTimeSeries)) &&
            (identical(other.unit, unit) ||
                const DeepCollectionEquality().equals(other.unit, unit)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.sensorWidget, sensorWidget) ||
                const DeepCollectionEquality()
                    .equals(other.sensorWidget, sensorWidget)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(parameterType) ^
      const DeepCollectionEquality().hash(required) ^
      const DeepCollectionEquality().hash(defaultValue) ^
      const DeepCollectionEquality().hash(enableTrend) ^
      const DeepCollectionEquality().hash(enableTimeSeries) ^
      const DeepCollectionEquality().hash(unit) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(sensorWidget) ^
      runtimeType.hashCode;
}

extension $ParameterExtension on Parameter {
  Parameter copyWith(
      {String? name,
      String? description,
      String? label,
      enums.ParameterParameterType? parameterType,
      bool? required,
      String? defaultValue,
      bool? enableTrend,
      bool? enableTimeSeries,
      String? unit,
      String? icon,
      SensorWidget? sensorWidget}) {
    return Parameter(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        parameterType: parameterType ?? this.parameterType,
        required: required ?? this.required,
        defaultValue: defaultValue ?? this.defaultValue,
        enableTrend: enableTrend ?? this.enableTrend,
        enableTimeSeries: enableTimeSeries ?? this.enableTimeSeries,
        unit: unit ?? this.unit,
        icon: icon ?? this.icon,
        sensorWidget: sensorWidget ?? this.sensorWidget);
  }

  Parameter copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<enums.ParameterParameterType>? parameterType,
      Wrapped<bool>? required,
      Wrapped<String?>? defaultValue,
      Wrapped<bool?>? enableTrend,
      Wrapped<bool?>? enableTimeSeries,
      Wrapped<String?>? unit,
      Wrapped<String?>? icon,
      Wrapped<SensorWidget?>? sensorWidget}) {
    return Parameter(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        parameterType:
            (parameterType != null ? parameterType.value : this.parameterType),
        required: (required != null ? required.value : this.required),
        defaultValue:
            (defaultValue != null ? defaultValue.value : this.defaultValue),
        enableTrend:
            (enableTrend != null ? enableTrend.value : this.enableTrend),
        enableTimeSeries: (enableTimeSeries != null
            ? enableTimeSeries.value
            : this.enableTimeSeries),
        unit: (unit != null ? unit.value : this.unit),
        icon: (icon != null ? icon.value : this.icon),
        sensorWidget:
            (sensorWidget != null ? sensorWidget.value : this.sensorWidget));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableConfig {
  const ScrappingTableConfig({
    required this.lookupName,
    required this.scrappingTableName,
    required this.scrappingTableIds,
  });

  factory ScrappingTableConfig.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableConfigFromJson(json);

  static const toJsonFactory = _$ScrappingTableConfigToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableConfigToJson(this);

  @JsonKey(name: 'lookupName', includeIfNull: false, defaultValue: '')
  final String lookupName;
  @JsonKey(name: 'scrappingTableName', includeIfNull: false, defaultValue: '')
  final String scrappingTableName;
  @JsonKey(
      name: 'scrappingTableIds', includeIfNull: false, defaultValue: <String>[])
  final List<String> scrappingTableIds;
  static const fromJsonFactory = _$ScrappingTableConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableConfig &&
            (identical(other.lookupName, lookupName) ||
                const DeepCollectionEquality()
                    .equals(other.lookupName, lookupName)) &&
            (identical(other.scrappingTableName, scrappingTableName) ||
                const DeepCollectionEquality()
                    .equals(other.scrappingTableName, scrappingTableName)) &&
            (identical(other.scrappingTableIds, scrappingTableIds) ||
                const DeepCollectionEquality()
                    .equals(other.scrappingTableIds, scrappingTableIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(lookupName) ^
      const DeepCollectionEquality().hash(scrappingTableName) ^
      const DeepCollectionEquality().hash(scrappingTableIds) ^
      runtimeType.hashCode;
}

extension $ScrappingTableConfigExtension on ScrappingTableConfig {
  ScrappingTableConfig copyWith(
      {String? lookupName,
      String? scrappingTableName,
      List<String>? scrappingTableIds}) {
    return ScrappingTableConfig(
        lookupName: lookupName ?? this.lookupName,
        scrappingTableName: scrappingTableName ?? this.scrappingTableName,
        scrappingTableIds: scrappingTableIds ?? this.scrappingTableIds);
  }

  ScrappingTableConfig copyWithWrapped(
      {Wrapped<String>? lookupName,
      Wrapped<String>? scrappingTableName,
      Wrapped<List<String>>? scrappingTableIds}) {
    return ScrappingTableConfig(
        lookupName: (lookupName != null ? lookupName.value : this.lookupName),
        scrappingTableName: (scrappingTableName != null
            ? scrappingTableName.value
            : this.scrappingTableName),
        scrappingTableIds: (scrappingTableIds != null
            ? scrappingTableIds.value
            : this.scrappingTableIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelInfo {
  const DeviceModelInfo({
    required this.name,
    this.description,
    required this.make,
    required this.model,
    required this.version,
    required this.parameters,
    this.icon,
    this.selectedImage,
    this.selectedBanner,
    this.tags,
    this.banners,
    this.images,
    this.metadata,
    this.defaultView,
    this.preprocessorId,
    this.hasGeoLocation,
    this.movable,
    this.customWidget,
    this.makePublic,
    this.scrappingTableConfigs,
  });

  factory DeviceModelInfo.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelInfoFromJson(json);

  static const toJsonFactory = _$DeviceModelInfoToJson;
  Map<String, dynamic> toJson() => _$DeviceModelInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'make', includeIfNull: false, defaultValue: '')
  final String make;
  @JsonKey(name: 'model', includeIfNull: false, defaultValue: '')
  final String model;
  @JsonKey(name: 'version', includeIfNull: false, defaultValue: '')
  final String version;
  @JsonKey(
      name: 'parameters', includeIfNull: false, defaultValue: <Parameter>[])
  final List<Parameter> parameters;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'selectedBanner', includeIfNull: false)
  final int? selectedBanner;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'banners', includeIfNull: false, defaultValue: <String>[])
  final List<String>? banners;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'defaultView', includeIfNull: false, defaultValue: '')
  final String? defaultView;
  @JsonKey(name: 'preprocessorId', includeIfNull: false, defaultValue: '')
  final String? preprocessorId;
  @JsonKey(name: 'hasGeoLocation', includeIfNull: false)
  final bool? hasGeoLocation;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(name: 'customWidget', includeIfNull: false)
  final CustomWidget? customWidget;
  @JsonKey(name: 'makePublic', includeIfNull: false, defaultValue: false)
  final bool? makePublic;
  @JsonKey(
      name: 'scrappingTableConfigs',
      includeIfNull: false,
      defaultValue: <ScrappingTableConfig>[])
  final List<ScrappingTableConfig>? scrappingTableConfigs;
  static const fromJsonFactory = _$DeviceModelInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.make, make) ||
                const DeepCollectionEquality().equals(other.make, make)) &&
            (identical(other.model, model) ||
                const DeepCollectionEquality().equals(other.model, model)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.selectedBanner, selectedBanner) ||
                const DeepCollectionEquality()
                    .equals(other.selectedBanner, selectedBanner)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.banners, banners) ||
                const DeepCollectionEquality()
                    .equals(other.banners, banners)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.defaultView, defaultView) ||
                const DeepCollectionEquality()
                    .equals(other.defaultView, defaultView)) &&
            (identical(other.preprocessorId, preprocessorId) ||
                const DeepCollectionEquality()
                    .equals(other.preprocessorId, preprocessorId)) &&
            (identical(other.hasGeoLocation, hasGeoLocation) ||
                const DeepCollectionEquality()
                    .equals(other.hasGeoLocation, hasGeoLocation)) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality()
                    .equals(other.movable, movable)) &&
            (identical(other.customWidget, customWidget) ||
                const DeepCollectionEquality()
                    .equals(other.customWidget, customWidget)) &&
            (identical(other.makePublic, makePublic) ||
                const DeepCollectionEquality()
                    .equals(other.makePublic, makePublic)) &&
            (identical(other.scrappingTableConfigs, scrappingTableConfigs) ||
                const DeepCollectionEquality().equals(
                    other.scrappingTableConfigs, scrappingTableConfigs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(make) ^
      const DeepCollectionEquality().hash(model) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(selectedBanner) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(banners) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(defaultView) ^
      const DeepCollectionEquality().hash(preprocessorId) ^
      const DeepCollectionEquality().hash(hasGeoLocation) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(customWidget) ^
      const DeepCollectionEquality().hash(makePublic) ^
      const DeepCollectionEquality().hash(scrappingTableConfigs) ^
      runtimeType.hashCode;
}

extension $DeviceModelInfoExtension on DeviceModelInfo {
  DeviceModelInfo copyWith(
      {String? name,
      String? description,
      String? make,
      String? model,
      String? version,
      List<Parameter>? parameters,
      String? icon,
      int? selectedImage,
      int? selectedBanner,
      List<String>? tags,
      List<String>? banners,
      List<String>? images,
      Object? metadata,
      String? defaultView,
      String? preprocessorId,
      bool? hasGeoLocation,
      bool? movable,
      CustomWidget? customWidget,
      bool? makePublic,
      List<ScrappingTableConfig>? scrappingTableConfigs}) {
    return DeviceModelInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        make: make ?? this.make,
        model: model ?? this.model,
        version: version ?? this.version,
        parameters: parameters ?? this.parameters,
        icon: icon ?? this.icon,
        selectedImage: selectedImage ?? this.selectedImage,
        selectedBanner: selectedBanner ?? this.selectedBanner,
        tags: tags ?? this.tags,
        banners: banners ?? this.banners,
        images: images ?? this.images,
        metadata: metadata ?? this.metadata,
        defaultView: defaultView ?? this.defaultView,
        preprocessorId: preprocessorId ?? this.preprocessorId,
        hasGeoLocation: hasGeoLocation ?? this.hasGeoLocation,
        movable: movable ?? this.movable,
        customWidget: customWidget ?? this.customWidget,
        makePublic: makePublic ?? this.makePublic,
        scrappingTableConfigs:
            scrappingTableConfigs ?? this.scrappingTableConfigs);
  }

  DeviceModelInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? make,
      Wrapped<String>? model,
      Wrapped<String>? version,
      Wrapped<List<Parameter>>? parameters,
      Wrapped<String?>? icon,
      Wrapped<int?>? selectedImage,
      Wrapped<int?>? selectedBanner,
      Wrapped<List<String>?>? tags,
      Wrapped<List<String>?>? banners,
      Wrapped<List<String>?>? images,
      Wrapped<Object?>? metadata,
      Wrapped<String?>? defaultView,
      Wrapped<String?>? preprocessorId,
      Wrapped<bool?>? hasGeoLocation,
      Wrapped<bool?>? movable,
      Wrapped<CustomWidget?>? customWidget,
      Wrapped<bool?>? makePublic,
      Wrapped<List<ScrappingTableConfig>?>? scrappingTableConfigs}) {
    return DeviceModelInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        make: (make != null ? make.value : this.make),
        model: (model != null ? model.value : this.model),
        version: (version != null ? version.value : this.version),
        parameters: (parameters != null ? parameters.value : this.parameters),
        icon: (icon != null ? icon.value : this.icon),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        selectedBanner: (selectedBanner != null
            ? selectedBanner.value
            : this.selectedBanner),
        tags: (tags != null ? tags.value : this.tags),
        banners: (banners != null ? banners.value : this.banners),
        images: (images != null ? images.value : this.images),
        metadata: (metadata != null ? metadata.value : this.metadata),
        defaultView:
            (defaultView != null ? defaultView.value : this.defaultView),
        preprocessorId: (preprocessorId != null
            ? preprocessorId.value
            : this.preprocessorId),
        hasGeoLocation: (hasGeoLocation != null
            ? hasGeoLocation.value
            : this.hasGeoLocation),
        movable: (movable != null ? movable.value : this.movable),
        customWidget:
            (customWidget != null ? customWidget.value : this.customWidget),
        makePublic: (makePublic != null ? makePublic.value : this.makePublic),
        scrappingTableConfigs: (scrappingTableConfigs != null
            ? scrappingTableConfigs.value
            : this.scrappingTableConfigs));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModel {
  const DeviceModel({
    required this.name,
    this.description,
    required this.make,
    required this.model,
    required this.version,
    required this.parameters,
    this.icon,
    this.selectedImage,
    this.selectedBanner,
    this.tags,
    this.banners,
    this.images,
    this.metadata,
    this.defaultView,
    this.preprocessorId,
    this.hasGeoLocation,
    this.movable,
    this.customWidget,
    this.makePublic,
    this.scrappingTableConfigs,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory DeviceModel.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelFromJson(json);

  static const toJsonFactory = _$DeviceModelToJson;
  Map<String, dynamic> toJson() => _$DeviceModelToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'make', includeIfNull: false, defaultValue: '')
  final String make;
  @JsonKey(name: 'model', includeIfNull: false, defaultValue: '')
  final String model;
  @JsonKey(name: 'version', includeIfNull: false, defaultValue: '')
  final String version;
  @JsonKey(
      name: 'parameters', includeIfNull: false, defaultValue: <Parameter>[])
  final List<Parameter> parameters;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'selectedBanner', includeIfNull: false)
  final int? selectedBanner;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'banners', includeIfNull: false, defaultValue: <String>[])
  final List<String>? banners;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'defaultView', includeIfNull: false, defaultValue: '')
  final String? defaultView;
  @JsonKey(name: 'preprocessorId', includeIfNull: false, defaultValue: '')
  final String? preprocessorId;
  @JsonKey(name: 'hasGeoLocation', includeIfNull: false)
  final bool? hasGeoLocation;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(name: 'customWidget', includeIfNull: false)
  final CustomWidget? customWidget;
  @JsonKey(name: 'makePublic', includeIfNull: false, defaultValue: false)
  final bool? makePublic;
  @JsonKey(
      name: 'scrappingTableConfigs',
      includeIfNull: false,
      defaultValue: <ScrappingTableConfig>[])
  final List<ScrappingTableConfig>? scrappingTableConfigs;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$DeviceModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.make, make) ||
                const DeepCollectionEquality().equals(other.make, make)) &&
            (identical(other.model, model) ||
                const DeepCollectionEquality().equals(other.model, model)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.selectedBanner, selectedBanner) ||
                const DeepCollectionEquality()
                    .equals(other.selectedBanner, selectedBanner)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.banners, banners) ||
                const DeepCollectionEquality()
                    .equals(other.banners, banners)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.defaultView, defaultView) ||
                const DeepCollectionEquality()
                    .equals(other.defaultView, defaultView)) &&
            (identical(other.preprocessorId, preprocessorId) ||
                const DeepCollectionEquality()
                    .equals(other.preprocessorId, preprocessorId)) &&
            (identical(other.hasGeoLocation, hasGeoLocation) ||
                const DeepCollectionEquality()
                    .equals(other.hasGeoLocation, hasGeoLocation)) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality()
                    .equals(other.movable, movable)) &&
            (identical(other.customWidget, customWidget) ||
                const DeepCollectionEquality()
                    .equals(other.customWidget, customWidget)) &&
            (identical(other.makePublic, makePublic) ||
                const DeepCollectionEquality()
                    .equals(other.makePublic, makePublic)) &&
            (identical(other.scrappingTableConfigs, scrappingTableConfigs) ||
                const DeepCollectionEquality().equals(
                    other.scrappingTableConfigs, scrappingTableConfigs)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) || const DeepCollectionEquality().equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) || const DeepCollectionEquality().equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(make) ^
      const DeepCollectionEquality().hash(model) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(selectedBanner) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(banners) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(defaultView) ^
      const DeepCollectionEquality().hash(preprocessorId) ^
      const DeepCollectionEquality().hash(hasGeoLocation) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(customWidget) ^
      const DeepCollectionEquality().hash(makePublic) ^
      const DeepCollectionEquality().hash(scrappingTableConfigs) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $DeviceModelExtension on DeviceModel {
  DeviceModel copyWith(
      {String? name,
      String? description,
      String? make,
      String? model,
      String? version,
      List<Parameter>? parameters,
      String? icon,
      int? selectedImage,
      int? selectedBanner,
      List<String>? tags,
      List<String>? banners,
      List<String>? images,
      Object? metadata,
      String? defaultView,
      String? preprocessorId,
      bool? hasGeoLocation,
      bool? movable,
      CustomWidget? customWidget,
      bool? makePublic,
      List<ScrappingTableConfig>? scrappingTableConfigs,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return DeviceModel(
        name: name ?? this.name,
        description: description ?? this.description,
        make: make ?? this.make,
        model: model ?? this.model,
        version: version ?? this.version,
        parameters: parameters ?? this.parameters,
        icon: icon ?? this.icon,
        selectedImage: selectedImage ?? this.selectedImage,
        selectedBanner: selectedBanner ?? this.selectedBanner,
        tags: tags ?? this.tags,
        banners: banners ?? this.banners,
        images: images ?? this.images,
        metadata: metadata ?? this.metadata,
        defaultView: defaultView ?? this.defaultView,
        preprocessorId: preprocessorId ?? this.preprocessorId,
        hasGeoLocation: hasGeoLocation ?? this.hasGeoLocation,
        movable: movable ?? this.movable,
        customWidget: customWidget ?? this.customWidget,
        makePublic: makePublic ?? this.makePublic,
        scrappingTableConfigs:
            scrappingTableConfigs ?? this.scrappingTableConfigs,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  DeviceModel copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? make,
      Wrapped<String>? model,
      Wrapped<String>? version,
      Wrapped<List<Parameter>>? parameters,
      Wrapped<String?>? icon,
      Wrapped<int?>? selectedImage,
      Wrapped<int?>? selectedBanner,
      Wrapped<List<String>?>? tags,
      Wrapped<List<String>?>? banners,
      Wrapped<List<String>?>? images,
      Wrapped<Object?>? metadata,
      Wrapped<String?>? defaultView,
      Wrapped<String?>? preprocessorId,
      Wrapped<bool?>? hasGeoLocation,
      Wrapped<bool?>? movable,
      Wrapped<CustomWidget?>? customWidget,
      Wrapped<bool?>? makePublic,
      Wrapped<List<ScrappingTableConfig>?>? scrappingTableConfigs,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return DeviceModel(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        make: (make != null ? make.value : this.make),
        model: (model != null ? model.value : this.model),
        version: (version != null ? version.value : this.version),
        parameters: (parameters != null ? parameters.value : this.parameters),
        icon: (icon != null ? icon.value : this.icon),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        selectedBanner: (selectedBanner != null
            ? selectedBanner.value
            : this.selectedBanner),
        tags: (tags != null ? tags.value : this.tags),
        banners: (banners != null ? banners.value : this.banners),
        images: (images != null ? images.value : this.images),
        metadata: (metadata != null ? metadata.value : this.metadata),
        defaultView:
            (defaultView != null ? defaultView.value : this.defaultView),
        preprocessorId: (preprocessorId != null
            ? preprocessorId.value
            : this.preprocessorId),
        hasGeoLocation: (hasGeoLocation != null
            ? hasGeoLocation.value
            : this.hasGeoLocation),
        movable: (movable != null ? movable.value : this.movable),
        customWidget:
            (customWidget != null ? customWidget.value : this.customWidget),
        makePublic: (makePublic != null ? makePublic.value : this.makePublic),
        scrappingTableConfigs: (scrappingTableConfigs != null
            ? scrappingTableConfigs.value
            : this.scrappingTableConfigs),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelEntity {
  const DeviceModelEntity({
    this.entity,
  });

  factory DeviceModelEntity.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelEntityFromJson(json);

  static const toJsonFactory = _$DeviceModelEntityToJson;
  Map<String, dynamic> toJson() => _$DeviceModelEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DeviceModel? entity;
  static const fromJsonFactory = _$DeviceModelEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DeviceModelEntityExtension on DeviceModelEntity {
  DeviceModelEntity copyWith({DeviceModel? entity}) {
    return DeviceModelEntity(entity: entity ?? this.entity);
  }

  DeviceModelEntity copyWithWrapped({Wrapped<DeviceModel?>? entity}) {
    return DeviceModelEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelEntityRes {
  const DeviceModelEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DeviceModelEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelEntityResFromJson(json);

  static const toJsonFactory = _$DeviceModelEntityResToJson;
  Map<String, dynamic> toJson() => _$DeviceModelEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DeviceModel? entity;
  static const fromJsonFactory = _$DeviceModelEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DeviceModelEntityResExtension on DeviceModelEntityRes {
  DeviceModelEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      DeviceModel? entity}) {
    return DeviceModelEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  DeviceModelEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<DeviceModel?>? entity}) {
    return DeviceModelEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelArray {
  const DeviceModelArray({
    this.values,
  });

  factory DeviceModelArray.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelArrayFromJson(json);

  static const toJsonFactory = _$DeviceModelArrayToJson;
  Map<String, dynamic> toJson() => _$DeviceModelArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceModel>[])
  final List<DeviceModel>? values;
  static const fromJsonFactory = _$DeviceModelArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DeviceModelArrayExtension on DeviceModelArray {
  DeviceModelArray copyWith({List<DeviceModel>? values}) {
    return DeviceModelArray(values: values ?? this.values);
  }

  DeviceModelArray copyWithWrapped({Wrapped<List<DeviceModel>?>? values}) {
    return DeviceModelArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceModelArrayRes {
  const DeviceModelArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DeviceModelArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceModelArrayResFromJson(json);

  static const toJsonFactory = _$DeviceModelArrayResToJson;
  Map<String, dynamic> toJson() => _$DeviceModelArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceModel>[])
  final List<DeviceModel>? values;
  static const fromJsonFactory = _$DeviceModelArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceModelArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DeviceModelArrayResExtension on DeviceModelArrayRes {
  DeviceModelArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<DeviceModel>? values}) {
    return DeviceModelArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  DeviceModelArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<DeviceModel>?>? values}) {
    return DeviceModelArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceInfo {
  const DeviceInfo({
    required this.name,
    this.description,
    required this.modelId,
    required this.deviceId,
    this.tags,
    this.icon,
    this.selectedImage,
    this.selectedBanner,
    this.images,
    this.banners,
    this.metadata,
    this.defaultView,
    this.hasGeoLocation,
    this.movable,
    this.geolocation,
    this.customWidget,
    this.reportedStamp,
  });

  factory DeviceInfo.fromJson(Map<String, dynamic> json) =>
      _$DeviceInfoFromJson(json);

  static const toJsonFactory = _$DeviceInfoToJson;
  Map<String, dynamic> toJson() => _$DeviceInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'selectedBanner', includeIfNull: false)
  final int? selectedBanner;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'banners', includeIfNull: false, defaultValue: <String>[])
  final List<String>? banners;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'defaultView', includeIfNull: false, defaultValue: '')
  final String? defaultView;
  @JsonKey(name: 'hasGeoLocation', includeIfNull: false)
  final bool? hasGeoLocation;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(name: 'geolocation', includeIfNull: false)
  final GeoLocation? geolocation;
  @JsonKey(name: 'customWidget', includeIfNull: false)
  final CustomWidget? customWidget;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  static const fromJsonFactory = _$DeviceInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.selectedBanner, selectedBanner) ||
                const DeepCollectionEquality()
                    .equals(other.selectedBanner, selectedBanner)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.banners, banners) ||
                const DeepCollectionEquality()
                    .equals(other.banners, banners)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.defaultView, defaultView) ||
                const DeepCollectionEquality()
                    .equals(other.defaultView, defaultView)) &&
            (identical(other.hasGeoLocation, hasGeoLocation) ||
                const DeepCollectionEquality()
                    .equals(other.hasGeoLocation, hasGeoLocation)) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality()
                    .equals(other.movable, movable)) &&
            (identical(other.geolocation, geolocation) ||
                const DeepCollectionEquality()
                    .equals(other.geolocation, geolocation)) &&
            (identical(other.customWidget, customWidget) ||
                const DeepCollectionEquality()
                    .equals(other.customWidget, customWidget)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(selectedBanner) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(banners) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(defaultView) ^
      const DeepCollectionEquality().hash(hasGeoLocation) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(geolocation) ^
      const DeepCollectionEquality().hash(customWidget) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      runtimeType.hashCode;
}

extension $DeviceInfoExtension on DeviceInfo {
  DeviceInfo copyWith(
      {String? name,
      String? description,
      String? modelId,
      String? deviceId,
      List<String>? tags,
      String? icon,
      int? selectedImage,
      int? selectedBanner,
      List<String>? images,
      List<String>? banners,
      Object? metadata,
      String? defaultView,
      bool? hasGeoLocation,
      bool? movable,
      GeoLocation? geolocation,
      CustomWidget? customWidget,
      int? reportedStamp}) {
    return DeviceInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        deviceId: deviceId ?? this.deviceId,
        tags: tags ?? this.tags,
        icon: icon ?? this.icon,
        selectedImage: selectedImage ?? this.selectedImage,
        selectedBanner: selectedBanner ?? this.selectedBanner,
        images: images ?? this.images,
        banners: banners ?? this.banners,
        metadata: metadata ?? this.metadata,
        defaultView: defaultView ?? this.defaultView,
        hasGeoLocation: hasGeoLocation ?? this.hasGeoLocation,
        movable: movable ?? this.movable,
        geolocation: geolocation ?? this.geolocation,
        customWidget: customWidget ?? this.customWidget,
        reportedStamp: reportedStamp ?? this.reportedStamp);
  }

  DeviceInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<String>? deviceId,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? icon,
      Wrapped<int?>? selectedImage,
      Wrapped<int?>? selectedBanner,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? banners,
      Wrapped<Object?>? metadata,
      Wrapped<String?>? defaultView,
      Wrapped<bool?>? hasGeoLocation,
      Wrapped<bool?>? movable,
      Wrapped<GeoLocation?>? geolocation,
      Wrapped<CustomWidget?>? customWidget,
      Wrapped<int?>? reportedStamp}) {
    return DeviceInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        tags: (tags != null ? tags.value : this.tags),
        icon: (icon != null ? icon.value : this.icon),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        selectedBanner: (selectedBanner != null
            ? selectedBanner.value
            : this.selectedBanner),
        images: (images != null ? images.value : this.images),
        banners: (banners != null ? banners.value : this.banners),
        metadata: (metadata != null ? metadata.value : this.metadata),
        defaultView:
            (defaultView != null ? defaultView.value : this.defaultView),
        hasGeoLocation: (hasGeoLocation != null
            ? hasGeoLocation.value
            : this.hasGeoLocation),
        movable: (movable != null ? movable.value : this.movable),
        geolocation:
            (geolocation != null ? geolocation.value : this.geolocation),
        customWidget:
            (customWidget != null ? customWidget.value : this.customWidget),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceBase {
  const DeviceBase({
    required this.apiKey,
    required this.reportedStamp,
    this.premiseId,
    this.facilityId,
    this.floorId,
    this.assetId,
    this.premise,
    this.facility,
    this.floor,
    this.asset,
    this.clientId,
    this.$client,
  });

  factory DeviceBase.fromJson(Map<String, dynamic> json) =>
      _$DeviceBaseFromJson(json);

  static const toJsonFactory = _$DeviceBaseToJson;
  Map<String, dynamic> toJson() => _$DeviceBaseToJson(this);

  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int reportedStamp;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'premise', includeIfNull: false, defaultValue: '')
  final String? premise;
  @JsonKey(name: 'facility', includeIfNull: false, defaultValue: '')
  final String? facility;
  @JsonKey(name: 'floor', includeIfNull: false, defaultValue: '')
  final String? floor;
  @JsonKey(name: 'asset', includeIfNull: false, defaultValue: '')
  final String? asset;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'client', includeIfNull: false, defaultValue: '')
  final String? $client;
  static const fromJsonFactory = _$DeviceBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceBase &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality()
                    .equals(other.facilityId, facilityId)) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality()
                    .equals(other.floorId, floorId)) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality()
                    .equals(other.assetId, assetId)) &&
            (identical(other.premise, premise) ||
                const DeepCollectionEquality()
                    .equals(other.premise, premise)) &&
            (identical(other.facility, facility) ||
                const DeepCollectionEquality()
                    .equals(other.facility, facility)) &&
            (identical(other.floor, floor) ||
                const DeepCollectionEquality().equals(other.floor, floor)) &&
            (identical(other.asset, asset) ||
                const DeepCollectionEquality().equals(other.asset, asset)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.$client, $client) ||
                const DeepCollectionEquality().equals(other.$client, $client)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(premise) ^
      const DeepCollectionEquality().hash(facility) ^
      const DeepCollectionEquality().hash(floor) ^
      const DeepCollectionEquality().hash(asset) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash($client) ^
      runtimeType.hashCode;
}

extension $DeviceBaseExtension on DeviceBase {
  DeviceBase copyWith(
      {String? apiKey,
      int? reportedStamp,
      String? premiseId,
      String? facilityId,
      String? floorId,
      String? assetId,
      String? premise,
      String? facility,
      String? floor,
      String? asset,
      String? clientId,
      String? $client}) {
    return DeviceBase(
        apiKey: apiKey ?? this.apiKey,
        reportedStamp: reportedStamp ?? this.reportedStamp,
        premiseId: premiseId ?? this.premiseId,
        facilityId: facilityId ?? this.facilityId,
        floorId: floorId ?? this.floorId,
        assetId: assetId ?? this.assetId,
        premise: premise ?? this.premise,
        facility: facility ?? this.facility,
        floor: floor ?? this.floor,
        asset: asset ?? this.asset,
        clientId: clientId ?? this.clientId,
        $client: $client ?? this.$client);
  }

  DeviceBase copyWithWrapped(
      {Wrapped<String>? apiKey,
      Wrapped<int>? reportedStamp,
      Wrapped<String?>? premiseId,
      Wrapped<String?>? facilityId,
      Wrapped<String?>? floorId,
      Wrapped<String?>? assetId,
      Wrapped<String?>? premise,
      Wrapped<String?>? facility,
      Wrapped<String?>? floor,
      Wrapped<String?>? asset,
      Wrapped<String?>? clientId,
      Wrapped<String?>? $client}) {
    return DeviceBase(
        apiKey: (apiKey != null ? apiKey.value : this.apiKey),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp),
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        facilityId: (facilityId != null ? facilityId.value : this.facilityId),
        floorId: (floorId != null ? floorId.value : this.floorId),
        assetId: (assetId != null ? assetId.value : this.assetId),
        premise: (premise != null ? premise.value : this.premise),
        facility: (facility != null ? facility.value : this.facility),
        floor: (floor != null ? floor.value : this.floor),
        asset: (asset != null ? asset.value : this.asset),
        clientId: (clientId != null ? clientId.value : this.clientId),
        $client: ($client != null ? $client.value : this.$client));
  }
}

@JsonSerializable(explicitToJson: true)
class Device {
  const Device({
    required this.apiKey,
    required this.reportedStamp,
    this.premiseId,
    this.facilityId,
    this.floorId,
    this.assetId,
    this.premise,
    this.facility,
    this.floor,
    this.asset,
    this.clientId,
    this.$client,
    required this.name,
    this.description,
    required this.modelId,
    required this.deviceId,
    this.tags,
    this.icon,
    this.selectedImage,
    this.selectedBanner,
    this.images,
    this.banners,
    this.metadata,
    this.defaultView,
    this.hasGeoLocation,
    this.movable,
    this.geolocation,
    this.customWidget,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Device.fromJson(Map<String, dynamic> json) => _$DeviceFromJson(json);

  static const toJsonFactory = _$DeviceToJson;
  Map<String, dynamic> toJson() => _$DeviceToJson(this);

  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int reportedStamp;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'premise', includeIfNull: false, defaultValue: '')
  final String? premise;
  @JsonKey(name: 'facility', includeIfNull: false, defaultValue: '')
  final String? facility;
  @JsonKey(name: 'floor', includeIfNull: false, defaultValue: '')
  final String? floor;
  @JsonKey(name: 'asset', includeIfNull: false, defaultValue: '')
  final String? asset;
  @JsonKey(name: 'clientId', includeIfNull: false, defaultValue: '')
  final String? clientId;
  @JsonKey(name: 'client', includeIfNull: false, defaultValue: '')
  final String? $client;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'selectedBanner', includeIfNull: false)
  final int? selectedBanner;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'banners', includeIfNull: false, defaultValue: <String>[])
  final List<String>? banners;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'defaultView', includeIfNull: false, defaultValue: '')
  final String? defaultView;
  @JsonKey(name: 'hasGeoLocation', includeIfNull: false)
  final bool? hasGeoLocation;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(name: 'geolocation', includeIfNull: false)
  final GeoLocation? geolocation;
  @JsonKey(name: 'customWidget', includeIfNull: false)
  final CustomWidget? customWidget;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$DeviceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Device &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality()
                    .equals(other.facilityId, facilityId)) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality()
                    .equals(other.floorId, floorId)) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality()
                    .equals(other.assetId, assetId)) &&
            (identical(other.premise, premise) ||
                const DeepCollectionEquality()
                    .equals(other.premise, premise)) &&
            (identical(other.facility, facility) ||
                const DeepCollectionEquality()
                    .equals(other.facility, facility)) &&
            (identical(other.floor, floor) ||
                const DeepCollectionEquality().equals(other.floor, floor)) &&
            (identical(other.asset, asset) ||
                const DeepCollectionEquality().equals(other.asset, asset)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.$client, $client) ||
                const DeepCollectionEquality()
                    .equals(other.$client, $client)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.selectedBanner, selectedBanner) ||
                const DeepCollectionEquality()
                    .equals(other.selectedBanner, selectedBanner)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.banners, banners) ||
                const DeepCollectionEquality()
                    .equals(other.banners, banners)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.defaultView, defaultView) ||
                const DeepCollectionEquality()
                    .equals(other.defaultView, defaultView)) &&
            (identical(other.hasGeoLocation, hasGeoLocation) ||
                const DeepCollectionEquality()
                    .equals(other.hasGeoLocation, hasGeoLocation)) &&
            (identical(other.movable, movable) || const DeepCollectionEquality().equals(other.movable, movable)) &&
            (identical(other.geolocation, geolocation) || const DeepCollectionEquality().equals(other.geolocation, geolocation)) &&
            (identical(other.customWidget, customWidget) || const DeepCollectionEquality().equals(other.customWidget, customWidget)) &&
            (identical(other.domainKey, domainKey) || const DeepCollectionEquality().equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) || const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) || const DeepCollectionEquality().equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) || const DeepCollectionEquality().equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) || const DeepCollectionEquality().equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) || const DeepCollectionEquality().equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(premise) ^
      const DeepCollectionEquality().hash(facility) ^
      const DeepCollectionEquality().hash(floor) ^
      const DeepCollectionEquality().hash(asset) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash($client) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(selectedBanner) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(banners) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(defaultView) ^
      const DeepCollectionEquality().hash(hasGeoLocation) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(geolocation) ^
      const DeepCollectionEquality().hash(customWidget) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $DeviceExtension on Device {
  Device copyWith(
      {String? apiKey,
      int? reportedStamp,
      String? premiseId,
      String? facilityId,
      String? floorId,
      String? assetId,
      String? premise,
      String? facility,
      String? floor,
      String? asset,
      String? clientId,
      String? $client,
      String? name,
      String? description,
      String? modelId,
      String? deviceId,
      List<String>? tags,
      String? icon,
      int? selectedImage,
      int? selectedBanner,
      List<String>? images,
      List<String>? banners,
      Object? metadata,
      String? defaultView,
      bool? hasGeoLocation,
      bool? movable,
      GeoLocation? geolocation,
      CustomWidget? customWidget,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Device(
        apiKey: apiKey ?? this.apiKey,
        reportedStamp: reportedStamp ?? this.reportedStamp,
        premiseId: premiseId ?? this.premiseId,
        facilityId: facilityId ?? this.facilityId,
        floorId: floorId ?? this.floorId,
        assetId: assetId ?? this.assetId,
        premise: premise ?? this.premise,
        facility: facility ?? this.facility,
        floor: floor ?? this.floor,
        asset: asset ?? this.asset,
        clientId: clientId ?? this.clientId,
        $client: $client ?? this.$client,
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        deviceId: deviceId ?? this.deviceId,
        tags: tags ?? this.tags,
        icon: icon ?? this.icon,
        selectedImage: selectedImage ?? this.selectedImage,
        selectedBanner: selectedBanner ?? this.selectedBanner,
        images: images ?? this.images,
        banners: banners ?? this.banners,
        metadata: metadata ?? this.metadata,
        defaultView: defaultView ?? this.defaultView,
        hasGeoLocation: hasGeoLocation ?? this.hasGeoLocation,
        movable: movable ?? this.movable,
        geolocation: geolocation ?? this.geolocation,
        customWidget: customWidget ?? this.customWidget,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Device copyWithWrapped(
      {Wrapped<String>? apiKey,
      Wrapped<int>? reportedStamp,
      Wrapped<String?>? premiseId,
      Wrapped<String?>? facilityId,
      Wrapped<String?>? floorId,
      Wrapped<String?>? assetId,
      Wrapped<String?>? premise,
      Wrapped<String?>? facility,
      Wrapped<String?>? floor,
      Wrapped<String?>? asset,
      Wrapped<String?>? clientId,
      Wrapped<String?>? $client,
      Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<String>? deviceId,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? icon,
      Wrapped<int?>? selectedImage,
      Wrapped<int?>? selectedBanner,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? banners,
      Wrapped<Object?>? metadata,
      Wrapped<String?>? defaultView,
      Wrapped<bool?>? hasGeoLocation,
      Wrapped<bool?>? movable,
      Wrapped<GeoLocation?>? geolocation,
      Wrapped<CustomWidget?>? customWidget,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Device(
        apiKey: (apiKey != null ? apiKey.value : this.apiKey),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp),
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        facilityId: (facilityId != null ? facilityId.value : this.facilityId),
        floorId: (floorId != null ? floorId.value : this.floorId),
        assetId: (assetId != null ? assetId.value : this.assetId),
        premise: (premise != null ? premise.value : this.premise),
        facility: (facility != null ? facility.value : this.facility),
        floor: (floor != null ? floor.value : this.floor),
        asset: (asset != null ? asset.value : this.asset),
        clientId: (clientId != null ? clientId.value : this.clientId),
        $client: ($client != null ? $client.value : this.$client),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        tags: (tags != null ? tags.value : this.tags),
        icon: (icon != null ? icon.value : this.icon),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        selectedBanner: (selectedBanner != null
            ? selectedBanner.value
            : this.selectedBanner),
        images: (images != null ? images.value : this.images),
        banners: (banners != null ? banners.value : this.banners),
        metadata: (metadata != null ? metadata.value : this.metadata),
        defaultView:
            (defaultView != null ? defaultView.value : this.defaultView),
        hasGeoLocation: (hasGeoLocation != null
            ? hasGeoLocation.value
            : this.hasGeoLocation),
        movable: (movable != null ? movable.value : this.movable),
        geolocation:
            (geolocation != null ? geolocation.value : this.geolocation),
        customWidget:
            (customWidget != null ? customWidget.value : this.customWidget),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceEntity {
  const DeviceEntity({
    this.entity,
  });

  factory DeviceEntity.fromJson(Map<String, dynamic> json) =>
      _$DeviceEntityFromJson(json);

  static const toJsonFactory = _$DeviceEntityToJson;
  Map<String, dynamic> toJson() => _$DeviceEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Device? entity;
  static const fromJsonFactory = _$DeviceEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DeviceEntityExtension on DeviceEntity {
  DeviceEntity copyWith({Device? entity}) {
    return DeviceEntity(entity: entity ?? this.entity);
  }

  DeviceEntity copyWithWrapped({Wrapped<Device?>? entity}) {
    return DeviceEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceEntityRes {
  const DeviceEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DeviceEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceEntityResFromJson(json);

  static const toJsonFactory = _$DeviceEntityResToJson;
  Map<String, dynamic> toJson() => _$DeviceEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Device? entity;
  static const fromJsonFactory = _$DeviceEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DeviceEntityResExtension on DeviceEntityRes {
  DeviceEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Device? entity}) {
    return DeviceEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  DeviceEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Device?>? entity}) {
    return DeviceEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceArray {
  const DeviceArray({
    this.values,
  });

  factory DeviceArray.fromJson(Map<String, dynamic> json) =>
      _$DeviceArrayFromJson(json);

  static const toJsonFactory = _$DeviceArrayToJson;
  Map<String, dynamic> toJson() => _$DeviceArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Device>[])
  final List<Device>? values;
  static const fromJsonFactory = _$DeviceArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DeviceArrayExtension on DeviceArray {
  DeviceArray copyWith({List<Device>? values}) {
    return DeviceArray(values: values ?? this.values);
  }

  DeviceArray copyWithWrapped({Wrapped<List<Device>?>? values}) {
    return DeviceArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceArrayRes {
  const DeviceArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DeviceArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceArrayResFromJson(json);

  static const toJsonFactory = _$DeviceArrayResToJson;
  Map<String, dynamic> toJson() => _$DeviceArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Device>[])
  final List<Device>? values;
  static const fromJsonFactory = _$DeviceArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DeviceArrayResExtension on DeviceArrayRes {
  DeviceArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Device>? values}) {
    return DeviceArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  DeviceArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Device>?>? values}) {
    return DeviceArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionInfo {
  const ConditionInfo({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.field,
    required this.condition,
    this.$value,
    this.leftValue,
    this.rightValue,
    this.values,
    this.tags,
  });

  factory ConditionInfo.fromJson(Map<String, dynamic> json) =>
      _$ConditionInfoFromJson(json);

  static const toJsonFactory = _$ConditionInfoToJson;
  Map<String, dynamic> toJson() => _$ConditionInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String field;
  @JsonKey(
    name: 'condition',
    includeIfNull: false,
    toJson: conditionInfoConditionToJson,
    fromJson: conditionInfoConditionFromJson,
  )
  final enums.ConditionInfoCondition condition;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'leftValue', includeIfNull: false, defaultValue: '')
  final String? leftValue;
  @JsonKey(name: 'rightValue', includeIfNull: false, defaultValue: '')
  final String? rightValue;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$ConditionInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.leftValue, leftValue) ||
                const DeepCollectionEquality()
                    .equals(other.leftValue, leftValue)) &&
            (identical(other.rightValue, rightValue) ||
                const DeepCollectionEquality()
                    .equals(other.rightValue, rightValue)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(leftValue) ^
      const DeepCollectionEquality().hash(rightValue) ^
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $ConditionInfoExtension on ConditionInfo {
  ConditionInfo copyWith(
      {String? name,
      String? description,
      String? modelId,
      String? icon,
      String? field,
      enums.ConditionInfoCondition? condition,
      String? $value,
      String? leftValue,
      String? rightValue,
      List<String>? values,
      List<String>? tags}) {
    return ConditionInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        icon: icon ?? this.icon,
        field: field ?? this.field,
        condition: condition ?? this.condition,
        $value: $value ?? this.$value,
        leftValue: leftValue ?? this.leftValue,
        rightValue: rightValue ?? this.rightValue,
        values: values ?? this.values,
        tags: tags ?? this.tags);
  }

  ConditionInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<String?>? icon,
      Wrapped<String>? field,
      Wrapped<enums.ConditionInfoCondition>? condition,
      Wrapped<String?>? $value,
      Wrapped<String?>? leftValue,
      Wrapped<String?>? rightValue,
      Wrapped<List<String>?>? values,
      Wrapped<List<String>?>? tags}) {
    return ConditionInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        icon: (icon != null ? icon.value : this.icon),
        field: (field != null ? field.value : this.field),
        condition: (condition != null ? condition.value : this.condition),
        $value: ($value != null ? $value.value : this.$value),
        leftValue: (leftValue != null ? leftValue.value : this.leftValue),
        rightValue: (rightValue != null ? rightValue.value : this.rightValue),
        values: (values != null ? values.value : this.values),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class Condition {
  const Condition({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.field,
    required this.condition,
    this.$value,
    this.leftValue,
    this.rightValue,
    this.values,
    this.tags,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Condition.fromJson(Map<String, dynamic> json) =>
      _$ConditionFromJson(json);

  static const toJsonFactory = _$ConditionToJson;
  Map<String, dynamic> toJson() => _$ConditionToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String field;
  @JsonKey(
    name: 'condition',
    includeIfNull: false,
    toJson: conditionConditionToJson,
    fromJson: conditionConditionFromJson,
  )
  final enums.ConditionCondition condition;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'leftValue', includeIfNull: false, defaultValue: '')
  final String? leftValue;
  @JsonKey(name: 'rightValue', includeIfNull: false, defaultValue: '')
  final String? rightValue;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$ConditionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Condition &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.leftValue, leftValue) ||
                const DeepCollectionEquality()
                    .equals(other.leftValue, leftValue)) &&
            (identical(other.rightValue, rightValue) ||
                const DeepCollectionEquality()
                    .equals(other.rightValue, rightValue)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(leftValue) ^
      const DeepCollectionEquality().hash(rightValue) ^
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $ConditionExtension on Condition {
  Condition copyWith(
      {String? name,
      String? description,
      String? modelId,
      String? icon,
      String? field,
      enums.ConditionCondition? condition,
      String? $value,
      String? leftValue,
      String? rightValue,
      List<String>? values,
      List<String>? tags,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Condition(
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        icon: icon ?? this.icon,
        field: field ?? this.field,
        condition: condition ?? this.condition,
        $value: $value ?? this.$value,
        leftValue: leftValue ?? this.leftValue,
        rightValue: rightValue ?? this.rightValue,
        values: values ?? this.values,
        tags: tags ?? this.tags,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Condition copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<String?>? icon,
      Wrapped<String>? field,
      Wrapped<enums.ConditionCondition>? condition,
      Wrapped<String?>? $value,
      Wrapped<String?>? leftValue,
      Wrapped<String?>? rightValue,
      Wrapped<List<String>?>? values,
      Wrapped<List<String>?>? tags,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Condition(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        icon: (icon != null ? icon.value : this.icon),
        field: (field != null ? field.value : this.field),
        condition: (condition != null ? condition.value : this.condition),
        $value: ($value != null ? $value.value : this.$value),
        leftValue: (leftValue != null ? leftValue.value : this.leftValue),
        rightValue: (rightValue != null ? rightValue.value : this.rightValue),
        values: (values != null ? values.value : this.values),
        tags: (tags != null ? tags.value : this.tags),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionEntity {
  const ConditionEntity({
    this.entity,
  });

  factory ConditionEntity.fromJson(Map<String, dynamic> json) =>
      _$ConditionEntityFromJson(json);

  static const toJsonFactory = _$ConditionEntityToJson;
  Map<String, dynamic> toJson() => _$ConditionEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Condition? entity;
  static const fromJsonFactory = _$ConditionEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ConditionEntityExtension on ConditionEntity {
  ConditionEntity copyWith({Condition? entity}) {
    return ConditionEntity(entity: entity ?? this.entity);
  }

  ConditionEntity copyWithWrapped({Wrapped<Condition?>? entity}) {
    return ConditionEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionEntityRes {
  const ConditionEntityRes({
    this.entity,
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory ConditionEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ConditionEntityResFromJson(json);

  static const toJsonFactory = _$ConditionEntityResToJson;
  Map<String, dynamic> toJson() => _$ConditionEntityResToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Condition? entity;
  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$ConditionEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionEntityRes &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)) &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $ConditionEntityResExtension on ConditionEntityRes {
  ConditionEntityRes copyWith(
      {Condition? entity,
      bool? ok,
      String? msg,
      String? trace,
      String? errorCode}) {
    return ConditionEntityRes(
        entity: entity ?? this.entity,
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode);
  }

  ConditionEntityRes copyWithWrapped(
      {Wrapped<Condition?>? entity,
      Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode}) {
    return ConditionEntityRes(
        entity: (entity != null ? entity.value : this.entity),
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode));
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionArray {
  const ConditionArray({
    this.values,
  });

  factory ConditionArray.fromJson(Map<String, dynamic> json) =>
      _$ConditionArrayFromJson(json);

  static const toJsonFactory = _$ConditionArrayToJson;
  Map<String, dynamic> toJson() => _$ConditionArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Condition>[])
  final List<Condition>? values;
  static const fromJsonFactory = _$ConditionArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ConditionArrayExtension on ConditionArray {
  ConditionArray copyWith({List<Condition>? values}) {
    return ConditionArray(values: values ?? this.values);
  }

  ConditionArray copyWithWrapped({Wrapped<List<Condition>?>? values}) {
    return ConditionArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ConditionArrayRes {
  const ConditionArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ConditionArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ConditionArrayResFromJson(json);

  static const toJsonFactory = _$ConditionArrayResToJson;
  Map<String, dynamic> toJson() => _$ConditionArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Condition>[])
  final List<Condition>? values;
  static const fromJsonFactory = _$ConditionArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConditionArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ConditionArrayResExtension on ConditionArrayRes {
  ConditionArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Condition>? values}) {
    return ConditionArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  ConditionArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Condition>?>? values}) {
    return ConditionArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class MatchGroup {
  const MatchGroup({
    required this.matchType,
    required this.conditions,
  });

  factory MatchGroup.fromJson(Map<String, dynamic> json) =>
      _$MatchGroupFromJson(json);

  static const toJsonFactory = _$MatchGroupToJson;
  Map<String, dynamic> toJson() => _$MatchGroupToJson(this);

  @JsonKey(
    name: 'matchType',
    includeIfNull: false,
    toJson: matchGroupMatchTypeToJson,
    fromJson: matchGroupMatchTypeFromJson,
  )
  final enums.MatchGroupMatchType matchType;
  @JsonKey(name: 'conditions', includeIfNull: false, defaultValue: <String>[])
  final List<String> conditions;
  static const fromJsonFactory = _$MatchGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MatchGroup &&
            (identical(other.matchType, matchType) ||
                const DeepCollectionEquality()
                    .equals(other.matchType, matchType)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(matchType) ^
      const DeepCollectionEquality().hash(conditions) ^
      runtimeType.hashCode;
}

extension $MatchGroupExtension on MatchGroup {
  MatchGroup copyWith(
      {enums.MatchGroupMatchType? matchType, List<String>? conditions}) {
    return MatchGroup(
        matchType: matchType ?? this.matchType,
        conditions: conditions ?? this.conditions);
  }

  MatchGroup copyWithWrapped(
      {Wrapped<enums.MatchGroupMatchType>? matchType,
      Wrapped<List<String>>? conditions}) {
    return MatchGroup(
        matchType: (matchType != null ? matchType.value : this.matchType),
        conditions: (conditions != null ? conditions.value : this.conditions));
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmMatchGroup {
  const AlarmMatchGroup({
    required this.matchType,
    required this.conditions,
    required this.alarmState,
    this.deviceState,
    this.tooltip,
  });

  factory AlarmMatchGroup.fromJson(Map<String, dynamic> json) =>
      _$AlarmMatchGroupFromJson(json);

  static const toJsonFactory = _$AlarmMatchGroupToJson;
  Map<String, dynamic> toJson() => _$AlarmMatchGroupToJson(this);

  @JsonKey(
    name: 'matchType',
    includeIfNull: false,
    toJson: alarmMatchGroupMatchTypeToJson,
    fromJson: alarmMatchGroupMatchTypeFromJson,
  )
  final enums.AlarmMatchGroupMatchType matchType;
  @JsonKey(name: 'conditions', includeIfNull: false, defaultValue: <String>[])
  final List<String> conditions;
  @JsonKey(name: 'alarmState', includeIfNull: false)
  final int alarmState;
  @JsonKey(name: 'deviceState', includeIfNull: false)
  final int? deviceState;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  static const fromJsonFactory = _$AlarmMatchGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmMatchGroup &&
            (identical(other.matchType, matchType) ||
                const DeepCollectionEquality()
                    .equals(other.matchType, matchType)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.alarmState, alarmState) ||
                const DeepCollectionEquality()
                    .equals(other.alarmState, alarmState)) &&
            (identical(other.deviceState, deviceState) ||
                const DeepCollectionEquality()
                    .equals(other.deviceState, deviceState)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(other.tooltip, tooltip)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(matchType) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(alarmState) ^
      const DeepCollectionEquality().hash(deviceState) ^
      const DeepCollectionEquality().hash(tooltip) ^
      runtimeType.hashCode;
}

extension $AlarmMatchGroupExtension on AlarmMatchGroup {
  AlarmMatchGroup copyWith(
      {enums.AlarmMatchGroupMatchType? matchType,
      List<String>? conditions,
      int? alarmState,
      int? deviceState,
      String? tooltip}) {
    return AlarmMatchGroup(
        matchType: matchType ?? this.matchType,
        conditions: conditions ?? this.conditions,
        alarmState: alarmState ?? this.alarmState,
        deviceState: deviceState ?? this.deviceState,
        tooltip: tooltip ?? this.tooltip);
  }

  AlarmMatchGroup copyWithWrapped(
      {Wrapped<enums.AlarmMatchGroupMatchType>? matchType,
      Wrapped<List<String>>? conditions,
      Wrapped<int>? alarmState,
      Wrapped<int?>? deviceState,
      Wrapped<String?>? tooltip}) {
    return AlarmMatchGroup(
        matchType: (matchType != null ? matchType.value : this.matchType),
        conditions: (conditions != null ? conditions.value : this.conditions),
        alarmState: (alarmState != null ? alarmState.value : this.alarmState),
        deviceState:
            (deviceState != null ? deviceState.value : this.deviceState),
        tooltip: (tooltip != null ? tooltip.value : this.tooltip));
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmInfo {
  const AlarmInfo({
    required this.name,
    this.description,
    this.label,
    required this.modelId,
    required this.state,
    this.stateIcons,
    required this.conditions,
    this.tags,
    this.showOnlyIfMatched,
  });

  factory AlarmInfo.fromJson(Map<String, dynamic> json) =>
      _$AlarmInfoFromJson(json);

  static const toJsonFactory = _$AlarmInfoToJson;
  Map<String, dynamic> toJson() => _$AlarmInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int state;
  @JsonKey(name: 'stateIcons', includeIfNull: false, defaultValue: <String>[])
  final List<String>? stateIcons;
  @JsonKey(
      name: 'conditions',
      includeIfNull: false,
      defaultValue: <AlarmMatchGroup>[])
  final List<AlarmMatchGroup> conditions;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'showOnlyIfMatched', includeIfNull: false)
  final bool? showOnlyIfMatched;
  static const fromJsonFactory = _$AlarmInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcons, stateIcons) ||
                const DeepCollectionEquality()
                    .equals(other.stateIcons, stateIcons)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.showOnlyIfMatched, showOnlyIfMatched) ||
                const DeepCollectionEquality()
                    .equals(other.showOnlyIfMatched, showOnlyIfMatched)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcons) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(showOnlyIfMatched) ^
      runtimeType.hashCode;
}

extension $AlarmInfoExtension on AlarmInfo {
  AlarmInfo copyWith(
      {String? name,
      String? description,
      String? label,
      String? modelId,
      int? state,
      List<String>? stateIcons,
      List<AlarmMatchGroup>? conditions,
      List<String>? tags,
      bool? showOnlyIfMatched}) {
    return AlarmInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        modelId: modelId ?? this.modelId,
        state: state ?? this.state,
        stateIcons: stateIcons ?? this.stateIcons,
        conditions: conditions ?? this.conditions,
        tags: tags ?? this.tags,
        showOnlyIfMatched: showOnlyIfMatched ?? this.showOnlyIfMatched);
  }

  AlarmInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<String>? modelId,
      Wrapped<int>? state,
      Wrapped<List<String>?>? stateIcons,
      Wrapped<List<AlarmMatchGroup>>? conditions,
      Wrapped<List<String>?>? tags,
      Wrapped<bool?>? showOnlyIfMatched}) {
    return AlarmInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        modelId: (modelId != null ? modelId.value : this.modelId),
        state: (state != null ? state.value : this.state),
        stateIcons: (stateIcons != null ? stateIcons.value : this.stateIcons),
        conditions: (conditions != null ? conditions.value : this.conditions),
        tags: (tags != null ? tags.value : this.tags),
        showOnlyIfMatched: (showOnlyIfMatched != null
            ? showOnlyIfMatched.value
            : this.showOnlyIfMatched));
  }
}

@JsonSerializable(explicitToJson: true)
class Alarm {
  const Alarm({
    required this.name,
    this.description,
    this.label,
    required this.modelId,
    required this.state,
    this.stateIcons,
    required this.conditions,
    this.tags,
    this.showOnlyIfMatched,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Alarm.fromJson(Map<String, dynamic> json) => _$AlarmFromJson(json);

  static const toJsonFactory = _$AlarmToJson;
  Map<String, dynamic> toJson() => _$AlarmToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int state;
  @JsonKey(name: 'stateIcons', includeIfNull: false, defaultValue: <String>[])
  final List<String>? stateIcons;
  @JsonKey(
      name: 'conditions',
      includeIfNull: false,
      defaultValue: <AlarmMatchGroup>[])
  final List<AlarmMatchGroup> conditions;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'showOnlyIfMatched', includeIfNull: false)
  final bool? showOnlyIfMatched;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$AlarmFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Alarm &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcons, stateIcons) ||
                const DeepCollectionEquality()
                    .equals(other.stateIcons, stateIcons)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.showOnlyIfMatched, showOnlyIfMatched) ||
                const DeepCollectionEquality()
                    .equals(other.showOnlyIfMatched, showOnlyIfMatched)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcons) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(showOnlyIfMatched) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $AlarmExtension on Alarm {
  Alarm copyWith(
      {String? name,
      String? description,
      String? label,
      String? modelId,
      int? state,
      List<String>? stateIcons,
      List<AlarmMatchGroup>? conditions,
      List<String>? tags,
      bool? showOnlyIfMatched,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Alarm(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        modelId: modelId ?? this.modelId,
        state: state ?? this.state,
        stateIcons: stateIcons ?? this.stateIcons,
        conditions: conditions ?? this.conditions,
        tags: tags ?? this.tags,
        showOnlyIfMatched: showOnlyIfMatched ?? this.showOnlyIfMatched,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Alarm copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<String>? modelId,
      Wrapped<int>? state,
      Wrapped<List<String>?>? stateIcons,
      Wrapped<List<AlarmMatchGroup>>? conditions,
      Wrapped<List<String>?>? tags,
      Wrapped<bool?>? showOnlyIfMatched,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Alarm(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        modelId: (modelId != null ? modelId.value : this.modelId),
        state: (state != null ? state.value : this.state),
        stateIcons: (stateIcons != null ? stateIcons.value : this.stateIcons),
        conditions: (conditions != null ? conditions.value : this.conditions),
        tags: (tags != null ? tags.value : this.tags),
        showOnlyIfMatched: (showOnlyIfMatched != null
            ? showOnlyIfMatched.value
            : this.showOnlyIfMatched),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmEntity {
  const AlarmEntity({
    this.entity,
  });

  factory AlarmEntity.fromJson(Map<String, dynamic> json) =>
      _$AlarmEntityFromJson(json);

  static const toJsonFactory = _$AlarmEntityToJson;
  Map<String, dynamic> toJson() => _$AlarmEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Alarm? entity;
  static const fromJsonFactory = _$AlarmEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AlarmEntityExtension on AlarmEntity {
  AlarmEntity copyWith({Alarm? entity}) {
    return AlarmEntity(entity: entity ?? this.entity);
  }

  AlarmEntity copyWithWrapped({Wrapped<Alarm?>? entity}) {
    return AlarmEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmEntityRes {
  const AlarmEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AlarmEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AlarmEntityResFromJson(json);

  static const toJsonFactory = _$AlarmEntityResToJson;
  Map<String, dynamic> toJson() => _$AlarmEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Alarm? entity;
  static const fromJsonFactory = _$AlarmEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AlarmEntityResExtension on AlarmEntityRes {
  AlarmEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Alarm? entity}) {
    return AlarmEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  AlarmEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Alarm?>? entity}) {
    return AlarmEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmArray {
  const AlarmArray({
    this.values,
  });

  factory AlarmArray.fromJson(Map<String, dynamic> json) =>
      _$AlarmArrayFromJson(json);

  static const toJsonFactory = _$AlarmArrayToJson;
  Map<String, dynamic> toJson() => _$AlarmArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Alarm>[])
  final List<Alarm>? values;
  static const fromJsonFactory = _$AlarmArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AlarmArrayExtension on AlarmArray {
  AlarmArray copyWith({List<Alarm>? values}) {
    return AlarmArray(values: values ?? this.values);
  }

  AlarmArray copyWithWrapped({Wrapped<List<Alarm>?>? values}) {
    return AlarmArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AlarmArrayRes {
  const AlarmArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AlarmArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AlarmArrayResFromJson(json);

  static const toJsonFactory = _$AlarmArrayResToJson;
  Map<String, dynamic> toJson() => _$AlarmArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Alarm>[])
  final List<Alarm>? values;
  static const fromJsonFactory = _$AlarmArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlarmArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AlarmArrayResExtension on AlarmArrayRes {
  AlarmArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Alarm>? values}) {
    return AlarmArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  AlarmArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Alarm>?>? values}) {
    return AlarmArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ControlCommand {
  const ControlCommand({
    required this.type,
    this.fixedType,
    this.jsonValue,
    this.textValue,
    this.binaryValue,
    this.parameters,
  });

  factory ControlCommand.fromJson(Map<String, dynamic> json) =>
      _$ControlCommandFromJson(json);

  static const toJsonFactory = _$ControlCommandToJson;
  Map<String, dynamic> toJson() => _$ControlCommandToJson(this);

  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: controlCommandTypeToJson,
    fromJson: controlCommandTypeFromJson,
  )
  final enums.ControlCommandType type;
  @JsonKey(
    name: 'fixedType',
    includeIfNull: false,
    toJson: controlCommandFixedTypeNullableToJson,
    fromJson: controlCommandFixedTypeNullableFromJson,
  )
  final enums.ControlCommandFixedType? fixedType;
  @JsonKey(name: 'jsonValue', includeIfNull: false)
  final Object? jsonValue;
  @JsonKey(name: 'textValue', includeIfNull: false, defaultValue: '')
  final String? textValue;
  @JsonKey(name: 'binaryValue', includeIfNull: false, defaultValue: '')
  final String? binaryValue;
  @JsonKey(
      name: 'parameters', includeIfNull: false, defaultValue: <Parameter>[])
  final List<Parameter>? parameters;
  static const fromJsonFactory = _$ControlCommandFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlCommand &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.fixedType, fixedType) ||
                const DeepCollectionEquality()
                    .equals(other.fixedType, fixedType)) &&
            (identical(other.jsonValue, jsonValue) ||
                const DeepCollectionEquality()
                    .equals(other.jsonValue, jsonValue)) &&
            (identical(other.textValue, textValue) ||
                const DeepCollectionEquality()
                    .equals(other.textValue, textValue)) &&
            (identical(other.binaryValue, binaryValue) ||
                const DeepCollectionEquality()
                    .equals(other.binaryValue, binaryValue)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(fixedType) ^
      const DeepCollectionEquality().hash(jsonValue) ^
      const DeepCollectionEquality().hash(textValue) ^
      const DeepCollectionEquality().hash(binaryValue) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $ControlCommandExtension on ControlCommand {
  ControlCommand copyWith(
      {enums.ControlCommandType? type,
      enums.ControlCommandFixedType? fixedType,
      Object? jsonValue,
      String? textValue,
      String? binaryValue,
      List<Parameter>? parameters}) {
    return ControlCommand(
        type: type ?? this.type,
        fixedType: fixedType ?? this.fixedType,
        jsonValue: jsonValue ?? this.jsonValue,
        textValue: textValue ?? this.textValue,
        binaryValue: binaryValue ?? this.binaryValue,
        parameters: parameters ?? this.parameters);
  }

  ControlCommand copyWithWrapped(
      {Wrapped<enums.ControlCommandType>? type,
      Wrapped<enums.ControlCommandFixedType?>? fixedType,
      Wrapped<Object?>? jsonValue,
      Wrapped<String?>? textValue,
      Wrapped<String?>? binaryValue,
      Wrapped<List<Parameter>?>? parameters}) {
    return ControlCommand(
        type: (type != null ? type.value : this.type),
        fixedType: (fixedType != null ? fixedType.value : this.fixedType),
        jsonValue: (jsonValue != null ? jsonValue.value : this.jsonValue),
        textValue: (textValue != null ? textValue.value : this.textValue),
        binaryValue:
            (binaryValue != null ? binaryValue.value : this.binaryValue),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class ControlInfo {
  const ControlInfo({
    required this.name,
    this.description,
    required this.modelId,
    required this.state,
    this.stateIcons,
    this.tags,
    this.commands,
  });

  factory ControlInfo.fromJson(Map<String, dynamic> json) =>
      _$ControlInfoFromJson(json);

  static const toJsonFactory = _$ControlInfoToJson;
  Map<String, dynamic> toJson() => _$ControlInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int state;
  @JsonKey(name: 'stateIcons', includeIfNull: false, defaultValue: <String>[])
  final List<String>? stateIcons;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
      name: 'commands', includeIfNull: false, defaultValue: <ControlCommand>[])
  final List<ControlCommand>? commands;
  static const fromJsonFactory = _$ControlInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcons, stateIcons) ||
                const DeepCollectionEquality()
                    .equals(other.stateIcons, stateIcons)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.commands, commands) ||
                const DeepCollectionEquality()
                    .equals(other.commands, commands)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcons) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(commands) ^
      runtimeType.hashCode;
}

extension $ControlInfoExtension on ControlInfo {
  ControlInfo copyWith(
      {String? name,
      String? description,
      String? modelId,
      int? state,
      List<String>? stateIcons,
      List<String>? tags,
      List<ControlCommand>? commands}) {
    return ControlInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        state: state ?? this.state,
        stateIcons: stateIcons ?? this.stateIcons,
        tags: tags ?? this.tags,
        commands: commands ?? this.commands);
  }

  ControlInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<int>? state,
      Wrapped<List<String>?>? stateIcons,
      Wrapped<List<String>?>? tags,
      Wrapped<List<ControlCommand>?>? commands}) {
    return ControlInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        state: (state != null ? state.value : this.state),
        stateIcons: (stateIcons != null ? stateIcons.value : this.stateIcons),
        tags: (tags != null ? tags.value : this.tags),
        commands: (commands != null ? commands.value : this.commands));
  }
}

@JsonSerializable(explicitToJson: true)
class Control {
  const Control({
    required this.name,
    this.description,
    required this.modelId,
    required this.state,
    this.stateIcons,
    this.tags,
    this.commands,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Control.fromJson(Map<String, dynamic> json) =>
      _$ControlFromJson(json);

  static const toJsonFactory = _$ControlToJson;
  Map<String, dynamic> toJson() => _$ControlToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int state;
  @JsonKey(name: 'stateIcons', includeIfNull: false, defaultValue: <String>[])
  final List<String>? stateIcons;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
      name: 'commands', includeIfNull: false, defaultValue: <ControlCommand>[])
  final List<ControlCommand>? commands;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$ControlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Control &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcons, stateIcons) ||
                const DeepCollectionEquality()
                    .equals(other.stateIcons, stateIcons)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.commands, commands) ||
                const DeepCollectionEquality()
                    .equals(other.commands, commands)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcons) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(commands) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $ControlExtension on Control {
  Control copyWith(
      {String? name,
      String? description,
      String? modelId,
      int? state,
      List<String>? stateIcons,
      List<String>? tags,
      List<ControlCommand>? commands,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Control(
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        state: state ?? this.state,
        stateIcons: stateIcons ?? this.stateIcons,
        tags: tags ?? this.tags,
        commands: commands ?? this.commands,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Control copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<int>? state,
      Wrapped<List<String>?>? stateIcons,
      Wrapped<List<String>?>? tags,
      Wrapped<List<ControlCommand>?>? commands,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Control(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        state: (state != null ? state.value : this.state),
        stateIcons: (stateIcons != null ? stateIcons.value : this.stateIcons),
        tags: (tags != null ? tags.value : this.tags),
        commands: (commands != null ? commands.value : this.commands),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class ControlEntity {
  const ControlEntity({
    this.entity,
  });

  factory ControlEntity.fromJson(Map<String, dynamic> json) =>
      _$ControlEntityFromJson(json);

  static const toJsonFactory = _$ControlEntityToJson;
  Map<String, dynamic> toJson() => _$ControlEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Control? entity;
  static const fromJsonFactory = _$ControlEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ControlEntityExtension on ControlEntity {
  ControlEntity copyWith({Control? entity}) {
    return ControlEntity(entity: entity ?? this.entity);
  }

  ControlEntity copyWithWrapped({Wrapped<Control?>? entity}) {
    return ControlEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ControlEntityRes {
  const ControlEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ControlEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ControlEntityResFromJson(json);

  static const toJsonFactory = _$ControlEntityResToJson;
  Map<String, dynamic> toJson() => _$ControlEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Control? entity;
  static const fromJsonFactory = _$ControlEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ControlEntityResExtension on ControlEntityRes {
  ControlEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Control? entity}) {
    return ControlEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  ControlEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Control?>? entity}) {
    return ControlEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ControlArray {
  const ControlArray({
    this.values,
  });

  factory ControlArray.fromJson(Map<String, dynamic> json) =>
      _$ControlArrayFromJson(json);

  static const toJsonFactory = _$ControlArrayToJson;
  Map<String, dynamic> toJson() => _$ControlArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Control>[])
  final List<Control>? values;
  static const fromJsonFactory = _$ControlArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ControlArrayExtension on ControlArray {
  ControlArray copyWith({List<Control>? values}) {
    return ControlArray(values: values ?? this.values);
  }

  ControlArray copyWithWrapped({Wrapped<List<Control>?>? values}) {
    return ControlArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ControlArrayRes {
  const ControlArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ControlArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ControlArrayResFromJson(json);

  static const toJsonFactory = _$ControlArrayResToJson;
  Map<String, dynamic> toJson() => _$ControlArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Control>[])
  final List<Control>? values;
  static const fromJsonFactory = _$ControlArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ControlArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ControlArrayResExtension on ControlArrayRes {
  ControlArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Control>? values}) {
    return ControlArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  ControlArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Control>?>? values}) {
    return ControlArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class EventInfo {
  const EventInfo({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.conditions,
    this.notificationTemplate,
    this.emailTemplate,
    this.smsTemplate,
    this.fcmTemplate,
    this.voiceTemplate,
    this.tags,
    this.roles,
  });

  factory EventInfo.fromJson(Map<String, dynamic> json) =>
      _$EventInfoFromJson(json);

  static const toJsonFactory = _$EventInfoToJson;
  Map<String, dynamic> toJson() => _$EventInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
      name: 'conditions', includeIfNull: false, defaultValue: <MatchGroup>[])
  final List<MatchGroup> conditions;
  @JsonKey(name: 'notificationTemplate', includeIfNull: false)
  final NotificationTemplate? notificationTemplate;
  @JsonKey(name: 'emailTemplate', includeIfNull: false)
  final EmailTemplate? emailTemplate;
  @JsonKey(name: 'smsTemplate', includeIfNull: false)
  final SMSTemplate? smsTemplate;
  @JsonKey(name: 'fcmTemplate', includeIfNull: false)
  final FCMTemplate? fcmTemplate;
  @JsonKey(name: 'voiceTemplate', includeIfNull: false)
  final VoiceTemplate? voiceTemplate;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  static const fromJsonFactory = _$EventInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.notificationTemplate, notificationTemplate) ||
                const DeepCollectionEquality().equals(
                    other.notificationTemplate, notificationTemplate)) &&
            (identical(other.emailTemplate, emailTemplate) ||
                const DeepCollectionEquality()
                    .equals(other.emailTemplate, emailTemplate)) &&
            (identical(other.smsTemplate, smsTemplate) ||
                const DeepCollectionEquality()
                    .equals(other.smsTemplate, smsTemplate)) &&
            (identical(other.fcmTemplate, fcmTemplate) ||
                const DeepCollectionEquality()
                    .equals(other.fcmTemplate, fcmTemplate)) &&
            (identical(other.voiceTemplate, voiceTemplate) ||
                const DeepCollectionEquality()
                    .equals(other.voiceTemplate, voiceTemplate)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(notificationTemplate) ^
      const DeepCollectionEquality().hash(emailTemplate) ^
      const DeepCollectionEquality().hash(smsTemplate) ^
      const DeepCollectionEquality().hash(fcmTemplate) ^
      const DeepCollectionEquality().hash(voiceTemplate) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      runtimeType.hashCode;
}

extension $EventInfoExtension on EventInfo {
  EventInfo copyWith(
      {String? name,
      String? description,
      String? modelId,
      String? icon,
      List<MatchGroup>? conditions,
      NotificationTemplate? notificationTemplate,
      EmailTemplate? emailTemplate,
      SMSTemplate? smsTemplate,
      FCMTemplate? fcmTemplate,
      VoiceTemplate? voiceTemplate,
      List<String>? tags,
      List<String>? roles}) {
    return EventInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        icon: icon ?? this.icon,
        conditions: conditions ?? this.conditions,
        notificationTemplate: notificationTemplate ?? this.notificationTemplate,
        emailTemplate: emailTemplate ?? this.emailTemplate,
        smsTemplate: smsTemplate ?? this.smsTemplate,
        fcmTemplate: fcmTemplate ?? this.fcmTemplate,
        voiceTemplate: voiceTemplate ?? this.voiceTemplate,
        tags: tags ?? this.tags,
        roles: roles ?? this.roles);
  }

  EventInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<String?>? icon,
      Wrapped<List<MatchGroup>>? conditions,
      Wrapped<NotificationTemplate?>? notificationTemplate,
      Wrapped<EmailTemplate?>? emailTemplate,
      Wrapped<SMSTemplate?>? smsTemplate,
      Wrapped<FCMTemplate?>? fcmTemplate,
      Wrapped<VoiceTemplate?>? voiceTemplate,
      Wrapped<List<String>?>? tags,
      Wrapped<List<String>?>? roles}) {
    return EventInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        icon: (icon != null ? icon.value : this.icon),
        conditions: (conditions != null ? conditions.value : this.conditions),
        notificationTemplate: (notificationTemplate != null
            ? notificationTemplate.value
            : this.notificationTemplate),
        emailTemplate:
            (emailTemplate != null ? emailTemplate.value : this.emailTemplate),
        smsTemplate:
            (smsTemplate != null ? smsTemplate.value : this.smsTemplate),
        fcmTemplate:
            (fcmTemplate != null ? fcmTemplate.value : this.fcmTemplate),
        voiceTemplate:
            (voiceTemplate != null ? voiceTemplate.value : this.voiceTemplate),
        tags: (tags != null ? tags.value : this.tags),
        roles: (roles != null ? roles.value : this.roles));
  }
}

@JsonSerializable(explicitToJson: true)
class Event {
  const Event({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.conditions,
    this.notificationTemplate,
    this.emailTemplate,
    this.smsTemplate,
    this.fcmTemplate,
    this.voiceTemplate,
    this.tags,
    this.roles,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Event.fromJson(Map<String, dynamic> json) => _$EventFromJson(json);

  static const toJsonFactory = _$EventToJson;
  Map<String, dynamic> toJson() => _$EventToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
      name: 'conditions', includeIfNull: false, defaultValue: <MatchGroup>[])
  final List<MatchGroup> conditions;
  @JsonKey(name: 'notificationTemplate', includeIfNull: false)
  final NotificationTemplate? notificationTemplate;
  @JsonKey(name: 'emailTemplate', includeIfNull: false)
  final EmailTemplate? emailTemplate;
  @JsonKey(name: 'smsTemplate', includeIfNull: false)
  final SMSTemplate? smsTemplate;
  @JsonKey(name: 'fcmTemplate', includeIfNull: false)
  final FCMTemplate? fcmTemplate;
  @JsonKey(name: 'voiceTemplate', includeIfNull: false)
  final VoiceTemplate? voiceTemplate;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$EventFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Event &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.notificationTemplate, notificationTemplate) ||
                const DeepCollectionEquality().equals(
                    other.notificationTemplate, notificationTemplate)) &&
            (identical(other.emailTemplate, emailTemplate) ||
                const DeepCollectionEquality()
                    .equals(other.emailTemplate, emailTemplate)) &&
            (identical(other.smsTemplate, smsTemplate) ||
                const DeepCollectionEquality()
                    .equals(other.smsTemplate, smsTemplate)) &&
            (identical(other.fcmTemplate, fcmTemplate) ||
                const DeepCollectionEquality()
                    .equals(other.fcmTemplate, fcmTemplate)) &&
            (identical(other.voiceTemplate, voiceTemplate) ||
                const DeepCollectionEquality()
                    .equals(other.voiceTemplate, voiceTemplate)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(notificationTemplate) ^
      const DeepCollectionEquality().hash(emailTemplate) ^
      const DeepCollectionEquality().hash(smsTemplate) ^
      const DeepCollectionEquality().hash(fcmTemplate) ^
      const DeepCollectionEquality().hash(voiceTemplate) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $EventExtension on Event {
  Event copyWith(
      {String? name,
      String? description,
      String? modelId,
      String? icon,
      List<MatchGroup>? conditions,
      NotificationTemplate? notificationTemplate,
      EmailTemplate? emailTemplate,
      SMSTemplate? smsTemplate,
      FCMTemplate? fcmTemplate,
      VoiceTemplate? voiceTemplate,
      List<String>? tags,
      List<String>? roles,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Event(
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        icon: icon ?? this.icon,
        conditions: conditions ?? this.conditions,
        notificationTemplate: notificationTemplate ?? this.notificationTemplate,
        emailTemplate: emailTemplate ?? this.emailTemplate,
        smsTemplate: smsTemplate ?? this.smsTemplate,
        fcmTemplate: fcmTemplate ?? this.fcmTemplate,
        voiceTemplate: voiceTemplate ?? this.voiceTemplate,
        tags: tags ?? this.tags,
        roles: roles ?? this.roles,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Event copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<String?>? icon,
      Wrapped<List<MatchGroup>>? conditions,
      Wrapped<NotificationTemplate?>? notificationTemplate,
      Wrapped<EmailTemplate?>? emailTemplate,
      Wrapped<SMSTemplate?>? smsTemplate,
      Wrapped<FCMTemplate?>? fcmTemplate,
      Wrapped<VoiceTemplate?>? voiceTemplate,
      Wrapped<List<String>?>? tags,
      Wrapped<List<String>?>? roles,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Event(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        icon: (icon != null ? icon.value : this.icon),
        conditions: (conditions != null ? conditions.value : this.conditions),
        notificationTemplate: (notificationTemplate != null
            ? notificationTemplate.value
            : this.notificationTemplate),
        emailTemplate:
            (emailTemplate != null ? emailTemplate.value : this.emailTemplate),
        smsTemplate:
            (smsTemplate != null ? smsTemplate.value : this.smsTemplate),
        fcmTemplate:
            (fcmTemplate != null ? fcmTemplate.value : this.fcmTemplate),
        voiceTemplate:
            (voiceTemplate != null ? voiceTemplate.value : this.voiceTemplate),
        tags: (tags != null ? tags.value : this.tags),
        roles: (roles != null ? roles.value : this.roles),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class EventEntity {
  const EventEntity({
    this.entity,
  });

  factory EventEntity.fromJson(Map<String, dynamic> json) =>
      _$EventEntityFromJson(json);

  static const toJsonFactory = _$EventEntityToJson;
  Map<String, dynamic> toJson() => _$EventEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Event? entity;
  static const fromJsonFactory = _$EventEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $EventEntityExtension on EventEntity {
  EventEntity copyWith({Event? entity}) {
    return EventEntity(entity: entity ?? this.entity);
  }

  EventEntity copyWithWrapped({Wrapped<Event?>? entity}) {
    return EventEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class EventEntityRes {
  const EventEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory EventEntityRes.fromJson(Map<String, dynamic> json) =>
      _$EventEntityResFromJson(json);

  static const toJsonFactory = _$EventEntityResToJson;
  Map<String, dynamic> toJson() => _$EventEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Event? entity;
  static const fromJsonFactory = _$EventEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $EventEntityResExtension on EventEntityRes {
  EventEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Event? entity}) {
    return EventEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  EventEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Event?>? entity}) {
    return EventEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class EventArray {
  const EventArray({
    this.values,
  });

  factory EventArray.fromJson(Map<String, dynamic> json) =>
      _$EventArrayFromJson(json);

  static const toJsonFactory = _$EventArrayToJson;
  Map<String, dynamic> toJson() => _$EventArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Event>[])
  final List<Event>? values;
  static const fromJsonFactory = _$EventArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $EventArrayExtension on EventArray {
  EventArray copyWith({List<Event>? values}) {
    return EventArray(values: values ?? this.values);
  }

  EventArray copyWithWrapped({Wrapped<List<Event>?>? values}) {
    return EventArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class EventArrayRes {
  const EventArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory EventArrayRes.fromJson(Map<String, dynamic> json) =>
      _$EventArrayResFromJson(json);

  static const toJsonFactory = _$EventArrayResToJson;
  Map<String, dynamic> toJson() => _$EventArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Event>[])
  final List<Event>? values;
  static const fromJsonFactory = _$EventArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $EventArrayResExtension on EventArrayRes {
  EventArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Event>? values}) {
    return EventArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  EventArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Event>?>? values}) {
    return EventArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class HttpParam {
  const HttpParam({
    required this.name,
    this.$value,
  });

  factory HttpParam.fromJson(Map<String, dynamic> json) =>
      _$HttpParamFromJson(json);

  static const toJsonFactory = _$HttpParamToJson;
  Map<String, dynamic> toJson() => _$HttpParamToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  static const fromJsonFactory = _$HttpParamFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HttpParam &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $HttpParamExtension on HttpParam {
  HttpParam copyWith({String? name, String? $value}) {
    return HttpParam(name: name ?? this.name, $value: $value ?? this.$value);
  }

  HttpParam copyWithWrapped({Wrapped<String>? name, Wrapped<String?>? $value}) {
    return HttpParam(
        name: (name != null ? name.value : this.name),
        $value: ($value != null ? $value.value : this.$value));
  }
}

@JsonSerializable(explicitToJson: true)
class HttpConfig {
  const HttpConfig({
    required this.url,
    required this.protocol,
    this.headers,
    this.queryParameters,
  });

  factory HttpConfig.fromJson(Map<String, dynamic> json) =>
      _$HttpConfigFromJson(json);

  static const toJsonFactory = _$HttpConfigToJson;
  Map<String, dynamic> toJson() => _$HttpConfigToJson(this);

  @JsonKey(name: 'url', includeIfNull: false, defaultValue: '')
  final String url;
  @JsonKey(
    name: 'protocol',
    includeIfNull: false,
    toJson: httpConfigProtocolToJson,
    fromJson: httpConfigProtocolFromJson,
  )
  final enums.HttpConfigProtocol protocol;
  @JsonKey(name: 'headers', includeIfNull: false, defaultValue: <HttpParam>[])
  final List<HttpParam>? headers;
  @JsonKey(
      name: 'queryParameters',
      includeIfNull: false,
      defaultValue: <HttpParam>[])
  final List<HttpParam>? queryParameters;
  static const fromJsonFactory = _$HttpConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HttpConfig &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.protocol, protocol) ||
                const DeepCollectionEquality()
                    .equals(other.protocol, protocol)) &&
            (identical(other.headers, headers) ||
                const DeepCollectionEquality()
                    .equals(other.headers, headers)) &&
            (identical(other.queryParameters, queryParameters) ||
                const DeepCollectionEquality()
                    .equals(other.queryParameters, queryParameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(protocol) ^
      const DeepCollectionEquality().hash(headers) ^
      const DeepCollectionEquality().hash(queryParameters) ^
      runtimeType.hashCode;
}

extension $HttpConfigExtension on HttpConfig {
  HttpConfig copyWith(
      {String? url,
      enums.HttpConfigProtocol? protocol,
      List<HttpParam>? headers,
      List<HttpParam>? queryParameters}) {
    return HttpConfig(
        url: url ?? this.url,
        protocol: protocol ?? this.protocol,
        headers: headers ?? this.headers,
        queryParameters: queryParameters ?? this.queryParameters);
  }

  HttpConfig copyWithWrapped(
      {Wrapped<String>? url,
      Wrapped<enums.HttpConfigProtocol>? protocol,
      Wrapped<List<HttpParam>?>? headers,
      Wrapped<List<HttpParam>?>? queryParameters}) {
    return HttpConfig(
        url: (url != null ? url.value : this.url),
        protocol: (protocol != null ? protocol.value : this.protocol),
        headers: (headers != null ? headers.value : this.headers),
        queryParameters: (queryParameters != null
            ? queryParameters.value
            : this.queryParameters));
  }
}

@JsonSerializable(explicitToJson: true)
class UdpConfig {
  const UdpConfig({
    required this.host,
    required this.port,
  });

  factory UdpConfig.fromJson(Map<String, dynamic> json) =>
      _$UdpConfigFromJson(json);

  static const toJsonFactory = _$UdpConfigToJson;
  Map<String, dynamic> toJson() => _$UdpConfigToJson(this);

  @JsonKey(name: 'host', includeIfNull: false, defaultValue: '')
  final String host;
  @JsonKey(name: 'port', includeIfNull: false)
  final int port;
  static const fromJsonFactory = _$UdpConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UdpConfig &&
            (identical(other.host, host) ||
                const DeepCollectionEquality().equals(other.host, host)) &&
            (identical(other.port, port) ||
                const DeepCollectionEquality().equals(other.port, port)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(host) ^
      const DeepCollectionEquality().hash(port) ^
      runtimeType.hashCode;
}

extension $UdpConfigExtension on UdpConfig {
  UdpConfig copyWith({String? host, int? port}) {
    return UdpConfig(host: host ?? this.host, port: port ?? this.port);
  }

  UdpConfig copyWithWrapped({Wrapped<String>? host, Wrapped<int>? port}) {
    return UdpConfig(
        host: (host != null ? host.value : this.host),
        port: (port != null ? port.value : this.port));
  }
}

@JsonSerializable(explicitToJson: true)
class MqttConfig {
  const MqttConfig({
    required this.host,
    required this.port,
    required this.topic,
    this.qos,
  });

  factory MqttConfig.fromJson(Map<String, dynamic> json) =>
      _$MqttConfigFromJson(json);

  static const toJsonFactory = _$MqttConfigToJson;
  Map<String, dynamic> toJson() => _$MqttConfigToJson(this);

  @JsonKey(name: 'host', includeIfNull: false, defaultValue: '')
  final String host;
  @JsonKey(name: 'port', includeIfNull: false)
  final int port;
  @JsonKey(name: 'topic', includeIfNull: false, defaultValue: '')
  final String topic;
  @JsonKey(name: 'qos', includeIfNull: false)
  final int? qos;
  static const fromJsonFactory = _$MqttConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MqttConfig &&
            (identical(other.host, host) ||
                const DeepCollectionEquality().equals(other.host, host)) &&
            (identical(other.port, port) ||
                const DeepCollectionEquality().equals(other.port, port)) &&
            (identical(other.topic, topic) ||
                const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.qos, qos) ||
                const DeepCollectionEquality().equals(other.qos, qos)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(host) ^
      const DeepCollectionEquality().hash(port) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(qos) ^
      runtimeType.hashCode;
}

extension $MqttConfigExtension on MqttConfig {
  MqttConfig copyWith({String? host, int? port, String? topic, int? qos}) {
    return MqttConfig(
        host: host ?? this.host,
        port: port ?? this.port,
        topic: topic ?? this.topic,
        qos: qos ?? this.qos);
  }

  MqttConfig copyWithWrapped(
      {Wrapped<String>? host,
      Wrapped<int>? port,
      Wrapped<String>? topic,
      Wrapped<int?>? qos}) {
    return MqttConfig(
        host: (host != null ? host.value : this.host),
        port: (port != null ? port.value : this.port),
        topic: (topic != null ? topic.value : this.topic),
        qos: (qos != null ? qos.value : this.qos));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerControl {
  const TriggerControl({
    required this.controlState,
    required this.triggerTarget,
    this.triggerType,
    this.deliveryTarget,
    this.controlId,
    this.otherDeviceId,
    this.otherControlId,
    this.httpConfig,
    this.mqttConfig,
    this.udpConfig,
  });

  factory TriggerControl.fromJson(Map<String, dynamic> json) =>
      _$TriggerControlFromJson(json);

  static const toJsonFactory = _$TriggerControlToJson;
  Map<String, dynamic> toJson() => _$TriggerControlToJson(this);

  @JsonKey(name: 'controlState', includeIfNull: false)
  final int controlState;
  @JsonKey(
    name: 'triggerTarget',
    includeIfNull: false,
    toJson: triggerControlTriggerTargetToJson,
    fromJson: triggerControlTriggerTargetTriggerTargetFromJson,
  )
  final enums.TriggerControlTriggerTarget triggerTarget;
  static enums.TriggerControlTriggerTarget
      triggerControlTriggerTargetTriggerTargetFromJson(Object? value) =>
          triggerControlTriggerTargetFromJson(
              value, enums.TriggerControlTriggerTarget.thisdevice);

  @JsonKey(
    name: 'triggerType',
    includeIfNull: false,
    toJson: triggerControlTriggerTypeNullableToJson,
    fromJson: triggerControlTriggerTypeTriggerTypeNullableFromJson,
  )
  final enums.TriggerControlTriggerType? triggerType;
  static enums.TriggerControlTriggerType?
      triggerControlTriggerTypeTriggerTypeNullableFromJson(Object? value) =>
          triggerControlTriggerTypeNullableFromJson(
              value, enums.TriggerControlTriggerType.fire);

  @JsonKey(
    name: 'deliveryTarget',
    includeIfNull: false,
    toJson: triggerControlDeliveryTargetNullableToJson,
    fromJson: triggerControlDeliveryTargetDeliveryTargetNullableFromJson,
  )
  final enums.TriggerControlDeliveryTarget? deliveryTarget;
  static enums.TriggerControlDeliveryTarget?
      triggerControlDeliveryTargetDeliveryTargetNullableFromJson(
              Object? value) =>
          triggerControlDeliveryTargetNullableFromJson(
              value, enums.TriggerControlDeliveryTarget.builtin);

  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String? controlId;
  @JsonKey(name: 'otherDeviceId', includeIfNull: false, defaultValue: '')
  final String? otherDeviceId;
  @JsonKey(name: 'otherControlId', includeIfNull: false, defaultValue: '')
  final String? otherControlId;
  @JsonKey(name: 'httpConfig', includeIfNull: false)
  final HttpConfig? httpConfig;
  @JsonKey(name: 'mqttConfig', includeIfNull: false)
  final MqttConfig? mqttConfig;
  @JsonKey(name: 'udpConfig', includeIfNull: false)
  final UdpConfig? udpConfig;
  static const fromJsonFactory = _$TriggerControlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerControl &&
            (identical(other.controlState, controlState) ||
                const DeepCollectionEquality()
                    .equals(other.controlState, controlState)) &&
            (identical(other.triggerTarget, triggerTarget) ||
                const DeepCollectionEquality()
                    .equals(other.triggerTarget, triggerTarget)) &&
            (identical(other.triggerType, triggerType) ||
                const DeepCollectionEquality()
                    .equals(other.triggerType, triggerType)) &&
            (identical(other.deliveryTarget, deliveryTarget) ||
                const DeepCollectionEquality()
                    .equals(other.deliveryTarget, deliveryTarget)) &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality()
                    .equals(other.controlId, controlId)) &&
            (identical(other.otherDeviceId, otherDeviceId) ||
                const DeepCollectionEquality()
                    .equals(other.otherDeviceId, otherDeviceId)) &&
            (identical(other.otherControlId, otherControlId) ||
                const DeepCollectionEquality()
                    .equals(other.otherControlId, otherControlId)) &&
            (identical(other.httpConfig, httpConfig) ||
                const DeepCollectionEquality()
                    .equals(other.httpConfig, httpConfig)) &&
            (identical(other.mqttConfig, mqttConfig) ||
                const DeepCollectionEquality()
                    .equals(other.mqttConfig, mqttConfig)) &&
            (identical(other.udpConfig, udpConfig) ||
                const DeepCollectionEquality()
                    .equals(other.udpConfig, udpConfig)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(controlState) ^
      const DeepCollectionEquality().hash(triggerTarget) ^
      const DeepCollectionEquality().hash(triggerType) ^
      const DeepCollectionEquality().hash(deliveryTarget) ^
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(otherDeviceId) ^
      const DeepCollectionEquality().hash(otherControlId) ^
      const DeepCollectionEquality().hash(httpConfig) ^
      const DeepCollectionEquality().hash(mqttConfig) ^
      const DeepCollectionEquality().hash(udpConfig) ^
      runtimeType.hashCode;
}

extension $TriggerControlExtension on TriggerControl {
  TriggerControl copyWith(
      {int? controlState,
      enums.TriggerControlTriggerTarget? triggerTarget,
      enums.TriggerControlTriggerType? triggerType,
      enums.TriggerControlDeliveryTarget? deliveryTarget,
      String? controlId,
      String? otherDeviceId,
      String? otherControlId,
      HttpConfig? httpConfig,
      MqttConfig? mqttConfig,
      UdpConfig? udpConfig}) {
    return TriggerControl(
        controlState: controlState ?? this.controlState,
        triggerTarget: triggerTarget ?? this.triggerTarget,
        triggerType: triggerType ?? this.triggerType,
        deliveryTarget: deliveryTarget ?? this.deliveryTarget,
        controlId: controlId ?? this.controlId,
        otherDeviceId: otherDeviceId ?? this.otherDeviceId,
        otherControlId: otherControlId ?? this.otherControlId,
        httpConfig: httpConfig ?? this.httpConfig,
        mqttConfig: mqttConfig ?? this.mqttConfig,
        udpConfig: udpConfig ?? this.udpConfig);
  }

  TriggerControl copyWithWrapped(
      {Wrapped<int>? controlState,
      Wrapped<enums.TriggerControlTriggerTarget>? triggerTarget,
      Wrapped<enums.TriggerControlTriggerType?>? triggerType,
      Wrapped<enums.TriggerControlDeliveryTarget?>? deliveryTarget,
      Wrapped<String?>? controlId,
      Wrapped<String?>? otherDeviceId,
      Wrapped<String?>? otherControlId,
      Wrapped<HttpConfig?>? httpConfig,
      Wrapped<MqttConfig?>? mqttConfig,
      Wrapped<UdpConfig?>? udpConfig}) {
    return TriggerControl(
        controlState:
            (controlState != null ? controlState.value : this.controlState),
        triggerTarget:
            (triggerTarget != null ? triggerTarget.value : this.triggerTarget),
        triggerType:
            (triggerType != null ? triggerType.value : this.triggerType),
        deliveryTarget: (deliveryTarget != null
            ? deliveryTarget.value
            : this.deliveryTarget),
        controlId: (controlId != null ? controlId.value : this.controlId),
        otherDeviceId:
            (otherDeviceId != null ? otherDeviceId.value : this.otherDeviceId),
        otherControlId: (otherControlId != null
            ? otherControlId.value
            : this.otherControlId),
        httpConfig: (httpConfig != null ? httpConfig.value : this.httpConfig),
        mqttConfig: (mqttConfig != null ? mqttConfig.value : this.mqttConfig),
        udpConfig: (udpConfig != null ? udpConfig.value : this.udpConfig));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerInfo {
  const TriggerInfo({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.conditions,
    required this.controls,
    this.tags,
  });

  factory TriggerInfo.fromJson(Map<String, dynamic> json) =>
      _$TriggerInfoFromJson(json);

  static const toJsonFactory = _$TriggerInfoToJson;
  Map<String, dynamic> toJson() => _$TriggerInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
      name: 'conditions', includeIfNull: false, defaultValue: <MatchGroup>[])
  final List<MatchGroup> conditions;
  @JsonKey(
      name: 'controls', includeIfNull: false, defaultValue: <TriggerControl>[])
  final List<TriggerControl> controls;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$TriggerInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.controls, controls) ||
                const DeepCollectionEquality()
                    .equals(other.controls, controls)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(controls) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $TriggerInfoExtension on TriggerInfo {
  TriggerInfo copyWith(
      {String? name,
      String? description,
      String? modelId,
      String? icon,
      List<MatchGroup>? conditions,
      List<TriggerControl>? controls,
      List<String>? tags}) {
    return TriggerInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        icon: icon ?? this.icon,
        conditions: conditions ?? this.conditions,
        controls: controls ?? this.controls,
        tags: tags ?? this.tags);
  }

  TriggerInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<String?>? icon,
      Wrapped<List<MatchGroup>>? conditions,
      Wrapped<List<TriggerControl>>? controls,
      Wrapped<List<String>?>? tags}) {
    return TriggerInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        icon: (icon != null ? icon.value : this.icon),
        conditions: (conditions != null ? conditions.value : this.conditions),
        controls: (controls != null ? controls.value : this.controls),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class Trigger {
  const Trigger({
    required this.name,
    this.description,
    required this.modelId,
    this.icon,
    required this.conditions,
    required this.controls,
    this.tags,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Trigger.fromJson(Map<String, dynamic> json) =>
      _$TriggerFromJson(json);

  static const toJsonFactory = _$TriggerToJson;
  Map<String, dynamic> toJson() => _$TriggerToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
      name: 'conditions', includeIfNull: false, defaultValue: <MatchGroup>[])
  final List<MatchGroup> conditions;
  @JsonKey(
      name: 'controls', includeIfNull: false, defaultValue: <TriggerControl>[])
  final List<TriggerControl> controls;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$TriggerFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Trigger &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.controls, controls) ||
                const DeepCollectionEquality()
                    .equals(other.controls, controls)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(controls) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $TriggerExtension on Trigger {
  Trigger copyWith(
      {String? name,
      String? description,
      String? modelId,
      String? icon,
      List<MatchGroup>? conditions,
      List<TriggerControl>? controls,
      List<String>? tags,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Trigger(
        name: name ?? this.name,
        description: description ?? this.description,
        modelId: modelId ?? this.modelId,
        icon: icon ?? this.icon,
        conditions: conditions ?? this.conditions,
        controls: controls ?? this.controls,
        tags: tags ?? this.tags,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Trigger copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String>? modelId,
      Wrapped<String?>? icon,
      Wrapped<List<MatchGroup>>? conditions,
      Wrapped<List<TriggerControl>>? controls,
      Wrapped<List<String>?>? tags,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Trigger(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        modelId: (modelId != null ? modelId.value : this.modelId),
        icon: (icon != null ? icon.value : this.icon),
        conditions: (conditions != null ? conditions.value : this.conditions),
        controls: (controls != null ? controls.value : this.controls),
        tags: (tags != null ? tags.value : this.tags),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerEntity {
  const TriggerEntity({
    this.entity,
  });

  factory TriggerEntity.fromJson(Map<String, dynamic> json) =>
      _$TriggerEntityFromJson(json);

  static const toJsonFactory = _$TriggerEntityToJson;
  Map<String, dynamic> toJson() => _$TriggerEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Trigger? entity;
  static const fromJsonFactory = _$TriggerEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $TriggerEntityExtension on TriggerEntity {
  TriggerEntity copyWith({Trigger? entity}) {
    return TriggerEntity(entity: entity ?? this.entity);
  }

  TriggerEntity copyWithWrapped({Wrapped<Trigger?>? entity}) {
    return TriggerEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerEntityRes {
  const TriggerEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory TriggerEntityRes.fromJson(Map<String, dynamic> json) =>
      _$TriggerEntityResFromJson(json);

  static const toJsonFactory = _$TriggerEntityResToJson;
  Map<String, dynamic> toJson() => _$TriggerEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Trigger? entity;
  static const fromJsonFactory = _$TriggerEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $TriggerEntityResExtension on TriggerEntityRes {
  TriggerEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Trigger? entity}) {
    return TriggerEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  TriggerEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Trigger?>? entity}) {
    return TriggerEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerArray {
  const TriggerArray({
    this.values,
  });

  factory TriggerArray.fromJson(Map<String, dynamic> json) =>
      _$TriggerArrayFromJson(json);

  static const toJsonFactory = _$TriggerArrayToJson;
  Map<String, dynamic> toJson() => _$TriggerArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Trigger>[])
  final List<Trigger>? values;
  static const fromJsonFactory = _$TriggerArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TriggerArrayExtension on TriggerArray {
  TriggerArray copyWith({List<Trigger>? values}) {
    return TriggerArray(values: values ?? this.values);
  }

  TriggerArray copyWithWrapped({Wrapped<List<Trigger>?>? values}) {
    return TriggerArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggerArrayRes {
  const TriggerArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TriggerArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TriggerArrayResFromJson(json);

  static const toJsonFactory = _$TriggerArrayResToJson;
  Map<String, dynamic> toJson() => _$TriggerArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Trigger>[])
  final List<Trigger>? values;
  static const fromJsonFactory = _$TriggerArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggerArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TriggerArrayResExtension on TriggerArrayRes {
  TriggerArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Trigger>? values}) {
    return TriggerArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  TriggerArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Trigger>?>? values}) {
    return TriggerArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class NotificationTemplate {
  const NotificationTemplate({
    required this.title,
    required this.content,
  });

  factory NotificationTemplate.fromJson(Map<String, dynamic> json) =>
      _$NotificationTemplateFromJson(json);

  static const toJsonFactory = _$NotificationTemplateToJson;
  Map<String, dynamic> toJson() => _$NotificationTemplateToJson(this);

  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String title;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: '')
  final String content;
  static const fromJsonFactory = _$NotificationTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NotificationTemplate &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $NotificationTemplateExtension on NotificationTemplate {
  NotificationTemplate copyWith({String? title, String? content}) {
    return NotificationTemplate(
        title: title ?? this.title, content: content ?? this.content);
  }

  NotificationTemplate copyWithWrapped(
      {Wrapped<String>? title, Wrapped<String>? content}) {
    return NotificationTemplate(
        title: (title != null ? title.value : this.title),
        content: (content != null ? content.value : this.content));
  }
}

@JsonSerializable(explicitToJson: true)
class EmailTemplate {
  const EmailTemplate({
    required this.subject,
    required this.content,
  });

  factory EmailTemplate.fromJson(Map<String, dynamic> json) =>
      _$EmailTemplateFromJson(json);

  static const toJsonFactory = _$EmailTemplateToJson;
  Map<String, dynamic> toJson() => _$EmailTemplateToJson(this);

  @JsonKey(name: 'subject', includeIfNull: false, defaultValue: '')
  final String subject;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: '')
  final String content;
  static const fromJsonFactory = _$EmailTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EmailTemplate &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $EmailTemplateExtension on EmailTemplate {
  EmailTemplate copyWith({String? subject, String? content}) {
    return EmailTemplate(
        subject: subject ?? this.subject, content: content ?? this.content);
  }

  EmailTemplate copyWithWrapped(
      {Wrapped<String>? subject, Wrapped<String>? content}) {
    return EmailTemplate(
        subject: (subject != null ? subject.value : this.subject),
        content: (content != null ? content.value : this.content));
  }
}

@JsonSerializable(explicitToJson: true)
class FCMTemplate {
  const FCMTemplate({
    required this.title,
    required this.content,
  });

  factory FCMTemplate.fromJson(Map<String, dynamic> json) =>
      _$FCMTemplateFromJson(json);

  static const toJsonFactory = _$FCMTemplateToJson;
  Map<String, dynamic> toJson() => _$FCMTemplateToJson(this);

  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String title;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: '')
  final String content;
  static const fromJsonFactory = _$FCMTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FCMTemplate &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $FCMTemplateExtension on FCMTemplate {
  FCMTemplate copyWith({String? title, String? content}) {
    return FCMTemplate(
        title: title ?? this.title, content: content ?? this.content);
  }

  FCMTemplate copyWithWrapped(
      {Wrapped<String>? title, Wrapped<String>? content}) {
    return FCMTemplate(
        title: (title != null ? title.value : this.title),
        content: (content != null ? content.value : this.content));
  }
}

@JsonSerializable(explicitToJson: true)
class SMSTemplate {
  const SMSTemplate({
    required this.message,
  });

  factory SMSTemplate.fromJson(Map<String, dynamic> json) =>
      _$SMSTemplateFromJson(json);

  static const toJsonFactory = _$SMSTemplateToJson;
  Map<String, dynamic> toJson() => _$SMSTemplateToJson(this);

  @JsonKey(name: 'message', includeIfNull: false, defaultValue: '')
  final String message;
  static const fromJsonFactory = _$SMSTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SMSTemplate &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(message) ^ runtimeType.hashCode;
}

extension $SMSTemplateExtension on SMSTemplate {
  SMSTemplate copyWith({String? message}) {
    return SMSTemplate(message: message ?? this.message);
  }

  SMSTemplate copyWithWrapped({Wrapped<String>? message}) {
    return SMSTemplate(
        message: (message != null ? message.value : this.message));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceTemplate {
  const VoiceTemplate({
    required this.message,
  });

  factory VoiceTemplate.fromJson(Map<String, dynamic> json) =>
      _$VoiceTemplateFromJson(json);

  static const toJsonFactory = _$VoiceTemplateToJson;
  Map<String, dynamic> toJson() => _$VoiceTemplateToJson(this);

  @JsonKey(name: 'message', includeIfNull: false, defaultValue: '')
  final String message;
  static const fromJsonFactory = _$VoiceTemplateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceTemplate &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(message) ^ runtimeType.hashCode;
}

extension $VoiceTemplateExtension on VoiceTemplate {
  VoiceTemplate copyWith({String? message}) {
    return VoiceTemplate(message: message ?? this.message);
  }

  VoiceTemplate copyWithWrapped({Wrapped<String>? message}) {
    return VoiceTemplate(
        message: (message != null ? message.value : this.message));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageFileInfo {
  const ImageFileInfo({
    required this.imageType,
    required this.imageTarget,
    required this.name,
    required this.modelId,
    this.deviceId,
    this.conditionId,
    this.alarmId,
    this.controlId,
    this.eventId,
    this.triggerId,
    this.menuGroupId,
    this.menuIndex,
    this.screenId,
    this.displayId,
    this.assetId,
    this.facilityId,
    this.floorId,
    this.userId,
    this.premiseId,
  });

  factory ImageFileInfo.fromJson(Map<String, dynamic> json) =>
      _$ImageFileInfoFromJson(json);

  static const toJsonFactory = _$ImageFileInfoToJson;
  Map<String, dynamic> toJson() => _$ImageFileInfoToJson(this);

  @JsonKey(
    name: 'imageType',
    includeIfNull: false,
    toJson: imageFileInfoImageTypeToJson,
    fromJson: imageFileInfoImageTypeFromJson,
  )
  final enums.ImageFileInfoImageType imageType;
  @JsonKey(
    name: 'imageTarget',
    includeIfNull: false,
    toJson: imageFileInfoImageTargetToJson,
    fromJson: imageFileInfoImageTargetFromJson,
  )
  final enums.ImageFileInfoImageTarget imageTarget;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'conditionId', includeIfNull: false, defaultValue: '')
  final String? conditionId;
  @JsonKey(name: 'alarmId', includeIfNull: false, defaultValue: '')
  final String? alarmId;
  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String? controlId;
  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String? eventId;
  @JsonKey(name: 'triggerId', includeIfNull: false, defaultValue: '')
  final String? triggerId;
  @JsonKey(name: 'menuGroupId', includeIfNull: false, defaultValue: '')
  final String? menuGroupId;
  @JsonKey(name: 'menuIndex', includeIfNull: false)
  final int? menuIndex;
  @JsonKey(name: 'screenId', includeIfNull: false, defaultValue: '')
  final String? screenId;
  @JsonKey(name: 'displayId', includeIfNull: false, defaultValue: '')
  final String? displayId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String? userId;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  static const fromJsonFactory = _$ImageFileInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageFileInfo &&
            (identical(other.imageType, imageType) ||
                const DeepCollectionEquality()
                    .equals(other.imageType, imageType)) &&
            (identical(other.imageTarget, imageTarget) ||
                const DeepCollectionEquality()
                    .equals(other.imageTarget, imageTarget)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.conditionId, conditionId) ||
                const DeepCollectionEquality()
                    .equals(other.conditionId, conditionId)) &&
            (identical(other.alarmId, alarmId) ||
                const DeepCollectionEquality()
                    .equals(other.alarmId, alarmId)) &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality()
                    .equals(other.controlId, controlId)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.triggerId, triggerId) ||
                const DeepCollectionEquality()
                    .equals(other.triggerId, triggerId)) &&
            (identical(other.menuGroupId, menuGroupId) ||
                const DeepCollectionEquality()
                    .equals(other.menuGroupId, menuGroupId)) &&
            (identical(other.menuIndex, menuIndex) ||
                const DeepCollectionEquality()
                    .equals(other.menuIndex, menuIndex)) &&
            (identical(other.screenId, screenId) ||
                const DeepCollectionEquality()
                    .equals(other.screenId, screenId)) &&
            (identical(other.displayId, displayId) ||
                const DeepCollectionEquality()
                    .equals(other.displayId, displayId)) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality()
                    .equals(other.assetId, assetId)) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality()
                    .equals(other.facilityId, facilityId)) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality()
                    .equals(other.floorId, floorId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(imageType) ^
      const DeepCollectionEquality().hash(imageTarget) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(conditionId) ^
      const DeepCollectionEquality().hash(alarmId) ^
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(triggerId) ^
      const DeepCollectionEquality().hash(menuGroupId) ^
      const DeepCollectionEquality().hash(menuIndex) ^
      const DeepCollectionEquality().hash(screenId) ^
      const DeepCollectionEquality().hash(displayId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(premiseId) ^
      runtimeType.hashCode;
}

extension $ImageFileInfoExtension on ImageFileInfo {
  ImageFileInfo copyWith(
      {enums.ImageFileInfoImageType? imageType,
      enums.ImageFileInfoImageTarget? imageTarget,
      String? name,
      String? modelId,
      String? deviceId,
      String? conditionId,
      String? alarmId,
      String? controlId,
      String? eventId,
      String? triggerId,
      String? menuGroupId,
      int? menuIndex,
      String? screenId,
      String? displayId,
      String? assetId,
      String? facilityId,
      String? floorId,
      String? userId,
      String? premiseId}) {
    return ImageFileInfo(
        imageType: imageType ?? this.imageType,
        imageTarget: imageTarget ?? this.imageTarget,
        name: name ?? this.name,
        modelId: modelId ?? this.modelId,
        deviceId: deviceId ?? this.deviceId,
        conditionId: conditionId ?? this.conditionId,
        alarmId: alarmId ?? this.alarmId,
        controlId: controlId ?? this.controlId,
        eventId: eventId ?? this.eventId,
        triggerId: triggerId ?? this.triggerId,
        menuGroupId: menuGroupId ?? this.menuGroupId,
        menuIndex: menuIndex ?? this.menuIndex,
        screenId: screenId ?? this.screenId,
        displayId: displayId ?? this.displayId,
        assetId: assetId ?? this.assetId,
        facilityId: facilityId ?? this.facilityId,
        floorId: floorId ?? this.floorId,
        userId: userId ?? this.userId,
        premiseId: premiseId ?? this.premiseId);
  }

  ImageFileInfo copyWithWrapped(
      {Wrapped<enums.ImageFileInfoImageType>? imageType,
      Wrapped<enums.ImageFileInfoImageTarget>? imageTarget,
      Wrapped<String>? name,
      Wrapped<String>? modelId,
      Wrapped<String?>? deviceId,
      Wrapped<String?>? conditionId,
      Wrapped<String?>? alarmId,
      Wrapped<String?>? controlId,
      Wrapped<String?>? eventId,
      Wrapped<String?>? triggerId,
      Wrapped<String?>? menuGroupId,
      Wrapped<int?>? menuIndex,
      Wrapped<String?>? screenId,
      Wrapped<String?>? displayId,
      Wrapped<String?>? assetId,
      Wrapped<String?>? facilityId,
      Wrapped<String?>? floorId,
      Wrapped<String?>? userId,
      Wrapped<String?>? premiseId}) {
    return ImageFileInfo(
        imageType: (imageType != null ? imageType.value : this.imageType),
        imageTarget:
            (imageTarget != null ? imageTarget.value : this.imageTarget),
        name: (name != null ? name.value : this.name),
        modelId: (modelId != null ? modelId.value : this.modelId),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        conditionId:
            (conditionId != null ? conditionId.value : this.conditionId),
        alarmId: (alarmId != null ? alarmId.value : this.alarmId),
        controlId: (controlId != null ? controlId.value : this.controlId),
        eventId: (eventId != null ? eventId.value : this.eventId),
        triggerId: (triggerId != null ? triggerId.value : this.triggerId),
        menuGroupId:
            (menuGroupId != null ? menuGroupId.value : this.menuGroupId),
        menuIndex: (menuIndex != null ? menuIndex.value : this.menuIndex),
        screenId: (screenId != null ? screenId.value : this.screenId),
        displayId: (displayId != null ? displayId.value : this.displayId),
        assetId: (assetId != null ? assetId.value : this.assetId),
        facilityId: (facilityId != null ? facilityId.value : this.facilityId),
        floorId: (floorId != null ? floorId.value : this.floorId),
        userId: (userId != null ? userId.value : this.userId),
        premiseId: (premiseId != null ? premiseId.value : this.premiseId));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageFileBase {
  const ImageFileBase({
    required this.contentType,
  });

  factory ImageFileBase.fromJson(Map<String, dynamic> json) =>
      _$ImageFileBaseFromJson(json);

  static const toJsonFactory = _$ImageFileBaseToJson;
  Map<String, dynamic> toJson() => _$ImageFileBaseToJson(this);

  @JsonKey(name: 'contentType', includeIfNull: false, defaultValue: '')
  final String contentType;
  static const fromJsonFactory = _$ImageFileBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageFileBase &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(contentType) ^ runtimeType.hashCode;
}

extension $ImageFileBaseExtension on ImageFileBase {
  ImageFileBase copyWith({String? contentType}) {
    return ImageFileBase(contentType: contentType ?? this.contentType);
  }

  ImageFileBase copyWithWrapped({Wrapped<String>? contentType}) {
    return ImageFileBase(
        contentType:
            (contentType != null ? contentType.value : this.contentType));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageFile {
  const ImageFile({
    required this.imageType,
    required this.imageTarget,
    required this.name,
    required this.modelId,
    this.deviceId,
    this.conditionId,
    this.alarmId,
    this.controlId,
    this.eventId,
    this.triggerId,
    this.menuGroupId,
    this.menuIndex,
    this.screenId,
    this.displayId,
    this.assetId,
    this.facilityId,
    this.floorId,
    this.userId,
    this.premiseId,
    required this.contentType,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
    this.tags,
  });

  factory ImageFile.fromJson(Map<String, dynamic> json) =>
      _$ImageFileFromJson(json);

  static const toJsonFactory = _$ImageFileToJson;
  Map<String, dynamic> toJson() => _$ImageFileToJson(this);

  @JsonKey(
    name: 'imageType',
    includeIfNull: false,
    toJson: imageFileImageTypeToJson,
    fromJson: imageFileImageTypeFromJson,
  )
  final enums.ImageFileImageType imageType;
  @JsonKey(
    name: 'imageTarget',
    includeIfNull: false,
    toJson: imageFileImageTargetToJson,
    fromJson: imageFileImageTargetFromJson,
  )
  final enums.ImageFileImageTarget imageTarget;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'conditionId', includeIfNull: false, defaultValue: '')
  final String? conditionId;
  @JsonKey(name: 'alarmId', includeIfNull: false, defaultValue: '')
  final String? alarmId;
  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String? controlId;
  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String? eventId;
  @JsonKey(name: 'triggerId', includeIfNull: false, defaultValue: '')
  final String? triggerId;
  @JsonKey(name: 'menuGroupId', includeIfNull: false, defaultValue: '')
  final String? menuGroupId;
  @JsonKey(name: 'menuIndex', includeIfNull: false)
  final int? menuIndex;
  @JsonKey(name: 'screenId', includeIfNull: false, defaultValue: '')
  final String? screenId;
  @JsonKey(name: 'displayId', includeIfNull: false, defaultValue: '')
  final String? displayId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String? userId;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'contentType', includeIfNull: false, defaultValue: '')
  final String contentType;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$ImageFileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageFile &&
            (identical(other.imageType, imageType) ||
                const DeepCollectionEquality()
                    .equals(other.imageType, imageType)) &&
            (identical(other.imageTarget, imageTarget) ||
                const DeepCollectionEquality()
                    .equals(other.imageTarget, imageTarget)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.conditionId, conditionId) ||
                const DeepCollectionEquality()
                    .equals(other.conditionId, conditionId)) &&
            (identical(other.alarmId, alarmId) ||
                const DeepCollectionEquality()
                    .equals(other.alarmId, alarmId)) &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality()
                    .equals(other.controlId, controlId)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.triggerId, triggerId) ||
                const DeepCollectionEquality()
                    .equals(other.triggerId, triggerId)) &&
            (identical(other.menuGroupId, menuGroupId) ||
                const DeepCollectionEquality()
                    .equals(other.menuGroupId, menuGroupId)) &&
            (identical(other.menuIndex, menuIndex) ||
                const DeepCollectionEquality()
                    .equals(other.menuIndex, menuIndex)) &&
            (identical(other.screenId, screenId) ||
                const DeepCollectionEquality()
                    .equals(other.screenId, screenId)) &&
            (identical(other.displayId, displayId) ||
                const DeepCollectionEquality()
                    .equals(other.displayId, displayId)) &&
            (identical(other.assetId, assetId) ||
                const DeepCollectionEquality()
                    .equals(other.assetId, assetId)) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality()
                    .equals(other.facilityId, facilityId)) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality()
                    .equals(other.floorId, floorId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality().equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) || const DeepCollectionEquality().equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) || const DeepCollectionEquality().equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) || const DeepCollectionEquality().equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.tags, tags) || const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(imageType) ^
      const DeepCollectionEquality().hash(imageTarget) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(conditionId) ^
      const DeepCollectionEquality().hash(alarmId) ^
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(triggerId) ^
      const DeepCollectionEquality().hash(menuGroupId) ^
      const DeepCollectionEquality().hash(menuIndex) ^
      const DeepCollectionEquality().hash(screenId) ^
      const DeepCollectionEquality().hash(displayId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $ImageFileExtension on ImageFile {
  ImageFile copyWith(
      {enums.ImageFileImageType? imageType,
      enums.ImageFileImageTarget? imageTarget,
      String? name,
      String? modelId,
      String? deviceId,
      String? conditionId,
      String? alarmId,
      String? controlId,
      String? eventId,
      String? triggerId,
      String? menuGroupId,
      int? menuIndex,
      String? screenId,
      String? displayId,
      String? assetId,
      String? facilityId,
      String? floorId,
      String? userId,
      String? premiseId,
      String? contentType,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      List<String>? tags}) {
    return ImageFile(
        imageType: imageType ?? this.imageType,
        imageTarget: imageTarget ?? this.imageTarget,
        name: name ?? this.name,
        modelId: modelId ?? this.modelId,
        deviceId: deviceId ?? this.deviceId,
        conditionId: conditionId ?? this.conditionId,
        alarmId: alarmId ?? this.alarmId,
        controlId: controlId ?? this.controlId,
        eventId: eventId ?? this.eventId,
        triggerId: triggerId ?? this.triggerId,
        menuGroupId: menuGroupId ?? this.menuGroupId,
        menuIndex: menuIndex ?? this.menuIndex,
        screenId: screenId ?? this.screenId,
        displayId: displayId ?? this.displayId,
        assetId: assetId ?? this.assetId,
        facilityId: facilityId ?? this.facilityId,
        floorId: floorId ?? this.floorId,
        userId: userId ?? this.userId,
        premiseId: premiseId ?? this.premiseId,
        contentType: contentType ?? this.contentType,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        tags: tags ?? this.tags);
  }

  ImageFile copyWithWrapped(
      {Wrapped<enums.ImageFileImageType>? imageType,
      Wrapped<enums.ImageFileImageTarget>? imageTarget,
      Wrapped<String>? name,
      Wrapped<String>? modelId,
      Wrapped<String?>? deviceId,
      Wrapped<String?>? conditionId,
      Wrapped<String?>? alarmId,
      Wrapped<String?>? controlId,
      Wrapped<String?>? eventId,
      Wrapped<String?>? triggerId,
      Wrapped<String?>? menuGroupId,
      Wrapped<int?>? menuIndex,
      Wrapped<String?>? screenId,
      Wrapped<String?>? displayId,
      Wrapped<String?>? assetId,
      Wrapped<String?>? facilityId,
      Wrapped<String?>? floorId,
      Wrapped<String?>? userId,
      Wrapped<String?>? premiseId,
      Wrapped<String>? contentType,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp,
      Wrapped<List<String>?>? tags}) {
    return ImageFile(
        imageType: (imageType != null ? imageType.value : this.imageType),
        imageTarget:
            (imageTarget != null ? imageTarget.value : this.imageTarget),
        name: (name != null ? name.value : this.name),
        modelId: (modelId != null ? modelId.value : this.modelId),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        conditionId:
            (conditionId != null ? conditionId.value : this.conditionId),
        alarmId: (alarmId != null ? alarmId.value : this.alarmId),
        controlId: (controlId != null ? controlId.value : this.controlId),
        eventId: (eventId != null ? eventId.value : this.eventId),
        triggerId: (triggerId != null ? triggerId.value : this.triggerId),
        menuGroupId:
            (menuGroupId != null ? menuGroupId.value : this.menuGroupId),
        menuIndex: (menuIndex != null ? menuIndex.value : this.menuIndex),
        screenId: (screenId != null ? screenId.value : this.screenId),
        displayId: (displayId != null ? displayId.value : this.displayId),
        assetId: (assetId != null ? assetId.value : this.assetId),
        facilityId: (facilityId != null ? facilityId.value : this.facilityId),
        floorId: (floorId != null ? floorId.value : this.floorId),
        userId: (userId != null ? userId.value : this.userId),
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageFileEntity {
  const ImageFileEntity({
    this.entity,
  });

  factory ImageFileEntity.fromJson(Map<String, dynamic> json) =>
      _$ImageFileEntityFromJson(json);

  static const toJsonFactory = _$ImageFileEntityToJson;
  Map<String, dynamic> toJson() => _$ImageFileEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ImageFile? entity;
  static const fromJsonFactory = _$ImageFileEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageFileEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ImageFileEntityExtension on ImageFileEntity {
  ImageFileEntity copyWith({ImageFile? entity}) {
    return ImageFileEntity(entity: entity ?? this.entity);
  }

  ImageFileEntity copyWithWrapped({Wrapped<ImageFile?>? entity}) {
    return ImageFileEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageFileEntityRes {
  const ImageFileEntityRes({
    this.entity,
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory ImageFileEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ImageFileEntityResFromJson(json);

  static const toJsonFactory = _$ImageFileEntityResToJson;
  Map<String, dynamic> toJson() => _$ImageFileEntityResToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ImageFile? entity;
  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$ImageFileEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageFileEntityRes &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)) &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $ImageFileEntityResExtension on ImageFileEntityRes {
  ImageFileEntityRes copyWith(
      {ImageFile? entity,
      bool? ok,
      String? msg,
      String? trace,
      String? errorCode}) {
    return ImageFileEntityRes(
        entity: entity ?? this.entity,
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode);
  }

  ImageFileEntityRes copyWithWrapped(
      {Wrapped<ImageFile?>? entity,
      Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode}) {
    return ImageFileEntityRes(
        entity: (entity != null ? entity.value : this.entity),
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageFileArray {
  const ImageFileArray({
    this.values,
  });

  factory ImageFileArray.fromJson(Map<String, dynamic> json) =>
      _$ImageFileArrayFromJson(json);

  static const toJsonFactory = _$ImageFileArrayToJson;
  Map<String, dynamic> toJson() => _$ImageFileArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <ImageFile>[])
  final List<ImageFile>? values;
  static const fromJsonFactory = _$ImageFileArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageFileArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ImageFileArrayExtension on ImageFileArray {
  ImageFileArray copyWith({List<ImageFile>? values}) {
    return ImageFileArray(values: values ?? this.values);
  }

  ImageFileArray copyWithWrapped({Wrapped<List<ImageFile>?>? values}) {
    return ImageFileArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageFileArrayRes {
  const ImageFileArrayRes({
    this.values,
    required this.page,
    required this.size,
    required this.total,
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory ImageFileArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ImageFileArrayResFromJson(json);

  static const toJsonFactory = _$ImageFileArrayResToJson;
  Map<String, dynamic> toJson() => _$ImageFileArrayResToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <ImageFile>[])
  final List<ImageFile>? values;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$ImageFileArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageFileArrayRes &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $ImageFileArrayResExtension on ImageFileArrayRes {
  ImageFileArrayRes copyWith(
      {List<ImageFile>? values,
      int? page,
      int? size,
      int? total,
      bool? ok,
      String? msg,
      String? trace,
      String? errorCode}) {
    return ImageFileArrayRes(
        values: values ?? this.values,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode);
  }

  ImageFileArrayRes copyWithWrapped(
      {Wrapped<List<ImageFile>?>? values,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode}) {
    return ImageFileArrayRes(
        values: (values != null ? values.value : this.values),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayMatchGroup {
  const DisplayMatchGroup({
    required this.matchType,
    required this.conditions,
    required this.font,
    required this.fontSize,
    required this.fontColor,
    this.fontStyle,
    this.fontWeight,
    this.bordorColor,
    this.borderType,
    this.$value,
    this.bgColor,
    this.prefixText,
    this.prefixFont,
    this.prefixFontSize,
    this.prefixFontColor,
    this.prefixFontStyle,
    this.prefixFontWeight,
    this.prefixPadding,
    this.suffixText,
    this.suffixFont,
    this.suffixFontSize,
    this.suffixFontColor,
    this.suffixFontStyle,
    this.suffixFontWeight,
    this.suffixPadding,
    this.topText,
    this.topFont,
    this.topFontSize,
    this.topFontColor,
    this.topFontStyle,
    this.topFontWeight,
    this.topPadding,
    this.bottomText,
    this.bottomFont,
    this.bottomFontSize,
    this.bottomFontColor,
    this.bottomFontStyle,
    this.bottomFontWeight,
    this.bottomPadding,
    required this.width,
    required this.height,
    this.field,
    this.tooltip,
  });

  factory DisplayMatchGroup.fromJson(Map<String, dynamic> json) =>
      _$DisplayMatchGroupFromJson(json);

  static const toJsonFactory = _$DisplayMatchGroupToJson;
  Map<String, dynamic> toJson() => _$DisplayMatchGroupToJson(this);

  @JsonKey(
    name: 'matchType',
    includeIfNull: false,
    toJson: displayMatchGroupMatchTypeToJson,
    fromJson: displayMatchGroupMatchTypeFromJson,
  )
  final enums.DisplayMatchGroupMatchType matchType;
  @JsonKey(name: 'conditions', includeIfNull: false, defaultValue: <String>[])
  final List<String> conditions;
  @JsonKey(name: 'font', includeIfNull: false, defaultValue: '')
  final String font;
  @JsonKey(name: 'fontSize', includeIfNull: false)
  final double fontSize;
  @JsonKey(name: 'fontColor', includeIfNull: false)
  final int fontColor;
  @JsonKey(name: 'fontStyle', includeIfNull: false, defaultValue: '')
  final String? fontStyle;
  @JsonKey(name: 'fontWeight', includeIfNull: false)
  final int? fontWeight;
  @JsonKey(name: 'bordorColor', includeIfNull: false)
  final int? bordorColor;
  @JsonKey(
    name: 'borderType',
    includeIfNull: false,
    toJson: displayMatchGroupBorderTypeNullableToJson,
    fromJson: displayMatchGroupBorderTypeNullableFromJson,
  )
  final enums.DisplayMatchGroupBorderType? borderType;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'prefixText', includeIfNull: false, defaultValue: '')
  final String? prefixText;
  @JsonKey(name: 'prefixFont', includeIfNull: false, defaultValue: '')
  final String? prefixFont;
  @JsonKey(name: 'prefixFontSize', includeIfNull: false)
  final double? prefixFontSize;
  @JsonKey(name: 'prefixFontColor', includeIfNull: false)
  final int? prefixFontColor;
  @JsonKey(name: 'prefixFontStyle', includeIfNull: false, defaultValue: '')
  final String? prefixFontStyle;
  @JsonKey(name: 'prefixFontWeight', includeIfNull: false)
  final int? prefixFontWeight;
  @JsonKey(name: 'prefixPadding', includeIfNull: false)
  final double? prefixPadding;
  @JsonKey(name: 'suffixText', includeIfNull: false, defaultValue: '')
  final String? suffixText;
  @JsonKey(name: 'suffixFont', includeIfNull: false, defaultValue: '')
  final String? suffixFont;
  @JsonKey(name: 'suffixFontSize', includeIfNull: false)
  final double? suffixFontSize;
  @JsonKey(name: 'suffixFontColor', includeIfNull: false)
  final int? suffixFontColor;
  @JsonKey(name: 'suffixFontStyle', includeIfNull: false, defaultValue: '')
  final String? suffixFontStyle;
  @JsonKey(name: 'suffixFontWeight', includeIfNull: false)
  final int? suffixFontWeight;
  @JsonKey(name: 'suffixPadding', includeIfNull: false)
  final double? suffixPadding;
  @JsonKey(name: 'topText', includeIfNull: false, defaultValue: '')
  final String? topText;
  @JsonKey(name: 'topFont', includeIfNull: false, defaultValue: '')
  final String? topFont;
  @JsonKey(name: 'topFontSize', includeIfNull: false)
  final double? topFontSize;
  @JsonKey(name: 'topFontColor', includeIfNull: false)
  final int? topFontColor;
  @JsonKey(name: 'topFontStyle', includeIfNull: false, defaultValue: '')
  final String? topFontStyle;
  @JsonKey(name: 'topFontWeight', includeIfNull: false)
  final int? topFontWeight;
  @JsonKey(name: 'topPadding', includeIfNull: false)
  final double? topPadding;
  @JsonKey(name: 'bottomText', includeIfNull: false, defaultValue: '')
  final String? bottomText;
  @JsonKey(name: 'bottomFont', includeIfNull: false, defaultValue: '')
  final String? bottomFont;
  @JsonKey(name: 'bottomFontSize', includeIfNull: false)
  final double? bottomFontSize;
  @JsonKey(name: 'bottomFontColor', includeIfNull: false)
  final int? bottomFontColor;
  @JsonKey(name: 'bottomFontStyle', includeIfNull: false, defaultValue: '')
  final String? bottomFontStyle;
  @JsonKey(name: 'bottomFontWeight', includeIfNull: false)
  final int? bottomFontWeight;
  @JsonKey(name: 'bottomPadding', includeIfNull: false)
  final double? bottomPadding;
  @JsonKey(name: 'width', includeIfNull: false)
  final double width;
  @JsonKey(name: 'height', includeIfNull: false)
  final double height;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String? field;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  static const fromJsonFactory = _$DisplayMatchGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayMatchGroup &&
            (identical(other.matchType, matchType) ||
                const DeepCollectionEquality()
                    .equals(other.matchType, matchType)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.font, font) ||
                const DeepCollectionEquality().equals(other.font, font)) &&
            (identical(other.fontSize, fontSize) ||
                const DeepCollectionEquality()
                    .equals(other.fontSize, fontSize)) &&
            (identical(other.fontColor, fontColor) ||
                const DeepCollectionEquality()
                    .equals(other.fontColor, fontColor)) &&
            (identical(other.fontStyle, fontStyle) ||
                const DeepCollectionEquality()
                    .equals(other.fontStyle, fontStyle)) &&
            (identical(other.fontWeight, fontWeight) ||
                const DeepCollectionEquality()
                    .equals(other.fontWeight, fontWeight)) &&
            (identical(other.bordorColor, bordorColor) ||
                const DeepCollectionEquality()
                    .equals(other.bordorColor, bordorColor)) &&
            (identical(other.borderType, borderType) ||
                const DeepCollectionEquality()
                    .equals(other.borderType, borderType)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.prefixText, prefixText) ||
                const DeepCollectionEquality()
                    .equals(other.prefixText, prefixText)) &&
            (identical(other.prefixFont, prefixFont) ||
                const DeepCollectionEquality()
                    .equals(other.prefixFont, prefixFont)) &&
            (identical(other.prefixFontSize, prefixFontSize) ||
                const DeepCollectionEquality()
                    .equals(other.prefixFontSize, prefixFontSize)) &&
            (identical(other.prefixFontColor, prefixFontColor) ||
                const DeepCollectionEquality()
                    .equals(other.prefixFontColor, prefixFontColor)) &&
            (identical(other.prefixFontStyle, prefixFontStyle) ||
                const DeepCollectionEquality()
                    .equals(other.prefixFontStyle, prefixFontStyle)) &&
            (identical(other.prefixFontWeight, prefixFontWeight) ||
                const DeepCollectionEquality()
                    .equals(other.prefixFontWeight, prefixFontWeight)) &&
            (identical(other.prefixPadding, prefixPadding) ||
                const DeepCollectionEquality()
                    .equals(other.prefixPadding, prefixPadding)) &&
            (identical(other.suffixText, suffixText) ||
                const DeepCollectionEquality()
                    .equals(other.suffixText, suffixText)) &&
            (identical(other.suffixFont, suffixFont) ||
                const DeepCollectionEquality()
                    .equals(other.suffixFont, suffixFont)) &&
            (identical(other.suffixFontSize, suffixFontSize) ||
                const DeepCollectionEquality()
                    .equals(other.suffixFontSize, suffixFontSize)) &&
            (identical(other.suffixFontColor, suffixFontColor) ||
                const DeepCollectionEquality()
                    .equals(other.suffixFontColor, suffixFontColor)) &&
            (identical(other.suffixFontStyle, suffixFontStyle) ||
                const DeepCollectionEquality().equals(other.suffixFontStyle, suffixFontStyle)) &&
            (identical(other.suffixFontWeight, suffixFontWeight) || const DeepCollectionEquality().equals(other.suffixFontWeight, suffixFontWeight)) &&
            (identical(other.suffixPadding, suffixPadding) || const DeepCollectionEquality().equals(other.suffixPadding, suffixPadding)) &&
            (identical(other.topText, topText) || const DeepCollectionEquality().equals(other.topText, topText)) &&
            (identical(other.topFont, topFont) || const DeepCollectionEquality().equals(other.topFont, topFont)) &&
            (identical(other.topFontSize, topFontSize) || const DeepCollectionEquality().equals(other.topFontSize, topFontSize)) &&
            (identical(other.topFontColor, topFontColor) || const DeepCollectionEquality().equals(other.topFontColor, topFontColor)) &&
            (identical(other.topFontStyle, topFontStyle) || const DeepCollectionEquality().equals(other.topFontStyle, topFontStyle)) &&
            (identical(other.topFontWeight, topFontWeight) || const DeepCollectionEquality().equals(other.topFontWeight, topFontWeight)) &&
            (identical(other.topPadding, topPadding) || const DeepCollectionEquality().equals(other.topPadding, topPadding)) &&
            (identical(other.bottomText, bottomText) || const DeepCollectionEquality().equals(other.bottomText, bottomText)) &&
            (identical(other.bottomFont, bottomFont) || const DeepCollectionEquality().equals(other.bottomFont, bottomFont)) &&
            (identical(other.bottomFontSize, bottomFontSize) || const DeepCollectionEquality().equals(other.bottomFontSize, bottomFontSize)) &&
            (identical(other.bottomFontColor, bottomFontColor) || const DeepCollectionEquality().equals(other.bottomFontColor, bottomFontColor)) &&
            (identical(other.bottomFontStyle, bottomFontStyle) || const DeepCollectionEquality().equals(other.bottomFontStyle, bottomFontStyle)) &&
            (identical(other.bottomFontWeight, bottomFontWeight) || const DeepCollectionEquality().equals(other.bottomFontWeight, bottomFontWeight)) &&
            (identical(other.bottomPadding, bottomPadding) || const DeepCollectionEquality().equals(other.bottomPadding, bottomPadding)) &&
            (identical(other.width, width) || const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) || const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.field, field) || const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.tooltip, tooltip) || const DeepCollectionEquality().equals(other.tooltip, tooltip)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(matchType) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(font) ^
      const DeepCollectionEquality().hash(fontSize) ^
      const DeepCollectionEquality().hash(fontColor) ^
      const DeepCollectionEquality().hash(fontStyle) ^
      const DeepCollectionEquality().hash(fontWeight) ^
      const DeepCollectionEquality().hash(bordorColor) ^
      const DeepCollectionEquality().hash(borderType) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(prefixText) ^
      const DeepCollectionEquality().hash(prefixFont) ^
      const DeepCollectionEquality().hash(prefixFontSize) ^
      const DeepCollectionEquality().hash(prefixFontColor) ^
      const DeepCollectionEquality().hash(prefixFontStyle) ^
      const DeepCollectionEquality().hash(prefixFontWeight) ^
      const DeepCollectionEquality().hash(prefixPadding) ^
      const DeepCollectionEquality().hash(suffixText) ^
      const DeepCollectionEquality().hash(suffixFont) ^
      const DeepCollectionEquality().hash(suffixFontSize) ^
      const DeepCollectionEquality().hash(suffixFontColor) ^
      const DeepCollectionEquality().hash(suffixFontStyle) ^
      const DeepCollectionEquality().hash(suffixFontWeight) ^
      const DeepCollectionEquality().hash(suffixPadding) ^
      const DeepCollectionEquality().hash(topText) ^
      const DeepCollectionEquality().hash(topFont) ^
      const DeepCollectionEquality().hash(topFontSize) ^
      const DeepCollectionEquality().hash(topFontColor) ^
      const DeepCollectionEquality().hash(topFontStyle) ^
      const DeepCollectionEquality().hash(topFontWeight) ^
      const DeepCollectionEquality().hash(topPadding) ^
      const DeepCollectionEquality().hash(bottomText) ^
      const DeepCollectionEquality().hash(bottomFont) ^
      const DeepCollectionEquality().hash(bottomFontSize) ^
      const DeepCollectionEquality().hash(bottomFontColor) ^
      const DeepCollectionEquality().hash(bottomFontStyle) ^
      const DeepCollectionEquality().hash(bottomFontWeight) ^
      const DeepCollectionEquality().hash(bottomPadding) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(tooltip) ^
      runtimeType.hashCode;
}

extension $DisplayMatchGroupExtension on DisplayMatchGroup {
  DisplayMatchGroup copyWith(
      {enums.DisplayMatchGroupMatchType? matchType,
      List<String>? conditions,
      String? font,
      double? fontSize,
      int? fontColor,
      String? fontStyle,
      int? fontWeight,
      int? bordorColor,
      enums.DisplayMatchGroupBorderType? borderType,
      String? $value,
      int? bgColor,
      String? prefixText,
      String? prefixFont,
      double? prefixFontSize,
      int? prefixFontColor,
      String? prefixFontStyle,
      int? prefixFontWeight,
      double? prefixPadding,
      String? suffixText,
      String? suffixFont,
      double? suffixFontSize,
      int? suffixFontColor,
      String? suffixFontStyle,
      int? suffixFontWeight,
      double? suffixPadding,
      String? topText,
      String? topFont,
      double? topFontSize,
      int? topFontColor,
      String? topFontStyle,
      int? topFontWeight,
      double? topPadding,
      String? bottomText,
      String? bottomFont,
      double? bottomFontSize,
      int? bottomFontColor,
      String? bottomFontStyle,
      int? bottomFontWeight,
      double? bottomPadding,
      double? width,
      double? height,
      String? field,
      String? tooltip}) {
    return DisplayMatchGroup(
        matchType: matchType ?? this.matchType,
        conditions: conditions ?? this.conditions,
        font: font ?? this.font,
        fontSize: fontSize ?? this.fontSize,
        fontColor: fontColor ?? this.fontColor,
        fontStyle: fontStyle ?? this.fontStyle,
        fontWeight: fontWeight ?? this.fontWeight,
        bordorColor: bordorColor ?? this.bordorColor,
        borderType: borderType ?? this.borderType,
        $value: $value ?? this.$value,
        bgColor: bgColor ?? this.bgColor,
        prefixText: prefixText ?? this.prefixText,
        prefixFont: prefixFont ?? this.prefixFont,
        prefixFontSize: prefixFontSize ?? this.prefixFontSize,
        prefixFontColor: prefixFontColor ?? this.prefixFontColor,
        prefixFontStyle: prefixFontStyle ?? this.prefixFontStyle,
        prefixFontWeight: prefixFontWeight ?? this.prefixFontWeight,
        prefixPadding: prefixPadding ?? this.prefixPadding,
        suffixText: suffixText ?? this.suffixText,
        suffixFont: suffixFont ?? this.suffixFont,
        suffixFontSize: suffixFontSize ?? this.suffixFontSize,
        suffixFontColor: suffixFontColor ?? this.suffixFontColor,
        suffixFontStyle: suffixFontStyle ?? this.suffixFontStyle,
        suffixFontWeight: suffixFontWeight ?? this.suffixFontWeight,
        suffixPadding: suffixPadding ?? this.suffixPadding,
        topText: topText ?? this.topText,
        topFont: topFont ?? this.topFont,
        topFontSize: topFontSize ?? this.topFontSize,
        topFontColor: topFontColor ?? this.topFontColor,
        topFontStyle: topFontStyle ?? this.topFontStyle,
        topFontWeight: topFontWeight ?? this.topFontWeight,
        topPadding: topPadding ?? this.topPadding,
        bottomText: bottomText ?? this.bottomText,
        bottomFont: bottomFont ?? this.bottomFont,
        bottomFontSize: bottomFontSize ?? this.bottomFontSize,
        bottomFontColor: bottomFontColor ?? this.bottomFontColor,
        bottomFontStyle: bottomFontStyle ?? this.bottomFontStyle,
        bottomFontWeight: bottomFontWeight ?? this.bottomFontWeight,
        bottomPadding: bottomPadding ?? this.bottomPadding,
        width: width ?? this.width,
        height: height ?? this.height,
        field: field ?? this.field,
        tooltip: tooltip ?? this.tooltip);
  }

  DisplayMatchGroup copyWithWrapped(
      {Wrapped<enums.DisplayMatchGroupMatchType>? matchType,
      Wrapped<List<String>>? conditions,
      Wrapped<String>? font,
      Wrapped<double>? fontSize,
      Wrapped<int>? fontColor,
      Wrapped<String?>? fontStyle,
      Wrapped<int?>? fontWeight,
      Wrapped<int?>? bordorColor,
      Wrapped<enums.DisplayMatchGroupBorderType?>? borderType,
      Wrapped<String?>? $value,
      Wrapped<int?>? bgColor,
      Wrapped<String?>? prefixText,
      Wrapped<String?>? prefixFont,
      Wrapped<double?>? prefixFontSize,
      Wrapped<int?>? prefixFontColor,
      Wrapped<String?>? prefixFontStyle,
      Wrapped<int?>? prefixFontWeight,
      Wrapped<double?>? prefixPadding,
      Wrapped<String?>? suffixText,
      Wrapped<String?>? suffixFont,
      Wrapped<double?>? suffixFontSize,
      Wrapped<int?>? suffixFontColor,
      Wrapped<String?>? suffixFontStyle,
      Wrapped<int?>? suffixFontWeight,
      Wrapped<double?>? suffixPadding,
      Wrapped<String?>? topText,
      Wrapped<String?>? topFont,
      Wrapped<double?>? topFontSize,
      Wrapped<int?>? topFontColor,
      Wrapped<String?>? topFontStyle,
      Wrapped<int?>? topFontWeight,
      Wrapped<double?>? topPadding,
      Wrapped<String?>? bottomText,
      Wrapped<String?>? bottomFont,
      Wrapped<double?>? bottomFontSize,
      Wrapped<int?>? bottomFontColor,
      Wrapped<String?>? bottomFontStyle,
      Wrapped<int?>? bottomFontWeight,
      Wrapped<double?>? bottomPadding,
      Wrapped<double>? width,
      Wrapped<double>? height,
      Wrapped<String?>? field,
      Wrapped<String?>? tooltip}) {
    return DisplayMatchGroup(
        matchType: (matchType != null ? matchType.value : this.matchType),
        conditions: (conditions != null ? conditions.value : this.conditions),
        font: (font != null ? font.value : this.font),
        fontSize: (fontSize != null ? fontSize.value : this.fontSize),
        fontColor: (fontColor != null ? fontColor.value : this.fontColor),
        fontStyle: (fontStyle != null ? fontStyle.value : this.fontStyle),
        fontWeight: (fontWeight != null ? fontWeight.value : this.fontWeight),
        bordorColor:
            (bordorColor != null ? bordorColor.value : this.bordorColor),
        borderType: (borderType != null ? borderType.value : this.borderType),
        $value: ($value != null ? $value.value : this.$value),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        prefixText: (prefixText != null ? prefixText.value : this.prefixText),
        prefixFont: (prefixFont != null ? prefixFont.value : this.prefixFont),
        prefixFontSize: (prefixFontSize != null
            ? prefixFontSize.value
            : this.prefixFontSize),
        prefixFontColor: (prefixFontColor != null
            ? prefixFontColor.value
            : this.prefixFontColor),
        prefixFontStyle: (prefixFontStyle != null
            ? prefixFontStyle.value
            : this.prefixFontStyle),
        prefixFontWeight: (prefixFontWeight != null
            ? prefixFontWeight.value
            : this.prefixFontWeight),
        prefixPadding:
            (prefixPadding != null ? prefixPadding.value : this.prefixPadding),
        suffixText: (suffixText != null ? suffixText.value : this.suffixText),
        suffixFont: (suffixFont != null ? suffixFont.value : this.suffixFont),
        suffixFontSize: (suffixFontSize != null
            ? suffixFontSize.value
            : this.suffixFontSize),
        suffixFontColor: (suffixFontColor != null
            ? suffixFontColor.value
            : this.suffixFontColor),
        suffixFontStyle: (suffixFontStyle != null
            ? suffixFontStyle.value
            : this.suffixFontStyle),
        suffixFontWeight: (suffixFontWeight != null
            ? suffixFontWeight.value
            : this.suffixFontWeight),
        suffixPadding:
            (suffixPadding != null ? suffixPadding.value : this.suffixPadding),
        topText: (topText != null ? topText.value : this.topText),
        topFont: (topFont != null ? topFont.value : this.topFont),
        topFontSize:
            (topFontSize != null ? topFontSize.value : this.topFontSize),
        topFontColor:
            (topFontColor != null ? topFontColor.value : this.topFontColor),
        topFontStyle:
            (topFontStyle != null ? topFontStyle.value : this.topFontStyle),
        topFontWeight:
            (topFontWeight != null ? topFontWeight.value : this.topFontWeight),
        topPadding: (topPadding != null ? topPadding.value : this.topPadding),
        bottomText: (bottomText != null ? bottomText.value : this.bottomText),
        bottomFont: (bottomFont != null ? bottomFont.value : this.bottomFont),
        bottomFontSize: (bottomFontSize != null
            ? bottomFontSize.value
            : this.bottomFontSize),
        bottomFontColor: (bottomFontColor != null
            ? bottomFontColor.value
            : this.bottomFontColor),
        bottomFontStyle: (bottomFontStyle != null
            ? bottomFontStyle.value
            : this.bottomFontStyle),
        bottomFontWeight: (bottomFontWeight != null
            ? bottomFontWeight.value
            : this.bottomFontWeight),
        bottomPadding:
            (bottomPadding != null ? bottomPadding.value : this.bottomPadding),
        width: (width != null ? width.value : this.width),
        height: (height != null ? height.value : this.height),
        field: (field != null ? field.value : this.field),
        tooltip: (tooltip != null ? tooltip.value : this.tooltip));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayInfo {
  const DisplayInfo({
    required this.name,
    this.description,
    this.label,
    required this.modelId,
    this.icon,
    required this.conditions,
    this.tags,
  });

  factory DisplayInfo.fromJson(Map<String, dynamic> json) =>
      _$DisplayInfoFromJson(json);

  static const toJsonFactory = _$DisplayInfoToJson;
  Map<String, dynamic> toJson() => _$DisplayInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
      name: 'conditions',
      includeIfNull: false,
      defaultValue: <DisplayMatchGroup>[])
  final List<DisplayMatchGroup> conditions;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$DisplayInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $DisplayInfoExtension on DisplayInfo {
  DisplayInfo copyWith(
      {String? name,
      String? description,
      String? label,
      String? modelId,
      String? icon,
      List<DisplayMatchGroup>? conditions,
      List<String>? tags}) {
    return DisplayInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        modelId: modelId ?? this.modelId,
        icon: icon ?? this.icon,
        conditions: conditions ?? this.conditions,
        tags: tags ?? this.tags);
  }

  DisplayInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<String>? modelId,
      Wrapped<String?>? icon,
      Wrapped<List<DisplayMatchGroup>>? conditions,
      Wrapped<List<String>?>? tags}) {
    return DisplayInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        modelId: (modelId != null ? modelId.value : this.modelId),
        icon: (icon != null ? icon.value : this.icon),
        conditions: (conditions != null ? conditions.value : this.conditions),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class Display {
  const Display({
    required this.name,
    this.description,
    this.label,
    required this.modelId,
    this.icon,
    required this.conditions,
    this.tags,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Display.fromJson(Map<String, dynamic> json) =>
      _$DisplayFromJson(json);

  static const toJsonFactory = _$DisplayToJson;
  Map<String, dynamic> toJson() => _$DisplayToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(
      name: 'conditions',
      includeIfNull: false,
      defaultValue: <DisplayMatchGroup>[])
  final List<DisplayMatchGroup> conditions;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$DisplayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Display &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $DisplayExtension on Display {
  Display copyWith(
      {String? name,
      String? description,
      String? label,
      String? modelId,
      String? icon,
      List<DisplayMatchGroup>? conditions,
      List<String>? tags,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Display(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        modelId: modelId ?? this.modelId,
        icon: icon ?? this.icon,
        conditions: conditions ?? this.conditions,
        tags: tags ?? this.tags,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Display copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<String>? modelId,
      Wrapped<String?>? icon,
      Wrapped<List<DisplayMatchGroup>>? conditions,
      Wrapped<List<String>?>? tags,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Display(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        modelId: (modelId != null ? modelId.value : this.modelId),
        icon: (icon != null ? icon.value : this.icon),
        conditions: (conditions != null ? conditions.value : this.conditions),
        tags: (tags != null ? tags.value : this.tags),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayEntity {
  const DisplayEntity({
    this.entity,
  });

  factory DisplayEntity.fromJson(Map<String, dynamic> json) =>
      _$DisplayEntityFromJson(json);

  static const toJsonFactory = _$DisplayEntityToJson;
  Map<String, dynamic> toJson() => _$DisplayEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Display? entity;
  static const fromJsonFactory = _$DisplayEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DisplayEntityExtension on DisplayEntity {
  DisplayEntity copyWith({Display? entity}) {
    return DisplayEntity(entity: entity ?? this.entity);
  }

  DisplayEntity copyWithWrapped({Wrapped<Display?>? entity}) {
    return DisplayEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayEntityRes {
  const DisplayEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DisplayEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DisplayEntityResFromJson(json);

  static const toJsonFactory = _$DisplayEntityResToJson;
  Map<String, dynamic> toJson() => _$DisplayEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Display? entity;
  static const fromJsonFactory = _$DisplayEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DisplayEntityResExtension on DisplayEntityRes {
  DisplayEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Display? entity}) {
    return DisplayEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  DisplayEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Display?>? entity}) {
    return DisplayEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayArray {
  const DisplayArray({
    this.values,
  });

  factory DisplayArray.fromJson(Map<String, dynamic> json) =>
      _$DisplayArrayFromJson(json);

  static const toJsonFactory = _$DisplayArrayToJson;
  Map<String, dynamic> toJson() => _$DisplayArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Display>[])
  final List<Display>? values;
  static const fromJsonFactory = _$DisplayArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DisplayArrayExtension on DisplayArray {
  DisplayArray copyWith({List<Display>? values}) {
    return DisplayArray(values: values ?? this.values);
  }

  DisplayArray copyWithWrapped({Wrapped<List<Display>?>? values}) {
    return DisplayArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayArrayRes {
  const DisplayArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DisplayArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DisplayArrayResFromJson(json);

  static const toJsonFactory = _$DisplayArrayResToJson;
  Map<String, dynamic> toJson() => _$DisplayArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Display>[])
  final List<Display>? values;
  static const fromJsonFactory = _$DisplayArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DisplayArrayResExtension on DisplayArrayRes {
  DisplayArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Display>? values}) {
    return DisplayArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  DisplayArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Display>?>? values}) {
    return DisplayArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class Displayable {
  const Displayable({
    required this.type,
    required this.id,
    required this.width,
    required this.height,
  });

  factory Displayable.fromJson(Map<String, dynamic> json) =>
      _$DisplayableFromJson(json);

  static const toJsonFactory = _$DisplayableToJson;
  Map<String, dynamic> toJson() => _$DisplayableToJson(this);

  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: displayableTypeToJson,
    fromJson: displayableTypeFromJson,
  )
  final enums.DisplayableType type;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'width', includeIfNull: false)
  final int width;
  @JsonKey(name: 'height', includeIfNull: false)
  final int height;
  static const fromJsonFactory = _$DisplayableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Displayable &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      runtimeType.hashCode;
}

extension $DisplayableExtension on Displayable {
  Displayable copyWith(
      {enums.DisplayableType? type, String? id, int? width, int? height}) {
    return Displayable(
        type: type ?? this.type,
        id: id ?? this.id,
        width: width ?? this.width,
        height: height ?? this.height);
  }

  Displayable copyWithWrapped(
      {Wrapped<enums.DisplayableType>? type,
      Wrapped<String>? id,
      Wrapped<int>? width,
      Wrapped<int>? height}) {
    return Displayable(
        type: (type != null ? type.value : this.type),
        id: (id != null ? id.value : this.id),
        width: (width != null ? width.value : this.width),
        height: (height != null ? height.value : this.height));
  }
}

@JsonSerializable(explicitToJson: true)
class Positionable {
  const Positionable({
    required this.view,
    this.top,
    this.bottom,
    this.left,
    this.right,
  });

  factory Positionable.fromJson(Map<String, dynamic> json) =>
      _$PositionableFromJson(json);

  static const toJsonFactory = _$PositionableToJson;
  Map<String, dynamic> toJson() => _$PositionableToJson(this);

  @JsonKey(name: 'view', includeIfNull: false)
  final Displayable view;
  @JsonKey(name: 'top', includeIfNull: false)
  final int? top;
  @JsonKey(name: 'bottom', includeIfNull: false)
  final int? bottom;
  @JsonKey(name: 'left', includeIfNull: false)
  final int? left;
  @JsonKey(name: 'right', includeIfNull: false)
  final int? right;
  static const fromJsonFactory = _$PositionableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Positionable &&
            (identical(other.view, view) ||
                const DeepCollectionEquality().equals(other.view, view)) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.bottom, bottom) ||
                const DeepCollectionEquality().equals(other.bottom, bottom)) &&
            (identical(other.left, left) ||
                const DeepCollectionEquality().equals(other.left, left)) &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(view) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(bottom) ^
      const DeepCollectionEquality().hash(left) ^
      const DeepCollectionEquality().hash(right) ^
      runtimeType.hashCode;
}

extension $PositionableExtension on Positionable {
  Positionable copyWith(
      {Displayable? view, int? top, int? bottom, int? left, int? right}) {
    return Positionable(
        view: view ?? this.view,
        top: top ?? this.top,
        bottom: bottom ?? this.bottom,
        left: left ?? this.left,
        right: right ?? this.right);
  }

  Positionable copyWithWrapped(
      {Wrapped<Displayable>? view,
      Wrapped<int?>? top,
      Wrapped<int?>? bottom,
      Wrapped<int?>? left,
      Wrapped<int?>? right}) {
    return Positionable(
        view: (view != null ? view.value : this.view),
        top: (top != null ? top.value : this.top),
        bottom: (bottom != null ? bottom.value : this.bottom),
        left: (left != null ? left.value : this.left),
        right: (right != null ? right.value : this.right));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewInfo {
  const DeviceViewInfo({
    required this.modelId,
    required this.name,
    this.top,
    this.bottom,
    this.left,
    this.right,
    this.positioned,
    this.description,
    this.tags,
    this.width,
    this.height,
    this.topHeight,
    this.bottomHeight,
    this.leftWidth,
    this.rightWidth,
    this.showInfo,
    this.infoPosition,
    this.border,
  });

  factory DeviceViewInfo.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewInfoFromJson(json);

  static const toJsonFactory = _$DeviceViewInfoToJson;
  Map<String, dynamic> toJson() => _$DeviceViewInfoToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'top', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? top;
  @JsonKey(name: 'bottom', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? bottom;
  @JsonKey(name: 'left', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? left;
  @JsonKey(name: 'right', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? right;
  @JsonKey(
      name: 'positioned', includeIfNull: false, defaultValue: <Positionable>[])
  final List<Positionable>? positioned;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'width', includeIfNull: false)
  final int? width;
  @JsonKey(name: 'height', includeIfNull: false)
  final int? height;
  @JsonKey(name: 'topHeight', includeIfNull: false)
  final int? topHeight;
  @JsonKey(name: 'bottomHeight', includeIfNull: false)
  final int? bottomHeight;
  @JsonKey(name: 'leftWidth', includeIfNull: false)
  final int? leftWidth;
  @JsonKey(name: 'rightWidth', includeIfNull: false)
  final int? rightWidth;
  @JsonKey(name: 'showInfo', includeIfNull: false, defaultValue: true)
  final bool? showInfo;
  @JsonKey(
    name: 'infoPosition',
    includeIfNull: false,
    toJson: deviceViewInfoInfoPositionNullableToJson,
    fromJson: deviceViewInfoInfoPositionInfoPositionNullableFromJson,
  )
  final enums.DeviceViewInfoInfoPosition? infoPosition;
  static enums.DeviceViewInfoInfoPosition?
      deviceViewInfoInfoPositionInfoPositionNullableFromJson(Object? value) =>
          deviceViewInfoInfoPositionNullableFromJson(
              value, enums.DeviceViewInfoInfoPosition.bottom);

  @JsonKey(
    name: 'border',
    includeIfNull: false,
    toJson: deviceViewInfoBorderNullableToJson,
    fromJson: deviceViewInfoBorderBorderNullableFromJson,
  )
  final enums.DeviceViewInfoBorder? border;
  static enums.DeviceViewInfoBorder? deviceViewInfoBorderBorderNullableFromJson(
          Object? value) =>
      deviceViewInfoBorderNullableFromJson(
          value, enums.DeviceViewInfoBorder.none);

  static const fromJsonFactory = _$DeviceViewInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewInfo &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.bottom, bottom) ||
                const DeepCollectionEquality().equals(other.bottom, bottom)) &&
            (identical(other.left, left) ||
                const DeepCollectionEquality().equals(other.left, left)) &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)) &&
            (identical(other.positioned, positioned) ||
                const DeepCollectionEquality()
                    .equals(other.positioned, positioned)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.topHeight, topHeight) ||
                const DeepCollectionEquality()
                    .equals(other.topHeight, topHeight)) &&
            (identical(other.bottomHeight, bottomHeight) ||
                const DeepCollectionEquality()
                    .equals(other.bottomHeight, bottomHeight)) &&
            (identical(other.leftWidth, leftWidth) ||
                const DeepCollectionEquality()
                    .equals(other.leftWidth, leftWidth)) &&
            (identical(other.rightWidth, rightWidth) ||
                const DeepCollectionEquality()
                    .equals(other.rightWidth, rightWidth)) &&
            (identical(other.showInfo, showInfo) ||
                const DeepCollectionEquality()
                    .equals(other.showInfo, showInfo)) &&
            (identical(other.infoPosition, infoPosition) ||
                const DeepCollectionEquality()
                    .equals(other.infoPosition, infoPosition)) &&
            (identical(other.border, border) ||
                const DeepCollectionEquality().equals(other.border, border)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(bottom) ^
      const DeepCollectionEquality().hash(left) ^
      const DeepCollectionEquality().hash(right) ^
      const DeepCollectionEquality().hash(positioned) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(topHeight) ^
      const DeepCollectionEquality().hash(bottomHeight) ^
      const DeepCollectionEquality().hash(leftWidth) ^
      const DeepCollectionEquality().hash(rightWidth) ^
      const DeepCollectionEquality().hash(showInfo) ^
      const DeepCollectionEquality().hash(infoPosition) ^
      const DeepCollectionEquality().hash(border) ^
      runtimeType.hashCode;
}

extension $DeviceViewInfoExtension on DeviceViewInfo {
  DeviceViewInfo copyWith(
      {String? modelId,
      String? name,
      List<Displayable>? top,
      List<Displayable>? bottom,
      List<Displayable>? left,
      List<Displayable>? right,
      List<Positionable>? positioned,
      String? description,
      List<String>? tags,
      int? width,
      int? height,
      int? topHeight,
      int? bottomHeight,
      int? leftWidth,
      int? rightWidth,
      bool? showInfo,
      enums.DeviceViewInfoInfoPosition? infoPosition,
      enums.DeviceViewInfoBorder? border}) {
    return DeviceViewInfo(
        modelId: modelId ?? this.modelId,
        name: name ?? this.name,
        top: top ?? this.top,
        bottom: bottom ?? this.bottom,
        left: left ?? this.left,
        right: right ?? this.right,
        positioned: positioned ?? this.positioned,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        width: width ?? this.width,
        height: height ?? this.height,
        topHeight: topHeight ?? this.topHeight,
        bottomHeight: bottomHeight ?? this.bottomHeight,
        leftWidth: leftWidth ?? this.leftWidth,
        rightWidth: rightWidth ?? this.rightWidth,
        showInfo: showInfo ?? this.showInfo,
        infoPosition: infoPosition ?? this.infoPosition,
        border: border ?? this.border);
  }

  DeviceViewInfo copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<String>? name,
      Wrapped<List<Displayable>?>? top,
      Wrapped<List<Displayable>?>? bottom,
      Wrapped<List<Displayable>?>? left,
      Wrapped<List<Displayable>?>? right,
      Wrapped<List<Positionable>?>? positioned,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<int?>? width,
      Wrapped<int?>? height,
      Wrapped<int?>? topHeight,
      Wrapped<int?>? bottomHeight,
      Wrapped<int?>? leftWidth,
      Wrapped<int?>? rightWidth,
      Wrapped<bool?>? showInfo,
      Wrapped<enums.DeviceViewInfoInfoPosition?>? infoPosition,
      Wrapped<enums.DeviceViewInfoBorder?>? border}) {
    return DeviceViewInfo(
        modelId: (modelId != null ? modelId.value : this.modelId),
        name: (name != null ? name.value : this.name),
        top: (top != null ? top.value : this.top),
        bottom: (bottom != null ? bottom.value : this.bottom),
        left: (left != null ? left.value : this.left),
        right: (right != null ? right.value : this.right),
        positioned: (positioned != null ? positioned.value : this.positioned),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        width: (width != null ? width.value : this.width),
        height: (height != null ? height.value : this.height),
        topHeight: (topHeight != null ? topHeight.value : this.topHeight),
        bottomHeight:
            (bottomHeight != null ? bottomHeight.value : this.bottomHeight),
        leftWidth: (leftWidth != null ? leftWidth.value : this.leftWidth),
        rightWidth: (rightWidth != null ? rightWidth.value : this.rightWidth),
        showInfo: (showInfo != null ? showInfo.value : this.showInfo),
        infoPosition:
            (infoPosition != null ? infoPosition.value : this.infoPosition),
        border: (border != null ? border.value : this.border));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceView {
  const DeviceView({
    required this.modelId,
    required this.name,
    this.top,
    this.bottom,
    this.left,
    this.right,
    this.positioned,
    this.description,
    this.tags,
    this.width,
    this.height,
    this.topHeight,
    this.bottomHeight,
    this.leftWidth,
    this.rightWidth,
    this.showInfo,
    this.infoPosition,
    this.border,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory DeviceView.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewFromJson(json);

  static const toJsonFactory = _$DeviceViewToJson;
  Map<String, dynamic> toJson() => _$DeviceViewToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'top', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? top;
  @JsonKey(name: 'bottom', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? bottom;
  @JsonKey(name: 'left', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? left;
  @JsonKey(name: 'right', includeIfNull: false, defaultValue: <Displayable>[])
  final List<Displayable>? right;
  @JsonKey(
      name: 'positioned', includeIfNull: false, defaultValue: <Positionable>[])
  final List<Positionable>? positioned;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'width', includeIfNull: false)
  final int? width;
  @JsonKey(name: 'height', includeIfNull: false)
  final int? height;
  @JsonKey(name: 'topHeight', includeIfNull: false)
  final int? topHeight;
  @JsonKey(name: 'bottomHeight', includeIfNull: false)
  final int? bottomHeight;
  @JsonKey(name: 'leftWidth', includeIfNull: false)
  final int? leftWidth;
  @JsonKey(name: 'rightWidth', includeIfNull: false)
  final int? rightWidth;
  @JsonKey(name: 'showInfo', includeIfNull: false, defaultValue: true)
  final bool? showInfo;
  @JsonKey(
    name: 'infoPosition',
    includeIfNull: false,
    toJson: deviceViewInfoPositionNullableToJson,
    fromJson: deviceViewInfoPositionInfoPositionNullableFromJson,
  )
  final enums.DeviceViewInfoPosition? infoPosition;
  static enums.DeviceViewInfoPosition?
      deviceViewInfoPositionInfoPositionNullableFromJson(Object? value) =>
          deviceViewInfoPositionNullableFromJson(
              value, enums.DeviceViewInfoPosition.bottom);

  @JsonKey(
    name: 'border',
    includeIfNull: false,
    toJson: deviceViewBorderNullableToJson,
    fromJson: deviceViewBorderBorderNullableFromJson,
  )
  final enums.DeviceViewBorder? border;
  static enums.DeviceViewBorder? deviceViewBorderBorderNullableFromJson(
          Object? value) =>
      deviceViewBorderNullableFromJson(value, enums.DeviceViewBorder.none);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$DeviceViewFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceView &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.bottom, bottom) ||
                const DeepCollectionEquality().equals(other.bottom, bottom)) &&
            (identical(other.left, left) ||
                const DeepCollectionEquality().equals(other.left, left)) &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)) &&
            (identical(other.positioned, positioned) ||
                const DeepCollectionEquality()
                    .equals(other.positioned, positioned)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.topHeight, topHeight) ||
                const DeepCollectionEquality()
                    .equals(other.topHeight, topHeight)) &&
            (identical(other.bottomHeight, bottomHeight) ||
                const DeepCollectionEquality()
                    .equals(other.bottomHeight, bottomHeight)) &&
            (identical(other.leftWidth, leftWidth) ||
                const DeepCollectionEquality()
                    .equals(other.leftWidth, leftWidth)) &&
            (identical(other.rightWidth, rightWidth) ||
                const DeepCollectionEquality()
                    .equals(other.rightWidth, rightWidth)) &&
            (identical(other.showInfo, showInfo) ||
                const DeepCollectionEquality()
                    .equals(other.showInfo, showInfo)) &&
            (identical(other.infoPosition, infoPosition) ||
                const DeepCollectionEquality()
                    .equals(other.infoPosition, infoPosition)) &&
            (identical(other.border, border) ||
                const DeepCollectionEquality().equals(other.border, border)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(bottom) ^
      const DeepCollectionEquality().hash(left) ^
      const DeepCollectionEquality().hash(right) ^
      const DeepCollectionEquality().hash(positioned) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(topHeight) ^
      const DeepCollectionEquality().hash(bottomHeight) ^
      const DeepCollectionEquality().hash(leftWidth) ^
      const DeepCollectionEquality().hash(rightWidth) ^
      const DeepCollectionEquality().hash(showInfo) ^
      const DeepCollectionEquality().hash(infoPosition) ^
      const DeepCollectionEquality().hash(border) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $DeviceViewExtension on DeviceView {
  DeviceView copyWith(
      {String? modelId,
      String? name,
      List<Displayable>? top,
      List<Displayable>? bottom,
      List<Displayable>? left,
      List<Displayable>? right,
      List<Positionable>? positioned,
      String? description,
      List<String>? tags,
      int? width,
      int? height,
      int? topHeight,
      int? bottomHeight,
      int? leftWidth,
      int? rightWidth,
      bool? showInfo,
      enums.DeviceViewInfoPosition? infoPosition,
      enums.DeviceViewBorder? border,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return DeviceView(
        modelId: modelId ?? this.modelId,
        name: name ?? this.name,
        top: top ?? this.top,
        bottom: bottom ?? this.bottom,
        left: left ?? this.left,
        right: right ?? this.right,
        positioned: positioned ?? this.positioned,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        width: width ?? this.width,
        height: height ?? this.height,
        topHeight: topHeight ?? this.topHeight,
        bottomHeight: bottomHeight ?? this.bottomHeight,
        leftWidth: leftWidth ?? this.leftWidth,
        rightWidth: rightWidth ?? this.rightWidth,
        showInfo: showInfo ?? this.showInfo,
        infoPosition: infoPosition ?? this.infoPosition,
        border: border ?? this.border,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  DeviceView copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<String>? name,
      Wrapped<List<Displayable>?>? top,
      Wrapped<List<Displayable>?>? bottom,
      Wrapped<List<Displayable>?>? left,
      Wrapped<List<Displayable>?>? right,
      Wrapped<List<Positionable>?>? positioned,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<int?>? width,
      Wrapped<int?>? height,
      Wrapped<int?>? topHeight,
      Wrapped<int?>? bottomHeight,
      Wrapped<int?>? leftWidth,
      Wrapped<int?>? rightWidth,
      Wrapped<bool?>? showInfo,
      Wrapped<enums.DeviceViewInfoPosition?>? infoPosition,
      Wrapped<enums.DeviceViewBorder?>? border,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return DeviceView(
        modelId: (modelId != null ? modelId.value : this.modelId),
        name: (name != null ? name.value : this.name),
        top: (top != null ? top.value : this.top),
        bottom: (bottom != null ? bottom.value : this.bottom),
        left: (left != null ? left.value : this.left),
        right: (right != null ? right.value : this.right),
        positioned: (positioned != null ? positioned.value : this.positioned),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        width: (width != null ? width.value : this.width),
        height: (height != null ? height.value : this.height),
        topHeight: (topHeight != null ? topHeight.value : this.topHeight),
        bottomHeight:
            (bottomHeight != null ? bottomHeight.value : this.bottomHeight),
        leftWidth: (leftWidth != null ? leftWidth.value : this.leftWidth),
        rightWidth: (rightWidth != null ? rightWidth.value : this.rightWidth),
        showInfo: (showInfo != null ? showInfo.value : this.showInfo),
        infoPosition:
            (infoPosition != null ? infoPosition.value : this.infoPosition),
        border: (border != null ? border.value : this.border),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewEntity {
  const DeviceViewEntity({
    this.entity,
  });

  factory DeviceViewEntity.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewEntityFromJson(json);

  static const toJsonFactory = _$DeviceViewEntityToJson;
  Map<String, dynamic> toJson() => _$DeviceViewEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DeviceView? entity;
  static const fromJsonFactory = _$DeviceViewEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DeviceViewEntityExtension on DeviceViewEntity {
  DeviceViewEntity copyWith({DeviceView? entity}) {
    return DeviceViewEntity(entity: entity ?? this.entity);
  }

  DeviceViewEntity copyWithWrapped({Wrapped<DeviceView?>? entity}) {
    return DeviceViewEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewEntityRes {
  const DeviceViewEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DeviceViewEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewEntityResFromJson(json);

  static const toJsonFactory = _$DeviceViewEntityResToJson;
  Map<String, dynamic> toJson() => _$DeviceViewEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DeviceView? entity;
  static const fromJsonFactory = _$DeviceViewEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DeviceViewEntityResExtension on DeviceViewEntityRes {
  DeviceViewEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      DeviceView? entity}) {
    return DeviceViewEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  DeviceViewEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<DeviceView?>? entity}) {
    return DeviceViewEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewArray {
  const DeviceViewArray({
    this.values,
  });

  factory DeviceViewArray.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewArrayFromJson(json);

  static const toJsonFactory = _$DeviceViewArrayToJson;
  Map<String, dynamic> toJson() => _$DeviceViewArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceView>[])
  final List<DeviceView>? values;
  static const fromJsonFactory = _$DeviceViewArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DeviceViewArrayExtension on DeviceViewArray {
  DeviceViewArray copyWith({List<DeviceView>? values}) {
    return DeviceViewArray(values: values ?? this.values);
  }

  DeviceViewArray copyWithWrapped({Wrapped<List<DeviceView>?>? values}) {
    return DeviceViewArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceViewArrayRes {
  const DeviceViewArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DeviceViewArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceViewArrayResFromJson(json);

  static const toJsonFactory = _$DeviceViewArrayResToJson;
  Map<String, dynamic> toJson() => _$DeviceViewArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceView>[])
  final List<DeviceView>? values;
  static const fromJsonFactory = _$DeviceViewArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceViewArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DeviceViewArrayResExtension on DeviceViewArrayRes {
  DeviceViewArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<DeviceView>? values}) {
    return DeviceViewArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  DeviceViewArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<DeviceView>?>? values}) {
    return DeviceViewArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluatedAlarm {
  const EvaluatedAlarm({
    required this.alarmId,
    required this.state,
    required this.stateIcon,
    this.tooltip,
    this.deviceState,
  });

  factory EvaluatedAlarm.fromJson(Map<String, dynamic> json) =>
      _$EvaluatedAlarmFromJson(json);

  static const toJsonFactory = _$EvaluatedAlarmToJson;
  Map<String, dynamic> toJson() => _$EvaluatedAlarmToJson(this);

  @JsonKey(name: 'alarmId', includeIfNull: false, defaultValue: '')
  final String alarmId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int state;
  @JsonKey(name: 'stateIcon', includeIfNull: false, defaultValue: '')
  final String stateIcon;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'deviceState', includeIfNull: false)
  final int? deviceState;
  static const fromJsonFactory = _$EvaluatedAlarmFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluatedAlarm &&
            (identical(other.alarmId, alarmId) ||
                const DeepCollectionEquality()
                    .equals(other.alarmId, alarmId)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcon, stateIcon) ||
                const DeepCollectionEquality()
                    .equals(other.stateIcon, stateIcon)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality()
                    .equals(other.tooltip, tooltip)) &&
            (identical(other.deviceState, deviceState) ||
                const DeepCollectionEquality()
                    .equals(other.deviceState, deviceState)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(alarmId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcon) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(deviceState) ^
      runtimeType.hashCode;
}

extension $EvaluatedAlarmExtension on EvaluatedAlarm {
  EvaluatedAlarm copyWith(
      {String? alarmId,
      int? state,
      String? stateIcon,
      String? tooltip,
      int? deviceState}) {
    return EvaluatedAlarm(
        alarmId: alarmId ?? this.alarmId,
        state: state ?? this.state,
        stateIcon: stateIcon ?? this.stateIcon,
        tooltip: tooltip ?? this.tooltip,
        deviceState: deviceState ?? this.deviceState);
  }

  EvaluatedAlarm copyWithWrapped(
      {Wrapped<String>? alarmId,
      Wrapped<int>? state,
      Wrapped<String>? stateIcon,
      Wrapped<String?>? tooltip,
      Wrapped<int?>? deviceState}) {
    return EvaluatedAlarm(
        alarmId: (alarmId != null ? alarmId.value : this.alarmId),
        state: (state != null ? state.value : this.state),
        stateIcon: (stateIcon != null ? stateIcon.value : this.stateIcon),
        tooltip: (tooltip != null ? tooltip.value : this.tooltip),
        deviceState:
            (deviceState != null ? deviceState.value : this.deviceState));
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluatedDisplay {
  const EvaluatedDisplay({
    required this.displayId,
    required this.prefix,
    required this.suffix,
    required this.$value,
    required this.conditionIndex,
    this.tooltip,
  });

  factory EvaluatedDisplay.fromJson(Map<String, dynamic> json) =>
      _$EvaluatedDisplayFromJson(json);

  static const toJsonFactory = _$EvaluatedDisplayToJson;
  Map<String, dynamic> toJson() => _$EvaluatedDisplayToJson(this);

  @JsonKey(name: 'displayId', includeIfNull: false, defaultValue: '')
  final String displayId;
  @JsonKey(name: 'prefix', includeIfNull: false, defaultValue: '')
  final String prefix;
  @JsonKey(name: 'suffix', includeIfNull: false, defaultValue: '')
  final String suffix;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String $value;
  @JsonKey(name: 'conditionIndex', includeIfNull: false)
  final int conditionIndex;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  static const fromJsonFactory = _$EvaluatedDisplayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluatedDisplay &&
            (identical(other.displayId, displayId) ||
                const DeepCollectionEquality()
                    .equals(other.displayId, displayId)) &&
            (identical(other.prefix, prefix) ||
                const DeepCollectionEquality().equals(other.prefix, prefix)) &&
            (identical(other.suffix, suffix) ||
                const DeepCollectionEquality().equals(other.suffix, suffix)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.conditionIndex, conditionIndex) ||
                const DeepCollectionEquality()
                    .equals(other.conditionIndex, conditionIndex)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality().equals(other.tooltip, tooltip)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(displayId) ^
      const DeepCollectionEquality().hash(prefix) ^
      const DeepCollectionEquality().hash(suffix) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(conditionIndex) ^
      const DeepCollectionEquality().hash(tooltip) ^
      runtimeType.hashCode;
}

extension $EvaluatedDisplayExtension on EvaluatedDisplay {
  EvaluatedDisplay copyWith(
      {String? displayId,
      String? prefix,
      String? suffix,
      String? $value,
      int? conditionIndex,
      String? tooltip}) {
    return EvaluatedDisplay(
        displayId: displayId ?? this.displayId,
        prefix: prefix ?? this.prefix,
        suffix: suffix ?? this.suffix,
        $value: $value ?? this.$value,
        conditionIndex: conditionIndex ?? this.conditionIndex,
        tooltip: tooltip ?? this.tooltip);
  }

  EvaluatedDisplay copyWithWrapped(
      {Wrapped<String>? displayId,
      Wrapped<String>? prefix,
      Wrapped<String>? suffix,
      Wrapped<String>? $value,
      Wrapped<int>? conditionIndex,
      Wrapped<String?>? tooltip}) {
    return EvaluatedDisplay(
        displayId: (displayId != null ? displayId.value : this.displayId),
        prefix: (prefix != null ? prefix.value : this.prefix),
        suffix: (suffix != null ? suffix.value : this.suffix),
        $value: ($value != null ? $value.value : this.$value),
        conditionIndex: (conditionIndex != null
            ? conditionIndex.value
            : this.conditionIndex),
        tooltip: (tooltip != null ? tooltip.value : this.tooltip));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceControl {
  const DeviceControl({
    required this.controlId,
    this.deviceId,
    this.hardwareDeviceId,
    required this.state,
    required this.stateIcon,
    this.rtype,
    this.id,
    this.name,
    this.createdStamp,
    this.createdBy,
    this.updatedBy,
    this.updatedStamp,
  });

  factory DeviceControl.fromJson(Map<String, dynamic> json) =>
      _$DeviceControlFromJson(json);

  static const toJsonFactory = _$DeviceControlToJson;
  Map<String, dynamic> toJson() => _$DeviceControlToJson(this);

  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String controlId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String? deviceId;
  @JsonKey(name: 'hardwareDeviceId', includeIfNull: false, defaultValue: '')
  final String? hardwareDeviceId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int state;
  @JsonKey(name: 'stateIcon', includeIfNull: false, defaultValue: '')
  final String stateIcon;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String? rtype;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int? createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String? createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String? updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int? updatedStamp;
  static const fromJsonFactory = _$DeviceControlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceControl &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality()
                    .equals(other.controlId, controlId)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.hardwareDeviceId, hardwareDeviceId) ||
                const DeepCollectionEquality()
                    .equals(other.hardwareDeviceId, hardwareDeviceId)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcon, stateIcon) ||
                const DeepCollectionEquality()
                    .equals(other.stateIcon, stateIcon)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(hardwareDeviceId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcon) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $DeviceControlExtension on DeviceControl {
  DeviceControl copyWith(
      {String? controlId,
      String? deviceId,
      String? hardwareDeviceId,
      int? state,
      String? stateIcon,
      String? rtype,
      String? id,
      String? name,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return DeviceControl(
        controlId: controlId ?? this.controlId,
        deviceId: deviceId ?? this.deviceId,
        hardwareDeviceId: hardwareDeviceId ?? this.hardwareDeviceId,
        state: state ?? this.state,
        stateIcon: stateIcon ?? this.stateIcon,
        rtype: rtype ?? this.rtype,
        id: id ?? this.id,
        name: name ?? this.name,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  DeviceControl copyWithWrapped(
      {Wrapped<String>? controlId,
      Wrapped<String?>? deviceId,
      Wrapped<String?>? hardwareDeviceId,
      Wrapped<int>? state,
      Wrapped<String>? stateIcon,
      Wrapped<String?>? rtype,
      Wrapped<String?>? id,
      Wrapped<String?>? name,
      Wrapped<int?>? createdStamp,
      Wrapped<String?>? createdBy,
      Wrapped<String?>? updatedBy,
      Wrapped<int?>? updatedStamp}) {
    return DeviceControl(
        controlId: (controlId != null ? controlId.value : this.controlId),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        hardwareDeviceId: (hardwareDeviceId != null
            ? hardwareDeviceId.value
            : this.hardwareDeviceId),
        state: (state != null ? state.value : this.state),
        stateIcon: (stateIcon != null ? stateIcon.value : this.stateIcon),
        rtype: (rtype != null ? rtype.value : this.rtype),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluatedEvent {
  const EvaluatedEvent({
    required this.eventId,
    required this.icon,
    required this.name,
    required this.description,
  });

  factory EvaluatedEvent.fromJson(Map<String, dynamic> json) =>
      _$EvaluatedEventFromJson(json);

  static const toJsonFactory = _$EvaluatedEventToJson;
  Map<String, dynamic> toJson() => _$EvaluatedEventToJson(this);

  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String eventId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String icon;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String description;
  static const fromJsonFactory = _$EvaluatedEventFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluatedEvent &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $EvaluatedEventExtension on EvaluatedEvent {
  EvaluatedEvent copyWith(
      {String? eventId, String? icon, String? name, String? description}) {
    return EvaluatedEvent(
        eventId: eventId ?? this.eventId,
        icon: icon ?? this.icon,
        name: name ?? this.name,
        description: description ?? this.description);
  }

  EvaluatedEvent copyWithWrapped(
      {Wrapped<String>? eventId,
      Wrapped<String>? icon,
      Wrapped<String>? name,
      Wrapped<String>? description}) {
    return EvaluatedEvent(
        eventId: (eventId != null ? eventId.value : this.eventId),
        icon: (icon != null ? icon.value : this.icon),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredControl {
  const TriggeredControl({
    required this.id,
    required this.controlId,
    required this.modelId,
    required this.deviceId,
    required this.triggerId,
    this.triggerIcon,
    this.hardwareDeviceId,
    this.state,
    this.stateIcon,
    this.data,
    this.rtype,
    this.name,
    this.createdStamp,
    this.createdBy,
    this.updatedBy,
    this.updatedStamp,
    this.deliveryStatus,
    this.deliveryErrors,
    this.deviceIcon,
  });

  factory TriggeredControl.fromJson(Map<String, dynamic> json) =>
      _$TriggeredControlFromJson(json);

  static const toJsonFactory = _$TriggeredControlToJson;
  Map<String, dynamic> toJson() => _$TriggeredControlToJson(this);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'controlId', includeIfNull: false, defaultValue: '')
  final String controlId;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'triggerId', includeIfNull: false, defaultValue: '')
  final String triggerId;
  @JsonKey(name: 'triggerIcon', includeIfNull: false, defaultValue: '')
  final String? triggerIcon;
  @JsonKey(name: 'hardwareDeviceId', includeIfNull: false, defaultValue: '')
  final String? hardwareDeviceId;
  @JsonKey(name: 'state', includeIfNull: false)
  final int? state;
  @JsonKey(name: 'stateIcon', includeIfNull: false, defaultValue: '')
  final String? stateIcon;
  @JsonKey(name: 'data', includeIfNull: false)
  final Object? data;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String? rtype;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int? createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String? createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String? updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int? updatedStamp;
  @JsonKey(
    name: 'deliveryStatus',
    includeIfNull: false,
    toJson: triggeredControlDeliveryStatusNullableToJson,
    fromJson: triggeredControlDeliveryStatusNullableFromJson,
  )
  final enums.TriggeredControlDeliveryStatus? deliveryStatus;
  @JsonKey(
      name: 'deliveryErrors', includeIfNull: false, defaultValue: <String>[])
  final List<String>? deliveryErrors;
  @JsonKey(name: 'deviceIcon', includeIfNull: false, defaultValue: '')
  final String? deviceIcon;
  static const fromJsonFactory = _$TriggeredControlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredControl &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.controlId, controlId) ||
                const DeepCollectionEquality()
                    .equals(other.controlId, controlId)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.triggerId, triggerId) ||
                const DeepCollectionEquality()
                    .equals(other.triggerId, triggerId)) &&
            (identical(other.triggerIcon, triggerIcon) ||
                const DeepCollectionEquality()
                    .equals(other.triggerIcon, triggerIcon)) &&
            (identical(other.hardwareDeviceId, hardwareDeviceId) ||
                const DeepCollectionEquality()
                    .equals(other.hardwareDeviceId, hardwareDeviceId)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.stateIcon, stateIcon) ||
                const DeepCollectionEquality()
                    .equals(other.stateIcon, stateIcon)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.deliveryStatus, deliveryStatus) ||
                const DeepCollectionEquality()
                    .equals(other.deliveryStatus, deliveryStatus)) &&
            (identical(other.deliveryErrors, deliveryErrors) ||
                const DeepCollectionEquality()
                    .equals(other.deliveryErrors, deliveryErrors)) &&
            (identical(other.deviceIcon, deviceIcon) ||
                const DeepCollectionEquality()
                    .equals(other.deviceIcon, deviceIcon)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(controlId) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(triggerId) ^
      const DeepCollectionEquality().hash(triggerIcon) ^
      const DeepCollectionEquality().hash(hardwareDeviceId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(stateIcon) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(deliveryStatus) ^
      const DeepCollectionEquality().hash(deliveryErrors) ^
      const DeepCollectionEquality().hash(deviceIcon) ^
      runtimeType.hashCode;
}

extension $TriggeredControlExtension on TriggeredControl {
  TriggeredControl copyWith(
      {String? id,
      String? controlId,
      String? modelId,
      String? deviceId,
      String? triggerId,
      String? triggerIcon,
      String? hardwareDeviceId,
      int? state,
      String? stateIcon,
      Object? data,
      String? rtype,
      String? name,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      enums.TriggeredControlDeliveryStatus? deliveryStatus,
      List<String>? deliveryErrors,
      String? deviceIcon}) {
    return TriggeredControl(
        id: id ?? this.id,
        controlId: controlId ?? this.controlId,
        modelId: modelId ?? this.modelId,
        deviceId: deviceId ?? this.deviceId,
        triggerId: triggerId ?? this.triggerId,
        triggerIcon: triggerIcon ?? this.triggerIcon,
        hardwareDeviceId: hardwareDeviceId ?? this.hardwareDeviceId,
        state: state ?? this.state,
        stateIcon: stateIcon ?? this.stateIcon,
        data: data ?? this.data,
        rtype: rtype ?? this.rtype,
        name: name ?? this.name,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        deliveryStatus: deliveryStatus ?? this.deliveryStatus,
        deliveryErrors: deliveryErrors ?? this.deliveryErrors,
        deviceIcon: deviceIcon ?? this.deviceIcon);
  }

  TriggeredControl copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? controlId,
      Wrapped<String>? modelId,
      Wrapped<String>? deviceId,
      Wrapped<String>? triggerId,
      Wrapped<String?>? triggerIcon,
      Wrapped<String?>? hardwareDeviceId,
      Wrapped<int?>? state,
      Wrapped<String?>? stateIcon,
      Wrapped<Object?>? data,
      Wrapped<String?>? rtype,
      Wrapped<String?>? name,
      Wrapped<int?>? createdStamp,
      Wrapped<String?>? createdBy,
      Wrapped<String?>? updatedBy,
      Wrapped<int?>? updatedStamp,
      Wrapped<enums.TriggeredControlDeliveryStatus?>? deliveryStatus,
      Wrapped<List<String>?>? deliveryErrors,
      Wrapped<String?>? deviceIcon}) {
    return TriggeredControl(
        id: (id != null ? id.value : this.id),
        controlId: (controlId != null ? controlId.value : this.controlId),
        modelId: (modelId != null ? modelId.value : this.modelId),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        triggerId: (triggerId != null ? triggerId.value : this.triggerId),
        triggerIcon:
            (triggerIcon != null ? triggerIcon.value : this.triggerIcon),
        hardwareDeviceId: (hardwareDeviceId != null
            ? hardwareDeviceId.value
            : this.hardwareDeviceId),
        state: (state != null ? state.value : this.state),
        stateIcon: (stateIcon != null ? stateIcon.value : this.stateIcon),
        data: (data != null ? data.value : this.data),
        rtype: (rtype != null ? rtype.value : this.rtype),
        name: (name != null ? name.value : this.name),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        deliveryStatus: (deliveryStatus != null
            ? deliveryStatus.value
            : this.deliveryStatus),
        deliveryErrors: (deliveryErrors != null
            ? deliveryErrors.value
            : this.deliveryErrors),
        deviceIcon: (deviceIcon != null ? deviceIcon.value : this.deviceIcon));
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluatedTrigger {
  const EvaluatedTrigger({
    required this.triggerId,
    this.icon,
  });

  factory EvaluatedTrigger.fromJson(Map<String, dynamic> json) =>
      _$EvaluatedTriggerFromJson(json);

  static const toJsonFactory = _$EvaluatedTriggerToJson;
  Map<String, dynamic> toJson() => _$EvaluatedTriggerToJson(this);

  @JsonKey(name: 'triggerId', includeIfNull: false, defaultValue: '')
  final String triggerId;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  static const fromJsonFactory = _$EvaluatedTriggerFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluatedTrigger &&
            (identical(other.triggerId, triggerId) ||
                const DeepCollectionEquality()
                    .equals(other.triggerId, triggerId)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(triggerId) ^
      const DeepCollectionEquality().hash(icon) ^
      runtimeType.hashCode;
}

extension $EvaluatedTriggerExtension on EvaluatedTrigger {
  EvaluatedTrigger copyWith({String? triggerId, String? icon}) {
    return EvaluatedTrigger(
        triggerId: triggerId ?? this.triggerId, icon: icon ?? this.icon);
  }

  EvaluatedTrigger copyWithWrapped(
      {Wrapped<String>? triggerId, Wrapped<String?>? icon}) {
    return EvaluatedTrigger(
        triggerId: (triggerId != null ? triggerId.value : this.triggerId),
        icon: (icon != null ? icon.value : this.icon));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceData {
  const DeviceData({
    required this.domainKey,
    required this.deviceId,
    this.subType,
    required this.modelId,
    required this.hardwareDeviceId,
    this.reportedStamp,
    this.processedStamp,
    required this.data,
    this.deviceName,
    this.modelName,
    this.deviceDescription,
    this.modelDescription,
    this.deviceIcon,
    this.modelIcon,
    this.rtype,
    this.name,
    this.id,
    required this.createdStamp,
    this.createdBy,
    this.updatedBy,
    required this.updatedStamp,
    this.controls,
    required this.alarms,
    required this.displays,
    required this.events,
    required this.triggers,
    this.evaluationErrors,
    this.series,
    this.trends,
    this.geolocation,
    this.geocoded,
    this.premise,
    this.facility,
    this.floor,
    this.asset,
    this.premiseId,
    this.facilityId,
    this.floorId,
    this.assetId,
    this.roles,
    this.$client,
    this.clientIds,
    this.assetModelId,
  });

  factory DeviceData.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataFromJson(json);

  static const toJsonFactory = _$DeviceDataToJson;
  Map<String, dynamic> toJson() => _$DeviceDataToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'subType', includeIfNull: false, defaultValue: '')
  final String? subType;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'hardwareDeviceId', includeIfNull: false, defaultValue: '')
  final String hardwareDeviceId;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'processedStamp', includeIfNull: false)
  final int? processedStamp;
  @JsonKey(name: 'data', includeIfNull: false)
  final Object data;
  @JsonKey(name: 'deviceName', includeIfNull: false, defaultValue: '')
  final String? deviceName;
  @JsonKey(name: 'modelName', includeIfNull: false, defaultValue: '')
  final String? modelName;
  @JsonKey(name: 'deviceDescription', includeIfNull: false, defaultValue: '')
  final String? deviceDescription;
  @JsonKey(name: 'modelDescription', includeIfNull: false, defaultValue: '')
  final String? modelDescription;
  @JsonKey(name: 'deviceIcon', includeIfNull: false, defaultValue: '')
  final String? deviceIcon;
  @JsonKey(name: 'modelIcon', includeIfNull: false, defaultValue: '')
  final String? modelIcon;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String? rtype;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String? createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String? updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(
      name: 'controls', includeIfNull: false, defaultValue: <DeviceControl>[])
  final List<DeviceControl>? controls;
  @JsonKey(
      name: 'alarms', includeIfNull: false, defaultValue: <EvaluatedAlarm>[])
  final List<EvaluatedAlarm> alarms;
  @JsonKey(
      name: 'displays',
      includeIfNull: false,
      defaultValue: <EvaluatedDisplay>[])
  final List<EvaluatedDisplay> displays;
  @JsonKey(
      name: 'events', includeIfNull: false, defaultValue: <EvaluatedEvent>[])
  final List<EvaluatedEvent> events;
  @JsonKey(
      name: 'triggers',
      includeIfNull: false,
      defaultValue: <EvaluatedTrigger>[])
  final List<EvaluatedTrigger> triggers;
  @JsonKey(
      name: 'evaluationErrors', includeIfNull: false, defaultValue: <String>[])
  final List<String>? evaluationErrors;
  @JsonKey(name: 'series', includeIfNull: false, defaultValue: <String>[])
  final List<String>? series;
  @JsonKey(name: 'trends', includeIfNull: false, defaultValue: <String>[])
  final List<String>? trends;
  @JsonKey(name: 'geolocation', includeIfNull: false)
  final GeoLocation? geolocation;
  @JsonKey(name: 'geocoded', includeIfNull: false)
  final Object? geocoded;
  @JsonKey(name: 'premise', includeIfNull: false, defaultValue: '')
  final String? premise;
  @JsonKey(name: 'facility', includeIfNull: false, defaultValue: '')
  final String? facility;
  @JsonKey(name: 'floor', includeIfNull: false, defaultValue: '')
  final String? floor;
  @JsonKey(name: 'asset', includeIfNull: false, defaultValue: '')
  final String? asset;
  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String? premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String? facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String? floorId;
  @JsonKey(name: 'assetId', includeIfNull: false, defaultValue: '')
  final String? assetId;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'client', includeIfNull: false, defaultValue: '')
  final String? $client;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'assetModelId', includeIfNull: false, defaultValue: '')
  final String? assetModelId;
  static const fromJsonFactory = _$DeviceDataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceData &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.subType, subType) ||
                const DeepCollectionEquality()
                    .equals(other.subType, subType)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.hardwareDeviceId, hardwareDeviceId) ||
                const DeepCollectionEquality()
                    .equals(other.hardwareDeviceId, hardwareDeviceId)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)) &&
            (identical(other.processedStamp, processedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.processedStamp, processedStamp)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.deviceName, deviceName) ||
                const DeepCollectionEquality()
                    .equals(other.deviceName, deviceName)) &&
            (identical(other.modelName, modelName) ||
                const DeepCollectionEquality()
                    .equals(other.modelName, modelName)) &&
            (identical(other.deviceDescription, deviceDescription) ||
                const DeepCollectionEquality()
                    .equals(other.deviceDescription, deviceDescription)) &&
            (identical(other.modelDescription, modelDescription) ||
                const DeepCollectionEquality()
                    .equals(other.modelDescription, modelDescription)) &&
            (identical(other.deviceIcon, deviceIcon) ||
                const DeepCollectionEquality()
                    .equals(other.deviceIcon, deviceIcon)) &&
            (identical(other.modelIcon, modelIcon) ||
                const DeepCollectionEquality()
                    .equals(other.modelIcon, modelIcon)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.controls, controls) ||
                const DeepCollectionEquality()
                    .equals(other.controls, controls)) &&
            (identical(other.alarms, alarms) ||
                const DeepCollectionEquality().equals(other.alarms, alarms)) &&
            (identical(other.displays, displays) ||
                const DeepCollectionEquality()
                    .equals(other.displays, displays)) &&
            (identical(other.events, events) || const DeepCollectionEquality().equals(other.events, events)) &&
            (identical(other.triggers, triggers) || const DeepCollectionEquality().equals(other.triggers, triggers)) &&
            (identical(other.evaluationErrors, evaluationErrors) || const DeepCollectionEquality().equals(other.evaluationErrors, evaluationErrors)) &&
            (identical(other.series, series) || const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.trends, trends) || const DeepCollectionEquality().equals(other.trends, trends)) &&
            (identical(other.geolocation, geolocation) || const DeepCollectionEquality().equals(other.geolocation, geolocation)) &&
            (identical(other.geocoded, geocoded) || const DeepCollectionEquality().equals(other.geocoded, geocoded)) &&
            (identical(other.premise, premise) || const DeepCollectionEquality().equals(other.premise, premise)) &&
            (identical(other.facility, facility) || const DeepCollectionEquality().equals(other.facility, facility)) &&
            (identical(other.floor, floor) || const DeepCollectionEquality().equals(other.floor, floor)) &&
            (identical(other.asset, asset) || const DeepCollectionEquality().equals(other.asset, asset)) &&
            (identical(other.premiseId, premiseId) || const DeepCollectionEquality().equals(other.premiseId, premiseId)) &&
            (identical(other.facilityId, facilityId) || const DeepCollectionEquality().equals(other.facilityId, facilityId)) &&
            (identical(other.floorId, floorId) || const DeepCollectionEquality().equals(other.floorId, floorId)) &&
            (identical(other.assetId, assetId) || const DeepCollectionEquality().equals(other.assetId, assetId)) &&
            (identical(other.roles, roles) || const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.$client, $client) || const DeepCollectionEquality().equals(other.$client, $client)) &&
            (identical(other.clientIds, clientIds) || const DeepCollectionEquality().equals(other.clientIds, clientIds)) &&
            (identical(other.assetModelId, assetModelId) || const DeepCollectionEquality().equals(other.assetModelId, assetModelId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(subType) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(hardwareDeviceId) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(processedStamp) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(deviceName) ^
      const DeepCollectionEquality().hash(modelName) ^
      const DeepCollectionEquality().hash(deviceDescription) ^
      const DeepCollectionEquality().hash(modelDescription) ^
      const DeepCollectionEquality().hash(deviceIcon) ^
      const DeepCollectionEquality().hash(modelIcon) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(controls) ^
      const DeepCollectionEquality().hash(alarms) ^
      const DeepCollectionEquality().hash(displays) ^
      const DeepCollectionEquality().hash(events) ^
      const DeepCollectionEquality().hash(triggers) ^
      const DeepCollectionEquality().hash(evaluationErrors) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(trends) ^
      const DeepCollectionEquality().hash(geolocation) ^
      const DeepCollectionEquality().hash(geocoded) ^
      const DeepCollectionEquality().hash(premise) ^
      const DeepCollectionEquality().hash(facility) ^
      const DeepCollectionEquality().hash(floor) ^
      const DeepCollectionEquality().hash(asset) ^
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(assetId) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash($client) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(assetModelId) ^
      runtimeType.hashCode;
}

extension $DeviceDataExtension on DeviceData {
  DeviceData copyWith(
      {String? domainKey,
      String? deviceId,
      String? subType,
      String? modelId,
      String? hardwareDeviceId,
      int? reportedStamp,
      int? processedStamp,
      Object? data,
      String? deviceName,
      String? modelName,
      String? deviceDescription,
      String? modelDescription,
      String? deviceIcon,
      String? modelIcon,
      String? rtype,
      String? name,
      String? id,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      List<DeviceControl>? controls,
      List<EvaluatedAlarm>? alarms,
      List<EvaluatedDisplay>? displays,
      List<EvaluatedEvent>? events,
      List<EvaluatedTrigger>? triggers,
      List<String>? evaluationErrors,
      List<String>? series,
      List<String>? trends,
      GeoLocation? geolocation,
      Object? geocoded,
      String? premise,
      String? facility,
      String? floor,
      String? asset,
      String? premiseId,
      String? facilityId,
      String? floorId,
      String? assetId,
      List<String>? roles,
      String? $client,
      List<String>? clientIds,
      String? assetModelId}) {
    return DeviceData(
        domainKey: domainKey ?? this.domainKey,
        deviceId: deviceId ?? this.deviceId,
        subType: subType ?? this.subType,
        modelId: modelId ?? this.modelId,
        hardwareDeviceId: hardwareDeviceId ?? this.hardwareDeviceId,
        reportedStamp: reportedStamp ?? this.reportedStamp,
        processedStamp: processedStamp ?? this.processedStamp,
        data: data ?? this.data,
        deviceName: deviceName ?? this.deviceName,
        modelName: modelName ?? this.modelName,
        deviceDescription: deviceDescription ?? this.deviceDescription,
        modelDescription: modelDescription ?? this.modelDescription,
        deviceIcon: deviceIcon ?? this.deviceIcon,
        modelIcon: modelIcon ?? this.modelIcon,
        rtype: rtype ?? this.rtype,
        name: name ?? this.name,
        id: id ?? this.id,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        controls: controls ?? this.controls,
        alarms: alarms ?? this.alarms,
        displays: displays ?? this.displays,
        events: events ?? this.events,
        triggers: triggers ?? this.triggers,
        evaluationErrors: evaluationErrors ?? this.evaluationErrors,
        series: series ?? this.series,
        trends: trends ?? this.trends,
        geolocation: geolocation ?? this.geolocation,
        geocoded: geocoded ?? this.geocoded,
        premise: premise ?? this.premise,
        facility: facility ?? this.facility,
        floor: floor ?? this.floor,
        asset: asset ?? this.asset,
        premiseId: premiseId ?? this.premiseId,
        facilityId: facilityId ?? this.facilityId,
        floorId: floorId ?? this.floorId,
        assetId: assetId ?? this.assetId,
        roles: roles ?? this.roles,
        $client: $client ?? this.$client,
        clientIds: clientIds ?? this.clientIds,
        assetModelId: assetModelId ?? this.assetModelId);
  }

  DeviceData copyWithWrapped(
      {Wrapped<String>? domainKey,
      Wrapped<String>? deviceId,
      Wrapped<String?>? subType,
      Wrapped<String>? modelId,
      Wrapped<String>? hardwareDeviceId,
      Wrapped<int?>? reportedStamp,
      Wrapped<int?>? processedStamp,
      Wrapped<Object>? data,
      Wrapped<String?>? deviceName,
      Wrapped<String?>? modelName,
      Wrapped<String?>? deviceDescription,
      Wrapped<String?>? modelDescription,
      Wrapped<String?>? deviceIcon,
      Wrapped<String?>? modelIcon,
      Wrapped<String?>? rtype,
      Wrapped<String?>? name,
      Wrapped<String?>? id,
      Wrapped<int>? createdStamp,
      Wrapped<String?>? createdBy,
      Wrapped<String?>? updatedBy,
      Wrapped<int>? updatedStamp,
      Wrapped<List<DeviceControl>?>? controls,
      Wrapped<List<EvaluatedAlarm>>? alarms,
      Wrapped<List<EvaluatedDisplay>>? displays,
      Wrapped<List<EvaluatedEvent>>? events,
      Wrapped<List<EvaluatedTrigger>>? triggers,
      Wrapped<List<String>?>? evaluationErrors,
      Wrapped<List<String>?>? series,
      Wrapped<List<String>?>? trends,
      Wrapped<GeoLocation?>? geolocation,
      Wrapped<Object?>? geocoded,
      Wrapped<String?>? premise,
      Wrapped<String?>? facility,
      Wrapped<String?>? floor,
      Wrapped<String?>? asset,
      Wrapped<String?>? premiseId,
      Wrapped<String?>? facilityId,
      Wrapped<String?>? floorId,
      Wrapped<String?>? assetId,
      Wrapped<List<String>?>? roles,
      Wrapped<String?>? $client,
      Wrapped<List<String>?>? clientIds,
      Wrapped<String?>? assetModelId}) {
    return DeviceData(
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        subType: (subType != null ? subType.value : this.subType),
        modelId: (modelId != null ? modelId.value : this.modelId),
        hardwareDeviceId: (hardwareDeviceId != null
            ? hardwareDeviceId.value
            : this.hardwareDeviceId),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp),
        processedStamp: (processedStamp != null
            ? processedStamp.value
            : this.processedStamp),
        data: (data != null ? data.value : this.data),
        deviceName: (deviceName != null ? deviceName.value : this.deviceName),
        modelName: (modelName != null ? modelName.value : this.modelName),
        deviceDescription: (deviceDescription != null
            ? deviceDescription.value
            : this.deviceDescription),
        modelDescription: (modelDescription != null
            ? modelDescription.value
            : this.modelDescription),
        deviceIcon: (deviceIcon != null ? deviceIcon.value : this.deviceIcon),
        modelIcon: (modelIcon != null ? modelIcon.value : this.modelIcon),
        rtype: (rtype != null ? rtype.value : this.rtype),
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        controls: (controls != null ? controls.value : this.controls),
        alarms: (alarms != null ? alarms.value : this.alarms),
        displays: (displays != null ? displays.value : this.displays),
        events: (events != null ? events.value : this.events),
        triggers: (triggers != null ? triggers.value : this.triggers),
        evaluationErrors: (evaluationErrors != null
            ? evaluationErrors.value
            : this.evaluationErrors),
        series: (series != null ? series.value : this.series),
        trends: (trends != null ? trends.value : this.trends),
        geolocation:
            (geolocation != null ? geolocation.value : this.geolocation),
        geocoded: (geocoded != null ? geocoded.value : this.geocoded),
        premise: (premise != null ? premise.value : this.premise),
        facility: (facility != null ? facility.value : this.facility),
        floor: (floor != null ? floor.value : this.floor),
        asset: (asset != null ? asset.value : this.asset),
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        facilityId: (facilityId != null ? facilityId.value : this.facilityId),
        floorId: (floorId != null ? floorId.value : this.floorId),
        assetId: (assetId != null ? assetId.value : this.assetId),
        roles: (roles != null ? roles.value : this.roles),
        $client: ($client != null ? $client.value : this.$client),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        assetModelId:
            (assetModelId != null ? assetModelId.value : this.assetModelId));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceDataArray {
  const DeviceDataArray({
    this.values,
  });

  factory DeviceDataArray.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataArrayFromJson(json);

  static const toJsonFactory = _$DeviceDataArrayToJson;
  Map<String, dynamic> toJson() => _$DeviceDataArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceData>[])
  final List<DeviceData>? values;
  static const fromJsonFactory = _$DeviceDataArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceDataArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DeviceDataArrayExtension on DeviceDataArray {
  DeviceDataArray copyWith({List<DeviceData>? values}) {
    return DeviceDataArray(values: values ?? this.values);
  }

  DeviceDataArray copyWithWrapped({Wrapped<List<DeviceData>?>? values}) {
    return DeviceDataArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceDataArrayRes {
  const DeviceDataArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DeviceDataArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataArrayResFromJson(json);

  static const toJsonFactory = _$DeviceDataArrayResToJson;
  Map<String, dynamic> toJson() => _$DeviceDataArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DeviceData>[])
  final List<DeviceData>? values;
  static const fromJsonFactory = _$DeviceDataArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceDataArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DeviceDataArrayResExtension on DeviceDataArrayRes {
  DeviceDataArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<DeviceData>? values}) {
    return DeviceDataArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  DeviceDataArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<DeviceData>?>? values}) {
    return DeviceDataArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenu {
  const DashboardMenu({
    required this.displayName,
    this.icon,
    required this.webSupported,
    required this.tabletSupported,
    required this.mobileSupported,
    required this.screenId,
  });

  factory DashboardMenu.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuFromJson(json);

  static const toJsonFactory = _$DashboardMenuToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuToJson(this);

  @JsonKey(name: 'displayName', includeIfNull: false, defaultValue: '')
  final String displayName;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'webSupported', includeIfNull: false, defaultValue: true)
  final bool webSupported;
  @JsonKey(name: 'tabletSupported', includeIfNull: false, defaultValue: true)
  final bool tabletSupported;
  @JsonKey(name: 'mobileSupported', includeIfNull: false, defaultValue: true)
  final bool mobileSupported;
  @JsonKey(name: 'screenId', includeIfNull: false, defaultValue: '')
  final String screenId;
  static const fromJsonFactory = _$DashboardMenuFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenu &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.webSupported, webSupported) ||
                const DeepCollectionEquality()
                    .equals(other.webSupported, webSupported)) &&
            (identical(other.tabletSupported, tabletSupported) ||
                const DeepCollectionEquality()
                    .equals(other.tabletSupported, tabletSupported)) &&
            (identical(other.mobileSupported, mobileSupported) ||
                const DeepCollectionEquality()
                    .equals(other.mobileSupported, mobileSupported)) &&
            (identical(other.screenId, screenId) ||
                const DeepCollectionEquality()
                    .equals(other.screenId, screenId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(webSupported) ^
      const DeepCollectionEquality().hash(tabletSupported) ^
      const DeepCollectionEquality().hash(mobileSupported) ^
      const DeepCollectionEquality().hash(screenId) ^
      runtimeType.hashCode;
}

extension $DashboardMenuExtension on DashboardMenu {
  DashboardMenu copyWith(
      {String? displayName,
      String? icon,
      bool? webSupported,
      bool? tabletSupported,
      bool? mobileSupported,
      String? screenId}) {
    return DashboardMenu(
        displayName: displayName ?? this.displayName,
        icon: icon ?? this.icon,
        webSupported: webSupported ?? this.webSupported,
        tabletSupported: tabletSupported ?? this.tabletSupported,
        mobileSupported: mobileSupported ?? this.mobileSupported,
        screenId: screenId ?? this.screenId);
  }

  DashboardMenu copyWithWrapped(
      {Wrapped<String>? displayName,
      Wrapped<String?>? icon,
      Wrapped<bool>? webSupported,
      Wrapped<bool>? tabletSupported,
      Wrapped<bool>? mobileSupported,
      Wrapped<String>? screenId}) {
    return DashboardMenu(
        displayName:
            (displayName != null ? displayName.value : this.displayName),
        icon: (icon != null ? icon.value : this.icon),
        webSupported:
            (webSupported != null ? webSupported.value : this.webSupported),
        tabletSupported: (tabletSupported != null
            ? tabletSupported.value
            : this.tabletSupported),
        mobileSupported: (mobileSupported != null
            ? mobileSupported.value
            : this.mobileSupported),
        screenId: (screenId != null ? screenId.value : this.screenId));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupInfo {
  const DashboardMenuGroupInfo({
    required this.name,
    required this.displayName,
    this.description,
    this.icon,
    this.order,
    required this.webSupported,
    required this.tabletSupported,
    required this.mobileSupported,
    this.tags,
    this.roles,
    this.clientIds,
    required this.menus,
  });

  factory DashboardMenuGroupInfo.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupInfoFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupInfoToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'displayName', includeIfNull: false, defaultValue: '')
  final String displayName;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'webSupported', includeIfNull: false, defaultValue: true)
  final bool webSupported;
  @JsonKey(name: 'tabletSupported', includeIfNull: false, defaultValue: true)
  final bool tabletSupported;
  @JsonKey(name: 'mobileSupported', includeIfNull: false, defaultValue: true)
  final bool mobileSupported;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'menus', includeIfNull: false, defaultValue: <DashboardMenu>[])
  final List<DashboardMenu> menus;
  static const fromJsonFactory = _$DashboardMenuGroupInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.webSupported, webSupported) ||
                const DeepCollectionEquality()
                    .equals(other.webSupported, webSupported)) &&
            (identical(other.tabletSupported, tabletSupported) ||
                const DeepCollectionEquality()
                    .equals(other.tabletSupported, tabletSupported)) &&
            (identical(other.mobileSupported, mobileSupported) ||
                const DeepCollectionEquality()
                    .equals(other.mobileSupported, mobileSupported)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.menus, menus) ||
                const DeepCollectionEquality().equals(other.menus, menus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(webSupported) ^
      const DeepCollectionEquality().hash(tabletSupported) ^
      const DeepCollectionEquality().hash(mobileSupported) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(menus) ^
      runtimeType.hashCode;
}

extension $DashboardMenuGroupInfoExtension on DashboardMenuGroupInfo {
  DashboardMenuGroupInfo copyWith(
      {String? name,
      String? displayName,
      String? description,
      String? icon,
      int? order,
      bool? webSupported,
      bool? tabletSupported,
      bool? mobileSupported,
      List<String>? tags,
      List<String>? roles,
      List<String>? clientIds,
      List<DashboardMenu>? menus}) {
    return DashboardMenuGroupInfo(
        name: name ?? this.name,
        displayName: displayName ?? this.displayName,
        description: description ?? this.description,
        icon: icon ?? this.icon,
        order: order ?? this.order,
        webSupported: webSupported ?? this.webSupported,
        tabletSupported: tabletSupported ?? this.tabletSupported,
        mobileSupported: mobileSupported ?? this.mobileSupported,
        tags: tags ?? this.tags,
        roles: roles ?? this.roles,
        clientIds: clientIds ?? this.clientIds,
        menus: menus ?? this.menus);
  }

  DashboardMenuGroupInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? displayName,
      Wrapped<String?>? description,
      Wrapped<String?>? icon,
      Wrapped<int?>? order,
      Wrapped<bool>? webSupported,
      Wrapped<bool>? tabletSupported,
      Wrapped<bool>? mobileSupported,
      Wrapped<List<String>?>? tags,
      Wrapped<List<String>?>? roles,
      Wrapped<List<String>?>? clientIds,
      Wrapped<List<DashboardMenu>>? menus}) {
    return DashboardMenuGroupInfo(
        name: (name != null ? name.value : this.name),
        displayName:
            (displayName != null ? displayName.value : this.displayName),
        description:
            (description != null ? description.value : this.description),
        icon: (icon != null ? icon.value : this.icon),
        order: (order != null ? order.value : this.order),
        webSupported:
            (webSupported != null ? webSupported.value : this.webSupported),
        tabletSupported: (tabletSupported != null
            ? tabletSupported.value
            : this.tabletSupported),
        mobileSupported: (mobileSupported != null
            ? mobileSupported.value
            : this.mobileSupported),
        tags: (tags != null ? tags.value : this.tags),
        roles: (roles != null ? roles.value : this.roles),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        menus: (menus != null ? menus.value : this.menus));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroup {
  const DashboardMenuGroup({
    required this.domainKey,
    required this.id,
    required this.name,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
    this.tags,
    required this.displayName,
    this.description,
    this.icon,
    this.order,
    required this.webSupported,
    required this.tabletSupported,
    required this.mobileSupported,
    this.roles,
    this.clientIds,
    required this.menus,
  });

  factory DashboardMenuGroup.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'displayName', includeIfNull: false, defaultValue: '')
  final String displayName;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'webSupported', includeIfNull: false, defaultValue: true)
  final bool webSupported;
  @JsonKey(name: 'tabletSupported', includeIfNull: false, defaultValue: true)
  final bool tabletSupported;
  @JsonKey(name: 'mobileSupported', includeIfNull: false, defaultValue: true)
  final bool mobileSupported;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'menus', includeIfNull: false, defaultValue: <DashboardMenu>[])
  final List<DashboardMenu> menus;
  static const fromJsonFactory = _$DashboardMenuGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroup &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.webSupported, webSupported) ||
                const DeepCollectionEquality()
                    .equals(other.webSupported, webSupported)) &&
            (identical(other.tabletSupported, tabletSupported) ||
                const DeepCollectionEquality()
                    .equals(other.tabletSupported, tabletSupported)) &&
            (identical(other.mobileSupported, mobileSupported) ||
                const DeepCollectionEquality()
                    .equals(other.mobileSupported, mobileSupported)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.menus, menus) ||
                const DeepCollectionEquality().equals(other.menus, menus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(webSupported) ^
      const DeepCollectionEquality().hash(tabletSupported) ^
      const DeepCollectionEquality().hash(mobileSupported) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(menus) ^
      runtimeType.hashCode;
}

extension $DashboardMenuGroupExtension on DashboardMenuGroup {
  DashboardMenuGroup copyWith(
      {String? domainKey,
      String? id,
      String? name,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      List<String>? tags,
      String? displayName,
      String? description,
      String? icon,
      int? order,
      bool? webSupported,
      bool? tabletSupported,
      bool? mobileSupported,
      List<String>? roles,
      List<String>? clientIds,
      List<DashboardMenu>? menus}) {
    return DashboardMenuGroup(
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        name: name ?? this.name,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        tags: tags ?? this.tags,
        displayName: displayName ?? this.displayName,
        description: description ?? this.description,
        icon: icon ?? this.icon,
        order: order ?? this.order,
        webSupported: webSupported ?? this.webSupported,
        tabletSupported: tabletSupported ?? this.tabletSupported,
        mobileSupported: mobileSupported ?? this.mobileSupported,
        roles: roles ?? this.roles,
        clientIds: clientIds ?? this.clientIds,
        menus: menus ?? this.menus);
  }

  DashboardMenuGroup copyWithWrapped(
      {Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp,
      Wrapped<List<String>?>? tags,
      Wrapped<String>? displayName,
      Wrapped<String?>? description,
      Wrapped<String?>? icon,
      Wrapped<int?>? order,
      Wrapped<bool>? webSupported,
      Wrapped<bool>? tabletSupported,
      Wrapped<bool>? mobileSupported,
      Wrapped<List<String>?>? roles,
      Wrapped<List<String>?>? clientIds,
      Wrapped<List<DashboardMenu>>? menus}) {
    return DashboardMenuGroup(
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        tags: (tags != null ? tags.value : this.tags),
        displayName:
            (displayName != null ? displayName.value : this.displayName),
        description:
            (description != null ? description.value : this.description),
        icon: (icon != null ? icon.value : this.icon),
        order: (order != null ? order.value : this.order),
        webSupported:
            (webSupported != null ? webSupported.value : this.webSupported),
        tabletSupported: (tabletSupported != null
            ? tabletSupported.value
            : this.tabletSupported),
        mobileSupported: (mobileSupported != null
            ? mobileSupported.value
            : this.mobileSupported),
        roles: (roles != null ? roles.value : this.roles),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        menus: (menus != null ? menus.value : this.menus));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupEntity {
  const DashboardMenuGroupEntity({
    this.entity,
  });

  factory DashboardMenuGroupEntity.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupEntityFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupEntityToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DashboardMenuGroup? entity;
  static const fromJsonFactory = _$DashboardMenuGroupEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DashboardMenuGroupEntityExtension on DashboardMenuGroupEntity {
  DashboardMenuGroupEntity copyWith({DashboardMenuGroup? entity}) {
    return DashboardMenuGroupEntity(entity: entity ?? this.entity);
  }

  DashboardMenuGroupEntity copyWithWrapped(
      {Wrapped<DashboardMenuGroup?>? entity}) {
    return DashboardMenuGroupEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupEntityRes {
  const DashboardMenuGroupEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DashboardMenuGroupEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupEntityResFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupEntityResToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DashboardMenuGroup? entity;
  static const fromJsonFactory = _$DashboardMenuGroupEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DashboardMenuGroupEntityResExtension on DashboardMenuGroupEntityRes {
  DashboardMenuGroupEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      DashboardMenuGroup? entity}) {
    return DashboardMenuGroupEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  DashboardMenuGroupEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<DashboardMenuGroup?>? entity}) {
    return DashboardMenuGroupEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupArray {
  const DashboardMenuGroupArray({
    this.values,
  });

  factory DashboardMenuGroupArray.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupArrayFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupArrayToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupArrayToJson(this);

  @JsonKey(
      name: 'values',
      includeIfNull: false,
      defaultValue: <DashboardMenuGroup>[])
  final List<DashboardMenuGroup>? values;
  static const fromJsonFactory = _$DashboardMenuGroupArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DashboardMenuGroupArrayExtension on DashboardMenuGroupArray {
  DashboardMenuGroupArray copyWith({List<DashboardMenuGroup>? values}) {
    return DashboardMenuGroupArray(values: values ?? this.values);
  }

  DashboardMenuGroupArray copyWithWrapped(
      {Wrapped<List<DashboardMenuGroup>?>? values}) {
    return DashboardMenuGroupArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardMenuGroupArrayRes {
  const DashboardMenuGroupArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DashboardMenuGroupArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DashboardMenuGroupArrayResFromJson(json);

  static const toJsonFactory = _$DashboardMenuGroupArrayResToJson;
  Map<String, dynamic> toJson() => _$DashboardMenuGroupArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
      name: 'values',
      includeIfNull: false,
      defaultValue: <DashboardMenuGroup>[])
  final List<DashboardMenuGroup>? values;
  static const fromJsonFactory = _$DashboardMenuGroupArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardMenuGroupArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DashboardMenuGroupArrayResExtension on DashboardMenuGroupArrayRes {
  DashboardMenuGroupArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<DashboardMenuGroup>? values}) {
    return DashboardMenuGroupArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  DashboardMenuGroupArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<DashboardMenuGroup>?>? values}) {
    return DashboardMenuGroupArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class PaddingConfig {
  const PaddingConfig({
    this.left,
    this.top,
    this.right,
    this.bottom,
  });

  factory PaddingConfig.fromJson(Map<String, dynamic> json) =>
      _$PaddingConfigFromJson(json);

  static const toJsonFactory = _$PaddingConfigToJson;
  Map<String, dynamic> toJson() => _$PaddingConfigToJson(this);

  @JsonKey(name: 'left', includeIfNull: false)
  final double? left;
  @JsonKey(name: 'top', includeIfNull: false)
  final double? top;
  @JsonKey(name: 'right', includeIfNull: false)
  final double? right;
  @JsonKey(name: 'bottom', includeIfNull: false)
  final double? bottom;
  static const fromJsonFactory = _$PaddingConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PaddingConfig &&
            (identical(other.left, left) ||
                const DeepCollectionEquality().equals(other.left, left)) &&
            (identical(other.top, top) ||
                const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)) &&
            (identical(other.bottom, bottom) ||
                const DeepCollectionEquality().equals(other.bottom, bottom)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(left) ^
      const DeepCollectionEquality().hash(top) ^
      const DeepCollectionEquality().hash(right) ^
      const DeepCollectionEquality().hash(bottom) ^
      runtimeType.hashCode;
}

extension $PaddingConfigExtension on PaddingConfig {
  PaddingConfig copyWith(
      {double? left, double? top, double? right, double? bottom}) {
    return PaddingConfig(
        left: left ?? this.left,
        top: top ?? this.top,
        right: right ?? this.right,
        bottom: bottom ?? this.bottom);
  }

  PaddingConfig copyWithWrapped(
      {Wrapped<double?>? left,
      Wrapped<double?>? top,
      Wrapped<double?>? right,
      Wrapped<double?>? bottom}) {
    return PaddingConfig(
        left: (left != null ? left.value : this.left),
        top: (top != null ? top.value : this.top),
        right: (right != null ? right.value : this.right),
        bottom: (bottom != null ? bottom.value : this.bottom));
  }
}

@JsonSerializable(explicitToJson: true)
class RadiusConfig {
  const RadiusConfig({
    required this.radType,
    this.rad,
    this.xRad,
    this.yRad,
  });

  factory RadiusConfig.fromJson(Map<String, dynamic> json) =>
      _$RadiusConfigFromJson(json);

  static const toJsonFactory = _$RadiusConfigToJson;
  Map<String, dynamic> toJson() => _$RadiusConfigToJson(this);

  @JsonKey(
    name: 'radType',
    includeIfNull: false,
    toJson: radiusConfigRadTypeToJson,
    fromJson: radiusConfigRadTypeFromJson,
  )
  final enums.RadiusConfigRadType radType;
  @JsonKey(name: 'rad', includeIfNull: false)
  final double? rad;
  @JsonKey(name: 'xRad', includeIfNull: false)
  final double? xRad;
  @JsonKey(name: 'yRad', includeIfNull: false)
  final double? yRad;
  static const fromJsonFactory = _$RadiusConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RadiusConfig &&
            (identical(other.radType, radType) ||
                const DeepCollectionEquality()
                    .equals(other.radType, radType)) &&
            (identical(other.rad, rad) ||
                const DeepCollectionEquality().equals(other.rad, rad)) &&
            (identical(other.xRad, xRad) ||
                const DeepCollectionEquality().equals(other.xRad, xRad)) &&
            (identical(other.yRad, yRad) ||
                const DeepCollectionEquality().equals(other.yRad, yRad)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(radType) ^
      const DeepCollectionEquality().hash(rad) ^
      const DeepCollectionEquality().hash(xRad) ^
      const DeepCollectionEquality().hash(yRad) ^
      runtimeType.hashCode;
}

extension $RadiusConfigExtension on RadiusConfig {
  RadiusConfig copyWith(
      {enums.RadiusConfigRadType? radType,
      double? rad,
      double? xRad,
      double? yRad}) {
    return RadiusConfig(
        radType: radType ?? this.radType,
        rad: rad ?? this.rad,
        xRad: xRad ?? this.xRad,
        yRad: yRad ?? this.yRad);
  }

  RadiusConfig copyWithWrapped(
      {Wrapped<enums.RadiusConfigRadType>? radType,
      Wrapped<double?>? rad,
      Wrapped<double?>? xRad,
      Wrapped<double?>? yRad}) {
    return RadiusConfig(
        radType: (radType != null ? radType.value : this.radType),
        rad: (rad != null ? rad.value : this.rad),
        xRad: (xRad != null ? xRad.value : this.xRad),
        yRad: (yRad != null ? yRad.value : this.yRad));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageFitConfig {
  const ImageFitConfig({
    required this.fit,
  });

  factory ImageFitConfig.fromJson(Map<String, dynamic> json) =>
      _$ImageFitConfigFromJson(json);

  static const toJsonFactory = _$ImageFitConfigToJson;
  Map<String, dynamic> toJson() => _$ImageFitConfigToJson(this);

  @JsonKey(
    name: 'fit',
    includeIfNull: false,
    toJson: imageFitConfigFitToJson,
    fromJson: imageFitConfigFitFromJson,
  )
  final enums.ImageFitConfigFit fit;
  static const fromJsonFactory = _$ImageFitConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageFitConfig &&
            (identical(other.fit, fit) ||
                const DeepCollectionEquality().equals(other.fit, fit)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fit) ^ runtimeType.hashCode;
}

extension $ImageFitConfigExtension on ImageFitConfig {
  ImageFitConfig copyWith({enums.ImageFitConfigFit? fit}) {
    return ImageFitConfig(fit: fit ?? this.fit);
  }

  ImageFitConfig copyWithWrapped({Wrapped<enums.ImageFitConfigFit>? fit}) {
    return ImageFitConfig(fit: (fit != null ? fit.value : this.fit));
  }
}

@JsonSerializable(explicitToJson: true)
class AlignmentConfig {
  const AlignmentConfig({
    required this.alignment,
  });

  factory AlignmentConfig.fromJson(Map<String, dynamic> json) =>
      _$AlignmentConfigFromJson(json);

  static const toJsonFactory = _$AlignmentConfigToJson;
  Map<String, dynamic> toJson() => _$AlignmentConfigToJson(this);

  @JsonKey(
    name: 'alignment',
    includeIfNull: false,
    toJson: alignmentConfigAlignmentToJson,
    fromJson: alignmentConfigAlignmentFromJson,
  )
  final enums.AlignmentConfigAlignment alignment;
  static const fromJsonFactory = _$AlignmentConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlignmentConfig &&
            (identical(other.alignment, alignment) ||
                const DeepCollectionEquality()
                    .equals(other.alignment, alignment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(alignment) ^ runtimeType.hashCode;
}

extension $AlignmentConfigExtension on AlignmentConfig {
  AlignmentConfig copyWith({enums.AlignmentConfigAlignment? alignment}) {
    return AlignmentConfig(alignment: alignment ?? this.alignment);
  }

  AlignmentConfig copyWithWrapped(
      {Wrapped<enums.AlignmentConfigAlignment>? alignment}) {
    return AlignmentConfig(
        alignment: (alignment != null ? alignment.value : this.alignment));
  }
}

@JsonSerializable(explicitToJson: true)
class BorderConfig {
  const BorderConfig({
    required this.type,
    this.color,
    this.width,
    this.allRadius,
    this.leftRadius,
    this.rightRadius,
    this.topRadius,
    this.bottomRadius,
    this.topLeftRadius,
    this.bottomLeftRadius,
    this.topRightRadius,
    this.bottomRightRadius,
    this.circularRadius,
  });

  factory BorderConfig.fromJson(Map<String, dynamic> json) =>
      _$BorderConfigFromJson(json);

  static const toJsonFactory = _$BorderConfigToJson;
  Map<String, dynamic> toJson() => _$BorderConfigToJson(this);

  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: borderConfigTypeToJson,
    fromJson: borderConfigTypeFromJson,
  )
  final enums.BorderConfigType type;
  @JsonKey(name: 'color', includeIfNull: false)
  final int? color;
  @JsonKey(name: 'width', includeIfNull: false)
  final double? width;
  @JsonKey(name: 'allRadius', includeIfNull: false)
  final RadiusConfig? allRadius;
  @JsonKey(name: 'leftRadius', includeIfNull: false)
  final RadiusConfig? leftRadius;
  @JsonKey(name: 'rightRadius', includeIfNull: false)
  final RadiusConfig? rightRadius;
  @JsonKey(name: 'topRadius', includeIfNull: false)
  final RadiusConfig? topRadius;
  @JsonKey(name: 'bottomRadius', includeIfNull: false)
  final RadiusConfig? bottomRadius;
  @JsonKey(name: 'topLeftRadius', includeIfNull: false)
  final RadiusConfig? topLeftRadius;
  @JsonKey(name: 'bottomLeftRadius', includeIfNull: false)
  final RadiusConfig? bottomLeftRadius;
  @JsonKey(name: 'topRightRadius', includeIfNull: false)
  final RadiusConfig? topRightRadius;
  @JsonKey(name: 'bottomRightRadius', includeIfNull: false)
  final RadiusConfig? bottomRightRadius;
  @JsonKey(name: 'circularRadius', includeIfNull: false)
  final double? circularRadius;
  static const fromJsonFactory = _$BorderConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BorderConfig &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.color, color) ||
                const DeepCollectionEquality().equals(other.color, color)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.allRadius, allRadius) ||
                const DeepCollectionEquality()
                    .equals(other.allRadius, allRadius)) &&
            (identical(other.leftRadius, leftRadius) ||
                const DeepCollectionEquality()
                    .equals(other.leftRadius, leftRadius)) &&
            (identical(other.rightRadius, rightRadius) ||
                const DeepCollectionEquality()
                    .equals(other.rightRadius, rightRadius)) &&
            (identical(other.topRadius, topRadius) ||
                const DeepCollectionEquality()
                    .equals(other.topRadius, topRadius)) &&
            (identical(other.bottomRadius, bottomRadius) ||
                const DeepCollectionEquality()
                    .equals(other.bottomRadius, bottomRadius)) &&
            (identical(other.topLeftRadius, topLeftRadius) ||
                const DeepCollectionEquality()
                    .equals(other.topLeftRadius, topLeftRadius)) &&
            (identical(other.bottomLeftRadius, bottomLeftRadius) ||
                const DeepCollectionEquality()
                    .equals(other.bottomLeftRadius, bottomLeftRadius)) &&
            (identical(other.topRightRadius, topRightRadius) ||
                const DeepCollectionEquality()
                    .equals(other.topRightRadius, topRightRadius)) &&
            (identical(other.bottomRightRadius, bottomRightRadius) ||
                const DeepCollectionEquality()
                    .equals(other.bottomRightRadius, bottomRightRadius)) &&
            (identical(other.circularRadius, circularRadius) ||
                const DeepCollectionEquality()
                    .equals(other.circularRadius, circularRadius)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(color) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(allRadius) ^
      const DeepCollectionEquality().hash(leftRadius) ^
      const DeepCollectionEquality().hash(rightRadius) ^
      const DeepCollectionEquality().hash(topRadius) ^
      const DeepCollectionEquality().hash(bottomRadius) ^
      const DeepCollectionEquality().hash(topLeftRadius) ^
      const DeepCollectionEquality().hash(bottomLeftRadius) ^
      const DeepCollectionEquality().hash(topRightRadius) ^
      const DeepCollectionEquality().hash(bottomRightRadius) ^
      const DeepCollectionEquality().hash(circularRadius) ^
      runtimeType.hashCode;
}

extension $BorderConfigExtension on BorderConfig {
  BorderConfig copyWith(
      {enums.BorderConfigType? type,
      int? color,
      double? width,
      RadiusConfig? allRadius,
      RadiusConfig? leftRadius,
      RadiusConfig? rightRadius,
      RadiusConfig? topRadius,
      RadiusConfig? bottomRadius,
      RadiusConfig? topLeftRadius,
      RadiusConfig? bottomLeftRadius,
      RadiusConfig? topRightRadius,
      RadiusConfig? bottomRightRadius,
      double? circularRadius}) {
    return BorderConfig(
        type: type ?? this.type,
        color: color ?? this.color,
        width: width ?? this.width,
        allRadius: allRadius ?? this.allRadius,
        leftRadius: leftRadius ?? this.leftRadius,
        rightRadius: rightRadius ?? this.rightRadius,
        topRadius: topRadius ?? this.topRadius,
        bottomRadius: bottomRadius ?? this.bottomRadius,
        topLeftRadius: topLeftRadius ?? this.topLeftRadius,
        bottomLeftRadius: bottomLeftRadius ?? this.bottomLeftRadius,
        topRightRadius: topRightRadius ?? this.topRightRadius,
        bottomRightRadius: bottomRightRadius ?? this.bottomRightRadius,
        circularRadius: circularRadius ?? this.circularRadius);
  }

  BorderConfig copyWithWrapped(
      {Wrapped<enums.BorderConfigType>? type,
      Wrapped<int?>? color,
      Wrapped<double?>? width,
      Wrapped<RadiusConfig?>? allRadius,
      Wrapped<RadiusConfig?>? leftRadius,
      Wrapped<RadiusConfig?>? rightRadius,
      Wrapped<RadiusConfig?>? topRadius,
      Wrapped<RadiusConfig?>? bottomRadius,
      Wrapped<RadiusConfig?>? topLeftRadius,
      Wrapped<RadiusConfig?>? bottomLeftRadius,
      Wrapped<RadiusConfig?>? topRightRadius,
      Wrapped<RadiusConfig?>? bottomRightRadius,
      Wrapped<double?>? circularRadius}) {
    return BorderConfig(
        type: (type != null ? type.value : this.type),
        color: (color != null ? color.value : this.color),
        width: (width != null ? width.value : this.width),
        allRadius: (allRadius != null ? allRadius.value : this.allRadius),
        leftRadius: (leftRadius != null ? leftRadius.value : this.leftRadius),
        rightRadius:
            (rightRadius != null ? rightRadius.value : this.rightRadius),
        topRadius: (topRadius != null ? topRadius.value : this.topRadius),
        bottomRadius:
            (bottomRadius != null ? bottomRadius.value : this.bottomRadius),
        topLeftRadius:
            (topLeftRadius != null ? topLeftRadius.value : this.topLeftRadius),
        bottomLeftRadius: (bottomLeftRadius != null
            ? bottomLeftRadius.value
            : this.bottomLeftRadius),
        topRightRadius: (topRightRadius != null
            ? topRightRadius.value
            : this.topRightRadius),
        bottomRightRadius: (bottomRightRadius != null
            ? bottomRightRadius.value
            : this.bottomRightRadius),
        circularRadius: (circularRadius != null
            ? circularRadius.value
            : this.circularRadius));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinFontConfig {
  const TwinFontConfig({
    this.fontFamily,
    this.fontColor,
    this.fontSize,
    this.fontBold,
  });

  factory TwinFontConfig.fromJson(Map<String, dynamic> json) =>
      _$TwinFontConfigFromJson(json);

  static const toJsonFactory = _$TwinFontConfigToJson;
  Map<String, dynamic> toJson() => _$TwinFontConfigToJson(this);

  @JsonKey(name: 'fontFamily', includeIfNull: false, defaultValue: '')
  final String? fontFamily;
  @JsonKey(name: 'fontColor', includeIfNull: false)
  final int? fontColor;
  @JsonKey(name: 'fontSize', includeIfNull: false)
  final double? fontSize;
  @JsonKey(name: 'fontBold', includeIfNull: false)
  final bool? fontBold;
  static const fromJsonFactory = _$TwinFontConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinFontConfig &&
            (identical(other.fontFamily, fontFamily) ||
                const DeepCollectionEquality()
                    .equals(other.fontFamily, fontFamily)) &&
            (identical(other.fontColor, fontColor) ||
                const DeepCollectionEquality()
                    .equals(other.fontColor, fontColor)) &&
            (identical(other.fontSize, fontSize) ||
                const DeepCollectionEquality()
                    .equals(other.fontSize, fontSize)) &&
            (identical(other.fontBold, fontBold) ||
                const DeepCollectionEquality()
                    .equals(other.fontBold, fontBold)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fontFamily) ^
      const DeepCollectionEquality().hash(fontColor) ^
      const DeepCollectionEquality().hash(fontSize) ^
      const DeepCollectionEquality().hash(fontBold) ^
      runtimeType.hashCode;
}

extension $TwinFontConfigExtension on TwinFontConfig {
  TwinFontConfig copyWith(
      {String? fontFamily, int? fontColor, double? fontSize, bool? fontBold}) {
    return TwinFontConfig(
        fontFamily: fontFamily ?? this.fontFamily,
        fontColor: fontColor ?? this.fontColor,
        fontSize: fontSize ?? this.fontSize,
        fontBold: fontBold ?? this.fontBold);
  }

  TwinFontConfig copyWithWrapped(
      {Wrapped<String?>? fontFamily,
      Wrapped<int?>? fontColor,
      Wrapped<double?>? fontSize,
      Wrapped<bool?>? fontBold}) {
    return TwinFontConfig(
        fontFamily: (fontFamily != null ? fontFamily.value : this.fontFamily),
        fontColor: (fontColor != null ? fontColor.value : this.fontColor),
        fontSize: (fontSize != null ? fontSize.value : this.fontSize),
        fontBold: (fontBold != null ? fontBold.value : this.fontBold));
  }
}

@JsonSerializable(explicitToJson: true)
class TitleConfig {
  const TitleConfig({
    this.title,
    this.bgColor,
    this.titleFont,
    this.titleAlignment,
  });

  factory TitleConfig.fromJson(Map<String, dynamic> json) =>
      _$TitleConfigFromJson(json);

  static const toJsonFactory = _$TitleConfigToJson;
  Map<String, dynamic> toJson() => _$TitleConfigToJson(this);

  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'titleFont', includeIfNull: false)
  final TwinFontConfig? titleFont;
  @JsonKey(name: 'titleAlignment', includeIfNull: false)
  final AlignmentConfig? titleAlignment;
  static const fromJsonFactory = _$TitleConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TitleConfig &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.titleFont, titleFont) ||
                const DeepCollectionEquality()
                    .equals(other.titleFont, titleFont)) &&
            (identical(other.titleAlignment, titleAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.titleAlignment, titleAlignment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(titleFont) ^
      const DeepCollectionEquality().hash(titleAlignment) ^
      runtimeType.hashCode;
}

extension $TitleConfigExtension on TitleConfig {
  TitleConfig copyWith(
      {String? title,
      int? bgColor,
      TwinFontConfig? titleFont,
      AlignmentConfig? titleAlignment}) {
    return TitleConfig(
        title: title ?? this.title,
        bgColor: bgColor ?? this.bgColor,
        titleFont: titleFont ?? this.titleFont,
        titleAlignment: titleAlignment ?? this.titleAlignment);
  }

  TitleConfig copyWithWrapped(
      {Wrapped<String?>? title,
      Wrapped<int?>? bgColor,
      Wrapped<TwinFontConfig?>? titleFont,
      Wrapped<AlignmentConfig?>? titleAlignment}) {
    return TitleConfig(
        title: (title != null ? title.value : this.title),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        titleFont: (titleFont != null ? titleFont.value : this.titleFont),
        titleAlignment: (titleAlignment != null
            ? titleAlignment.value
            : this.titleAlignment));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenChild {
  const ScreenChild({
    required this.widgetId,
    required this.config,
    this.width,
    this.height,
    this.bgColor,
    this.bgImage,
    this.expanded,
    this.flex,
    this.titleConfig,
    this.titleAlignment,
    this.bgImageFit,
    this.paddingConfig,
    this.marginConfig,
    this.childBorderConfig,
    this.alignment,
  });

  factory ScreenChild.fromJson(Map<String, dynamic> json) =>
      _$ScreenChildFromJson(json);

  static const toJsonFactory = _$ScreenChildToJson;
  Map<String, dynamic> toJson() => _$ScreenChildToJson(this);

  @JsonKey(name: 'widgetId', includeIfNull: false, defaultValue: '')
  final String widgetId;
  @JsonKey(name: 'config', includeIfNull: false)
  final Object config;
  @JsonKey(name: 'width', includeIfNull: false)
  final double? width;
  @JsonKey(name: 'height', includeIfNull: false)
  final double? height;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'bgImage', includeIfNull: false, defaultValue: '')
  final String? bgImage;
  @JsonKey(name: 'expanded', includeIfNull: false)
  final bool? expanded;
  @JsonKey(name: 'flex', includeIfNull: false)
  final int? flex;
  @JsonKey(name: 'titleConfig', includeIfNull: false)
  final TitleConfig? titleConfig;
  @JsonKey(name: 'titleAlignment', includeIfNull: false)
  final AlignmentConfig? titleAlignment;
  @JsonKey(name: 'bgImageFit', includeIfNull: false)
  final ImageFitConfig? bgImageFit;
  @JsonKey(name: 'paddingConfig', includeIfNull: false)
  final PaddingConfig? paddingConfig;
  @JsonKey(name: 'marginConfig', includeIfNull: false)
  final PaddingConfig? marginConfig;
  @JsonKey(name: 'childBorderConfig', includeIfNull: false)
  final BorderConfig? childBorderConfig;
  @JsonKey(name: 'alignment', includeIfNull: false)
  final AlignmentConfig? alignment;
  static const fromJsonFactory = _$ScreenChildFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenChild &&
            (identical(other.widgetId, widgetId) ||
                const DeepCollectionEquality()
                    .equals(other.widgetId, widgetId)) &&
            (identical(other.config, config) ||
                const DeepCollectionEquality().equals(other.config, config)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.bgImage, bgImage) ||
                const DeepCollectionEquality()
                    .equals(other.bgImage, bgImage)) &&
            (identical(other.expanded, expanded) ||
                const DeepCollectionEquality()
                    .equals(other.expanded, expanded)) &&
            (identical(other.flex, flex) ||
                const DeepCollectionEquality().equals(other.flex, flex)) &&
            (identical(other.titleConfig, titleConfig) ||
                const DeepCollectionEquality()
                    .equals(other.titleConfig, titleConfig)) &&
            (identical(other.titleAlignment, titleAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.titleAlignment, titleAlignment)) &&
            (identical(other.bgImageFit, bgImageFit) ||
                const DeepCollectionEquality()
                    .equals(other.bgImageFit, bgImageFit)) &&
            (identical(other.paddingConfig, paddingConfig) ||
                const DeepCollectionEquality()
                    .equals(other.paddingConfig, paddingConfig)) &&
            (identical(other.marginConfig, marginConfig) ||
                const DeepCollectionEquality()
                    .equals(other.marginConfig, marginConfig)) &&
            (identical(other.childBorderConfig, childBorderConfig) ||
                const DeepCollectionEquality()
                    .equals(other.childBorderConfig, childBorderConfig)) &&
            (identical(other.alignment, alignment) ||
                const DeepCollectionEquality()
                    .equals(other.alignment, alignment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(widgetId) ^
      const DeepCollectionEquality().hash(config) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(bgImage) ^
      const DeepCollectionEquality().hash(expanded) ^
      const DeepCollectionEquality().hash(flex) ^
      const DeepCollectionEquality().hash(titleConfig) ^
      const DeepCollectionEquality().hash(titleAlignment) ^
      const DeepCollectionEquality().hash(bgImageFit) ^
      const DeepCollectionEquality().hash(paddingConfig) ^
      const DeepCollectionEquality().hash(marginConfig) ^
      const DeepCollectionEquality().hash(childBorderConfig) ^
      const DeepCollectionEquality().hash(alignment) ^
      runtimeType.hashCode;
}

extension $ScreenChildExtension on ScreenChild {
  ScreenChild copyWith(
      {String? widgetId,
      Object? config,
      double? width,
      double? height,
      int? bgColor,
      String? bgImage,
      bool? expanded,
      int? flex,
      TitleConfig? titleConfig,
      AlignmentConfig? titleAlignment,
      ImageFitConfig? bgImageFit,
      PaddingConfig? paddingConfig,
      PaddingConfig? marginConfig,
      BorderConfig? childBorderConfig,
      AlignmentConfig? alignment}) {
    return ScreenChild(
        widgetId: widgetId ?? this.widgetId,
        config: config ?? this.config,
        width: width ?? this.width,
        height: height ?? this.height,
        bgColor: bgColor ?? this.bgColor,
        bgImage: bgImage ?? this.bgImage,
        expanded: expanded ?? this.expanded,
        flex: flex ?? this.flex,
        titleConfig: titleConfig ?? this.titleConfig,
        titleAlignment: titleAlignment ?? this.titleAlignment,
        bgImageFit: bgImageFit ?? this.bgImageFit,
        paddingConfig: paddingConfig ?? this.paddingConfig,
        marginConfig: marginConfig ?? this.marginConfig,
        childBorderConfig: childBorderConfig ?? this.childBorderConfig,
        alignment: alignment ?? this.alignment);
  }

  ScreenChild copyWithWrapped(
      {Wrapped<String>? widgetId,
      Wrapped<Object>? config,
      Wrapped<double?>? width,
      Wrapped<double?>? height,
      Wrapped<int?>? bgColor,
      Wrapped<String?>? bgImage,
      Wrapped<bool?>? expanded,
      Wrapped<int?>? flex,
      Wrapped<TitleConfig?>? titleConfig,
      Wrapped<AlignmentConfig?>? titleAlignment,
      Wrapped<ImageFitConfig?>? bgImageFit,
      Wrapped<PaddingConfig?>? paddingConfig,
      Wrapped<PaddingConfig?>? marginConfig,
      Wrapped<BorderConfig?>? childBorderConfig,
      Wrapped<AlignmentConfig?>? alignment}) {
    return ScreenChild(
        widgetId: (widgetId != null ? widgetId.value : this.widgetId),
        config: (config != null ? config.value : this.config),
        width: (width != null ? width.value : this.width),
        height: (height != null ? height.value : this.height),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        bgImage: (bgImage != null ? bgImage.value : this.bgImage),
        expanded: (expanded != null ? expanded.value : this.expanded),
        flex: (flex != null ? flex.value : this.flex),
        titleConfig:
            (titleConfig != null ? titleConfig.value : this.titleConfig),
        titleAlignment: (titleAlignment != null
            ? titleAlignment.value
            : this.titleAlignment),
        bgImageFit: (bgImageFit != null ? bgImageFit.value : this.bgImageFit),
        paddingConfig:
            (paddingConfig != null ? paddingConfig.value : this.paddingConfig),
        marginConfig:
            (marginConfig != null ? marginConfig.value : this.marginConfig),
        childBorderConfig: (childBorderConfig != null
            ? childBorderConfig.value
            : this.childBorderConfig),
        alignment: (alignment != null ? alignment.value : this.alignment));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenRow {
  const ScreenRow({
    this.height,
    this.spacing,
    this.bgColor,
    this.bgImage,
    this.mainAxisAlignment,
    this.crossAxisAlignment,
    this.mainAxisSize,
    this.scrollDirection,
    this.titleConfig,
    this.bgImageFit,
    this.paddingConfig,
    this.marginConfig,
    this.rowBorderConfig,
    required this.children,
  });

  factory ScreenRow.fromJson(Map<String, dynamic> json) =>
      _$ScreenRowFromJson(json);

  static const toJsonFactory = _$ScreenRowToJson;
  Map<String, dynamic> toJson() => _$ScreenRowToJson(this);

  @JsonKey(name: 'height', includeIfNull: false)
  final double? height;
  @JsonKey(name: 'spacing', includeIfNull: false)
  final double? spacing;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'bgImage', includeIfNull: false, defaultValue: '')
  final String? bgImage;
  @JsonKey(name: 'mainAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? mainAxisAlignment;
  @JsonKey(name: 'crossAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? crossAxisAlignment;
  @JsonKey(name: 'mainAxisSize', includeIfNull: false, defaultValue: '')
  final String? mainAxisSize;
  @JsonKey(name: 'scrollDirection', includeIfNull: false, defaultValue: '')
  final String? scrollDirection;
  @JsonKey(name: 'titleConfig', includeIfNull: false)
  final TitleConfig? titleConfig;
  @JsonKey(name: 'bgImageFit', includeIfNull: false)
  final ImageFitConfig? bgImageFit;
  @JsonKey(name: 'paddingConfig', includeIfNull: false)
  final PaddingConfig? paddingConfig;
  @JsonKey(name: 'marginConfig', includeIfNull: false)
  final PaddingConfig? marginConfig;
  @JsonKey(name: 'rowBorderConfig', includeIfNull: false)
  final BorderConfig? rowBorderConfig;
  @JsonKey(
      name: 'children', includeIfNull: false, defaultValue: <ScreenChild>[])
  final List<ScreenChild> children;
  static const fromJsonFactory = _$ScreenRowFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenRow &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.spacing, spacing) ||
                const DeepCollectionEquality()
                    .equals(other.spacing, spacing)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.bgImage, bgImage) ||
                const DeepCollectionEquality()
                    .equals(other.bgImage, bgImage)) &&
            (identical(other.mainAxisAlignment, mainAxisAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.mainAxisAlignment, mainAxisAlignment)) &&
            (identical(other.crossAxisAlignment, crossAxisAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.crossAxisAlignment, crossAxisAlignment)) &&
            (identical(other.mainAxisSize, mainAxisSize) ||
                const DeepCollectionEquality()
                    .equals(other.mainAxisSize, mainAxisSize)) &&
            (identical(other.scrollDirection, scrollDirection) ||
                const DeepCollectionEquality()
                    .equals(other.scrollDirection, scrollDirection)) &&
            (identical(other.titleConfig, titleConfig) ||
                const DeepCollectionEquality()
                    .equals(other.titleConfig, titleConfig)) &&
            (identical(other.bgImageFit, bgImageFit) ||
                const DeepCollectionEquality()
                    .equals(other.bgImageFit, bgImageFit)) &&
            (identical(other.paddingConfig, paddingConfig) ||
                const DeepCollectionEquality()
                    .equals(other.paddingConfig, paddingConfig)) &&
            (identical(other.marginConfig, marginConfig) ||
                const DeepCollectionEquality()
                    .equals(other.marginConfig, marginConfig)) &&
            (identical(other.rowBorderConfig, rowBorderConfig) ||
                const DeepCollectionEquality()
                    .equals(other.rowBorderConfig, rowBorderConfig)) &&
            (identical(other.children, children) ||
                const DeepCollectionEquality()
                    .equals(other.children, children)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(spacing) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(bgImage) ^
      const DeepCollectionEquality().hash(mainAxisAlignment) ^
      const DeepCollectionEquality().hash(crossAxisAlignment) ^
      const DeepCollectionEquality().hash(mainAxisSize) ^
      const DeepCollectionEquality().hash(scrollDirection) ^
      const DeepCollectionEquality().hash(titleConfig) ^
      const DeepCollectionEquality().hash(bgImageFit) ^
      const DeepCollectionEquality().hash(paddingConfig) ^
      const DeepCollectionEquality().hash(marginConfig) ^
      const DeepCollectionEquality().hash(rowBorderConfig) ^
      const DeepCollectionEquality().hash(children) ^
      runtimeType.hashCode;
}

extension $ScreenRowExtension on ScreenRow {
  ScreenRow copyWith(
      {double? height,
      double? spacing,
      int? bgColor,
      String? bgImage,
      String? mainAxisAlignment,
      String? crossAxisAlignment,
      String? mainAxisSize,
      String? scrollDirection,
      TitleConfig? titleConfig,
      ImageFitConfig? bgImageFit,
      PaddingConfig? paddingConfig,
      PaddingConfig? marginConfig,
      BorderConfig? rowBorderConfig,
      List<ScreenChild>? children}) {
    return ScreenRow(
        height: height ?? this.height,
        spacing: spacing ?? this.spacing,
        bgColor: bgColor ?? this.bgColor,
        bgImage: bgImage ?? this.bgImage,
        mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
        crossAxisAlignment: crossAxisAlignment ?? this.crossAxisAlignment,
        mainAxisSize: mainAxisSize ?? this.mainAxisSize,
        scrollDirection: scrollDirection ?? this.scrollDirection,
        titleConfig: titleConfig ?? this.titleConfig,
        bgImageFit: bgImageFit ?? this.bgImageFit,
        paddingConfig: paddingConfig ?? this.paddingConfig,
        marginConfig: marginConfig ?? this.marginConfig,
        rowBorderConfig: rowBorderConfig ?? this.rowBorderConfig,
        children: children ?? this.children);
  }

  ScreenRow copyWithWrapped(
      {Wrapped<double?>? height,
      Wrapped<double?>? spacing,
      Wrapped<int?>? bgColor,
      Wrapped<String?>? bgImage,
      Wrapped<String?>? mainAxisAlignment,
      Wrapped<String?>? crossAxisAlignment,
      Wrapped<String?>? mainAxisSize,
      Wrapped<String?>? scrollDirection,
      Wrapped<TitleConfig?>? titleConfig,
      Wrapped<ImageFitConfig?>? bgImageFit,
      Wrapped<PaddingConfig?>? paddingConfig,
      Wrapped<PaddingConfig?>? marginConfig,
      Wrapped<BorderConfig?>? rowBorderConfig,
      Wrapped<List<ScreenChild>>? children}) {
    return ScreenRow(
        height: (height != null ? height.value : this.height),
        spacing: (spacing != null ? spacing.value : this.spacing),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        bgImage: (bgImage != null ? bgImage.value : this.bgImage),
        mainAxisAlignment: (mainAxisAlignment != null
            ? mainAxisAlignment.value
            : this.mainAxisAlignment),
        crossAxisAlignment: (crossAxisAlignment != null
            ? crossAxisAlignment.value
            : this.crossAxisAlignment),
        mainAxisSize:
            (mainAxisSize != null ? mainAxisSize.value : this.mainAxisSize),
        scrollDirection: (scrollDirection != null
            ? scrollDirection.value
            : this.scrollDirection),
        titleConfig:
            (titleConfig != null ? titleConfig.value : this.titleConfig),
        bgImageFit: (bgImageFit != null ? bgImageFit.value : this.bgImageFit),
        paddingConfig:
            (paddingConfig != null ? paddingConfig.value : this.paddingConfig),
        marginConfig:
            (marginConfig != null ? marginConfig.value : this.marginConfig),
        rowBorderConfig: (rowBorderConfig != null
            ? rowBorderConfig.value
            : this.rowBorderConfig),
        children: (children != null ? children.value : this.children));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenInfo {
  const DashboardScreenInfo({
    required this.name,
    this.description,
    this.bannerImage,
    this.spacing,
    this.tags,
    this.bgColor,
    this.bgImage,
    this.mainAxisAlignment,
    this.crossAxisAlignment,
    this.mainAxisSize,
    this.scrollDirection,
    this.bannerHeight,
    this.titleConfig,
    this.bannerImageFit,
    this.bgImageFit,
    this.screenBorderConfig,
    this.paddingConfig,
    this.marginConfig,
    required this.rows,
  });

  factory DashboardScreenInfo.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenInfoFromJson(json);

  static const toJsonFactory = _$DashboardScreenInfoToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'bannerImage', includeIfNull: false, defaultValue: '')
  final String? bannerImage;
  @JsonKey(name: 'spacing', includeIfNull: false)
  final double? spacing;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'bgImage', includeIfNull: false, defaultValue: '')
  final String? bgImage;
  @JsonKey(name: 'mainAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? mainAxisAlignment;
  @JsonKey(name: 'crossAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? crossAxisAlignment;
  @JsonKey(name: 'mainAxisSize', includeIfNull: false, defaultValue: '')
  final String? mainAxisSize;
  @JsonKey(name: 'scrollDirection', includeIfNull: false, defaultValue: '')
  final String? scrollDirection;
  @JsonKey(name: 'bannerHeight', includeIfNull: false)
  final double? bannerHeight;
  @JsonKey(name: 'titleConfig', includeIfNull: false)
  final TitleConfig? titleConfig;
  @JsonKey(name: 'bannerImageFit', includeIfNull: false)
  final ImageFitConfig? bannerImageFit;
  @JsonKey(name: 'bgImageFit', includeIfNull: false)
  final ImageFitConfig? bgImageFit;
  @JsonKey(name: 'screenBorderConfig', includeIfNull: false)
  final BorderConfig? screenBorderConfig;
  @JsonKey(name: 'paddingConfig', includeIfNull: false)
  final PaddingConfig? paddingConfig;
  @JsonKey(name: 'marginConfig', includeIfNull: false)
  final PaddingConfig? marginConfig;
  @JsonKey(name: 'rows', includeIfNull: false, defaultValue: <ScreenRow>[])
  final List<ScreenRow> rows;
  static const fromJsonFactory = _$DashboardScreenInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.bannerImage, bannerImage) ||
                const DeepCollectionEquality()
                    .equals(other.bannerImage, bannerImage)) &&
            (identical(other.spacing, spacing) ||
                const DeepCollectionEquality()
                    .equals(other.spacing, spacing)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.bgImage, bgImage) ||
                const DeepCollectionEquality()
                    .equals(other.bgImage, bgImage)) &&
            (identical(other.mainAxisAlignment, mainAxisAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.mainAxisAlignment, mainAxisAlignment)) &&
            (identical(other.crossAxisAlignment, crossAxisAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.crossAxisAlignment, crossAxisAlignment)) &&
            (identical(other.mainAxisSize, mainAxisSize) ||
                const DeepCollectionEquality()
                    .equals(other.mainAxisSize, mainAxisSize)) &&
            (identical(other.scrollDirection, scrollDirection) ||
                const DeepCollectionEquality()
                    .equals(other.scrollDirection, scrollDirection)) &&
            (identical(other.bannerHeight, bannerHeight) ||
                const DeepCollectionEquality()
                    .equals(other.bannerHeight, bannerHeight)) &&
            (identical(other.titleConfig, titleConfig) ||
                const DeepCollectionEquality()
                    .equals(other.titleConfig, titleConfig)) &&
            (identical(other.bannerImageFit, bannerImageFit) ||
                const DeepCollectionEquality()
                    .equals(other.bannerImageFit, bannerImageFit)) &&
            (identical(other.bgImageFit, bgImageFit) ||
                const DeepCollectionEquality()
                    .equals(other.bgImageFit, bgImageFit)) &&
            (identical(other.screenBorderConfig, screenBorderConfig) ||
                const DeepCollectionEquality()
                    .equals(other.screenBorderConfig, screenBorderConfig)) &&
            (identical(other.paddingConfig, paddingConfig) ||
                const DeepCollectionEquality()
                    .equals(other.paddingConfig, paddingConfig)) &&
            (identical(other.marginConfig, marginConfig) ||
                const DeepCollectionEquality()
                    .equals(other.marginConfig, marginConfig)) &&
            (identical(other.rows, rows) ||
                const DeepCollectionEquality().equals(other.rows, rows)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(bannerImage) ^
      const DeepCollectionEquality().hash(spacing) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(bgImage) ^
      const DeepCollectionEquality().hash(mainAxisAlignment) ^
      const DeepCollectionEquality().hash(crossAxisAlignment) ^
      const DeepCollectionEquality().hash(mainAxisSize) ^
      const DeepCollectionEquality().hash(scrollDirection) ^
      const DeepCollectionEquality().hash(bannerHeight) ^
      const DeepCollectionEquality().hash(titleConfig) ^
      const DeepCollectionEquality().hash(bannerImageFit) ^
      const DeepCollectionEquality().hash(bgImageFit) ^
      const DeepCollectionEquality().hash(screenBorderConfig) ^
      const DeepCollectionEquality().hash(paddingConfig) ^
      const DeepCollectionEquality().hash(marginConfig) ^
      const DeepCollectionEquality().hash(rows) ^
      runtimeType.hashCode;
}

extension $DashboardScreenInfoExtension on DashboardScreenInfo {
  DashboardScreenInfo copyWith(
      {String? name,
      String? description,
      String? bannerImage,
      double? spacing,
      List<String>? tags,
      int? bgColor,
      String? bgImage,
      String? mainAxisAlignment,
      String? crossAxisAlignment,
      String? mainAxisSize,
      String? scrollDirection,
      double? bannerHeight,
      TitleConfig? titleConfig,
      ImageFitConfig? bannerImageFit,
      ImageFitConfig? bgImageFit,
      BorderConfig? screenBorderConfig,
      PaddingConfig? paddingConfig,
      PaddingConfig? marginConfig,
      List<ScreenRow>? rows}) {
    return DashboardScreenInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        bannerImage: bannerImage ?? this.bannerImage,
        spacing: spacing ?? this.spacing,
        tags: tags ?? this.tags,
        bgColor: bgColor ?? this.bgColor,
        bgImage: bgImage ?? this.bgImage,
        mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
        crossAxisAlignment: crossAxisAlignment ?? this.crossAxisAlignment,
        mainAxisSize: mainAxisSize ?? this.mainAxisSize,
        scrollDirection: scrollDirection ?? this.scrollDirection,
        bannerHeight: bannerHeight ?? this.bannerHeight,
        titleConfig: titleConfig ?? this.titleConfig,
        bannerImageFit: bannerImageFit ?? this.bannerImageFit,
        bgImageFit: bgImageFit ?? this.bgImageFit,
        screenBorderConfig: screenBorderConfig ?? this.screenBorderConfig,
        paddingConfig: paddingConfig ?? this.paddingConfig,
        marginConfig: marginConfig ?? this.marginConfig,
        rows: rows ?? this.rows);
  }

  DashboardScreenInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? bannerImage,
      Wrapped<double?>? spacing,
      Wrapped<List<String>?>? tags,
      Wrapped<int?>? bgColor,
      Wrapped<String?>? bgImage,
      Wrapped<String?>? mainAxisAlignment,
      Wrapped<String?>? crossAxisAlignment,
      Wrapped<String?>? mainAxisSize,
      Wrapped<String?>? scrollDirection,
      Wrapped<double?>? bannerHeight,
      Wrapped<TitleConfig?>? titleConfig,
      Wrapped<ImageFitConfig?>? bannerImageFit,
      Wrapped<ImageFitConfig?>? bgImageFit,
      Wrapped<BorderConfig?>? screenBorderConfig,
      Wrapped<PaddingConfig?>? paddingConfig,
      Wrapped<PaddingConfig?>? marginConfig,
      Wrapped<List<ScreenRow>>? rows}) {
    return DashboardScreenInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        bannerImage:
            (bannerImage != null ? bannerImage.value : this.bannerImage),
        spacing: (spacing != null ? spacing.value : this.spacing),
        tags: (tags != null ? tags.value : this.tags),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        bgImage: (bgImage != null ? bgImage.value : this.bgImage),
        mainAxisAlignment: (mainAxisAlignment != null
            ? mainAxisAlignment.value
            : this.mainAxisAlignment),
        crossAxisAlignment: (crossAxisAlignment != null
            ? crossAxisAlignment.value
            : this.crossAxisAlignment),
        mainAxisSize:
            (mainAxisSize != null ? mainAxisSize.value : this.mainAxisSize),
        scrollDirection: (scrollDirection != null
            ? scrollDirection.value
            : this.scrollDirection),
        bannerHeight:
            (bannerHeight != null ? bannerHeight.value : this.bannerHeight),
        titleConfig:
            (titleConfig != null ? titleConfig.value : this.titleConfig),
        bannerImageFit: (bannerImageFit != null
            ? bannerImageFit.value
            : this.bannerImageFit),
        bgImageFit: (bgImageFit != null ? bgImageFit.value : this.bgImageFit),
        screenBorderConfig: (screenBorderConfig != null
            ? screenBorderConfig.value
            : this.screenBorderConfig),
        paddingConfig:
            (paddingConfig != null ? paddingConfig.value : this.paddingConfig),
        marginConfig:
            (marginConfig != null ? marginConfig.value : this.marginConfig),
        rows: (rows != null ? rows.value : this.rows));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreen {
  const DashboardScreen({
    required this.domainKey,
    required this.id,
    required this.name,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
    this.tags,
    this.description,
    this.bannerImage,
    this.spacing,
    this.bgColor,
    this.bgImage,
    this.mainAxisAlignment,
    this.crossAxisAlignment,
    this.mainAxisSize,
    this.scrollDirection,
    this.bannerHeight,
    this.titleConfig,
    this.bannerImageFit,
    this.bgImageFit,
    this.screenBorderConfig,
    this.paddingConfig,
    this.marginConfig,
    required this.rows,
  });

  factory DashboardScreen.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenFromJson(json);

  static const toJsonFactory = _$DashboardScreenToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'bannerImage', includeIfNull: false, defaultValue: '')
  final String? bannerImage;
  @JsonKey(name: 'spacing', includeIfNull: false)
  final double? spacing;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'bgImage', includeIfNull: false, defaultValue: '')
  final String? bgImage;
  @JsonKey(name: 'mainAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? mainAxisAlignment;
  @JsonKey(name: 'crossAxisAlignment', includeIfNull: false, defaultValue: '')
  final String? crossAxisAlignment;
  @JsonKey(name: 'mainAxisSize', includeIfNull: false, defaultValue: '')
  final String? mainAxisSize;
  @JsonKey(name: 'scrollDirection', includeIfNull: false, defaultValue: '')
  final String? scrollDirection;
  @JsonKey(name: 'bannerHeight', includeIfNull: false)
  final double? bannerHeight;
  @JsonKey(name: 'titleConfig', includeIfNull: false)
  final TitleConfig? titleConfig;
  @JsonKey(name: 'bannerImageFit', includeIfNull: false)
  final ImageFitConfig? bannerImageFit;
  @JsonKey(name: 'bgImageFit', includeIfNull: false)
  final ImageFitConfig? bgImageFit;
  @JsonKey(name: 'screenBorderConfig', includeIfNull: false)
  final BorderConfig? screenBorderConfig;
  @JsonKey(name: 'paddingConfig', includeIfNull: false)
  final PaddingConfig? paddingConfig;
  @JsonKey(name: 'marginConfig', includeIfNull: false)
  final PaddingConfig? marginConfig;
  @JsonKey(name: 'rows', includeIfNull: false, defaultValue: <ScreenRow>[])
  final List<ScreenRow> rows;
  static const fromJsonFactory = _$DashboardScreenFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreen &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.bannerImage, bannerImage) ||
                const DeepCollectionEquality()
                    .equals(other.bannerImage, bannerImage)) &&
            (identical(other.spacing, spacing) ||
                const DeepCollectionEquality()
                    .equals(other.spacing, spacing)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.bgImage, bgImage) ||
                const DeepCollectionEquality()
                    .equals(other.bgImage, bgImage)) &&
            (identical(other.mainAxisAlignment, mainAxisAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.mainAxisAlignment, mainAxisAlignment)) &&
            (identical(other.crossAxisAlignment, crossAxisAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.crossAxisAlignment, crossAxisAlignment)) &&
            (identical(other.mainAxisSize, mainAxisSize) ||
                const DeepCollectionEquality()
                    .equals(other.mainAxisSize, mainAxisSize)) &&
            (identical(other.scrollDirection, scrollDirection) ||
                const DeepCollectionEquality()
                    .equals(other.scrollDirection, scrollDirection)) &&
            (identical(other.bannerHeight, bannerHeight) ||
                const DeepCollectionEquality()
                    .equals(other.bannerHeight, bannerHeight)) &&
            (identical(other.titleConfig, titleConfig) ||
                const DeepCollectionEquality()
                    .equals(other.titleConfig, titleConfig)) &&
            (identical(other.bannerImageFit, bannerImageFit) ||
                const DeepCollectionEquality()
                    .equals(other.bannerImageFit, bannerImageFit)) &&
            (identical(other.bgImageFit, bgImageFit) ||
                const DeepCollectionEquality()
                    .equals(other.bgImageFit, bgImageFit)) &&
            (identical(other.screenBorderConfig, screenBorderConfig) ||
                const DeepCollectionEquality()
                    .equals(other.screenBorderConfig, screenBorderConfig)) &&
            (identical(other.paddingConfig, paddingConfig) ||
                const DeepCollectionEquality().equals(other.paddingConfig, paddingConfig)) &&
            (identical(other.marginConfig, marginConfig) || const DeepCollectionEquality().equals(other.marginConfig, marginConfig)) &&
            (identical(other.rows, rows) || const DeepCollectionEquality().equals(other.rows, rows)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(bannerImage) ^
      const DeepCollectionEquality().hash(spacing) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(bgImage) ^
      const DeepCollectionEquality().hash(mainAxisAlignment) ^
      const DeepCollectionEquality().hash(crossAxisAlignment) ^
      const DeepCollectionEquality().hash(mainAxisSize) ^
      const DeepCollectionEquality().hash(scrollDirection) ^
      const DeepCollectionEquality().hash(bannerHeight) ^
      const DeepCollectionEquality().hash(titleConfig) ^
      const DeepCollectionEquality().hash(bannerImageFit) ^
      const DeepCollectionEquality().hash(bgImageFit) ^
      const DeepCollectionEquality().hash(screenBorderConfig) ^
      const DeepCollectionEquality().hash(paddingConfig) ^
      const DeepCollectionEquality().hash(marginConfig) ^
      const DeepCollectionEquality().hash(rows) ^
      runtimeType.hashCode;
}

extension $DashboardScreenExtension on DashboardScreen {
  DashboardScreen copyWith(
      {String? domainKey,
      String? id,
      String? name,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      List<String>? tags,
      String? description,
      String? bannerImage,
      double? spacing,
      int? bgColor,
      String? bgImage,
      String? mainAxisAlignment,
      String? crossAxisAlignment,
      String? mainAxisSize,
      String? scrollDirection,
      double? bannerHeight,
      TitleConfig? titleConfig,
      ImageFitConfig? bannerImageFit,
      ImageFitConfig? bgImageFit,
      BorderConfig? screenBorderConfig,
      PaddingConfig? paddingConfig,
      PaddingConfig? marginConfig,
      List<ScreenRow>? rows}) {
    return DashboardScreen(
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        name: name ?? this.name,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        tags: tags ?? this.tags,
        description: description ?? this.description,
        bannerImage: bannerImage ?? this.bannerImage,
        spacing: spacing ?? this.spacing,
        bgColor: bgColor ?? this.bgColor,
        bgImage: bgImage ?? this.bgImage,
        mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
        crossAxisAlignment: crossAxisAlignment ?? this.crossAxisAlignment,
        mainAxisSize: mainAxisSize ?? this.mainAxisSize,
        scrollDirection: scrollDirection ?? this.scrollDirection,
        bannerHeight: bannerHeight ?? this.bannerHeight,
        titleConfig: titleConfig ?? this.titleConfig,
        bannerImageFit: bannerImageFit ?? this.bannerImageFit,
        bgImageFit: bgImageFit ?? this.bgImageFit,
        screenBorderConfig: screenBorderConfig ?? this.screenBorderConfig,
        paddingConfig: paddingConfig ?? this.paddingConfig,
        marginConfig: marginConfig ?? this.marginConfig,
        rows: rows ?? this.rows);
  }

  DashboardScreen copyWithWrapped(
      {Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? description,
      Wrapped<String?>? bannerImage,
      Wrapped<double?>? spacing,
      Wrapped<int?>? bgColor,
      Wrapped<String?>? bgImage,
      Wrapped<String?>? mainAxisAlignment,
      Wrapped<String?>? crossAxisAlignment,
      Wrapped<String?>? mainAxisSize,
      Wrapped<String?>? scrollDirection,
      Wrapped<double?>? bannerHeight,
      Wrapped<TitleConfig?>? titleConfig,
      Wrapped<ImageFitConfig?>? bannerImageFit,
      Wrapped<ImageFitConfig?>? bgImageFit,
      Wrapped<BorderConfig?>? screenBorderConfig,
      Wrapped<PaddingConfig?>? paddingConfig,
      Wrapped<PaddingConfig?>? marginConfig,
      Wrapped<List<ScreenRow>>? rows}) {
    return DashboardScreen(
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        tags: (tags != null ? tags.value : this.tags),
        description:
            (description != null ? description.value : this.description),
        bannerImage:
            (bannerImage != null ? bannerImage.value : this.bannerImage),
        spacing: (spacing != null ? spacing.value : this.spacing),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        bgImage: (bgImage != null ? bgImage.value : this.bgImage),
        mainAxisAlignment: (mainAxisAlignment != null
            ? mainAxisAlignment.value
            : this.mainAxisAlignment),
        crossAxisAlignment: (crossAxisAlignment != null
            ? crossAxisAlignment.value
            : this.crossAxisAlignment),
        mainAxisSize:
            (mainAxisSize != null ? mainAxisSize.value : this.mainAxisSize),
        scrollDirection: (scrollDirection != null
            ? scrollDirection.value
            : this.scrollDirection),
        bannerHeight:
            (bannerHeight != null ? bannerHeight.value : this.bannerHeight),
        titleConfig:
            (titleConfig != null ? titleConfig.value : this.titleConfig),
        bannerImageFit: (bannerImageFit != null
            ? bannerImageFit.value
            : this.bannerImageFit),
        bgImageFit: (bgImageFit != null ? bgImageFit.value : this.bgImageFit),
        screenBorderConfig: (screenBorderConfig != null
            ? screenBorderConfig.value
            : this.screenBorderConfig),
        paddingConfig:
            (paddingConfig != null ? paddingConfig.value : this.paddingConfig),
        marginConfig:
            (marginConfig != null ? marginConfig.value : this.marginConfig),
        rows: (rows != null ? rows.value : this.rows));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenEntity {
  const DashboardScreenEntity({
    this.entity,
  });

  factory DashboardScreenEntity.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenEntityFromJson(json);

  static const toJsonFactory = _$DashboardScreenEntityToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DashboardScreen? entity;
  static const fromJsonFactory = _$DashboardScreenEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DashboardScreenEntityExtension on DashboardScreenEntity {
  DashboardScreenEntity copyWith({DashboardScreen? entity}) {
    return DashboardScreenEntity(entity: entity ?? this.entity);
  }

  DashboardScreenEntity copyWithWrapped({Wrapped<DashboardScreen?>? entity}) {
    return DashboardScreenEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenEntityRes {
  const DashboardScreenEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DashboardScreenEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenEntityResFromJson(json);

  static const toJsonFactory = _$DashboardScreenEntityResToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DashboardScreen? entity;
  static const fromJsonFactory = _$DashboardScreenEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DashboardScreenEntityResExtension on DashboardScreenEntityRes {
  DashboardScreenEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      DashboardScreen? entity}) {
    return DashboardScreenEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  DashboardScreenEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<DashboardScreen?>? entity}) {
    return DashboardScreenEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenArray {
  const DashboardScreenArray({
    this.values,
  });

  factory DashboardScreenArray.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenArrayFromJson(json);

  static const toJsonFactory = _$DashboardScreenArrayToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenArrayToJson(this);

  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <DashboardScreen>[])
  final List<DashboardScreen>? values;
  static const fromJsonFactory = _$DashboardScreenArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DashboardScreenArrayExtension on DashboardScreenArray {
  DashboardScreenArray copyWith({List<DashboardScreen>? values}) {
    return DashboardScreenArray(values: values ?? this.values);
  }

  DashboardScreenArray copyWithWrapped(
      {Wrapped<List<DashboardScreen>?>? values}) {
    return DashboardScreenArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardScreenArrayRes {
  const DashboardScreenArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DashboardScreenArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DashboardScreenArrayResFromJson(json);

  static const toJsonFactory = _$DashboardScreenArrayResToJson;
  Map<String, dynamic> toJson() => _$DashboardScreenArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <DashboardScreen>[])
  final List<DashboardScreen>? values;
  static const fromJsonFactory = _$DashboardScreenArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardScreenArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DashboardScreenArrayResExtension on DashboardScreenArrayRes {
  DashboardScreenArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<DashboardScreen>? values}) {
    return DashboardScreenArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  DashboardScreenArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<DashboardScreen>?>? values}) {
    return DashboardScreenArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceDataBase {
  const DeviceDataBase({
    this.data,
  });

  factory DeviceDataBase.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataBaseFromJson(json);

  static const toJsonFactory = _$DeviceDataBaseToJson;
  Map<String, dynamic> toJson() => _$DeviceDataBaseToJson(this);

  @JsonKey(name: 'data', includeIfNull: false)
  final DeviceData? data;
  static const fromJsonFactory = _$DeviceDataBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceDataBase &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^ runtimeType.hashCode;
}

extension $DeviceDataBaseExtension on DeviceDataBase {
  DeviceDataBase copyWith({DeviceData? data}) {
    return DeviceDataBase(data: data ?? this.data);
  }

  DeviceDataBase copyWithWrapped({Wrapped<DeviceData?>? data}) {
    return DeviceDataBase(data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceDataEntityRes {
  const DeviceDataEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.data,
  });

  factory DeviceDataEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DeviceDataEntityResFromJson(json);

  static const toJsonFactory = _$DeviceDataEntityResToJson;
  Map<String, dynamic> toJson() => _$DeviceDataEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'data', includeIfNull: false)
  final DeviceData? data;
  static const fromJsonFactory = _$DeviceDataEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceDataEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $DeviceDataEntityResExtension on DeviceDataEntityRes {
  DeviceDataEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      DeviceData? data}) {
    return DeviceDataEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        data: data ?? this.data);
  }

  DeviceDataEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<DeviceData?>? data}) {
    return DeviceDataEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationInfo {
  const EventRegistrationInfo({
    required this.eventId,
    this.notification,
    this.email,
    this.sms,
    this.voice,
    this.fcm,
    this.emailId,
    this.phoneNumber,
    this.name,
    this.targetDeviceIds,
    this.tags,
  });

  factory EventRegistrationInfo.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationInfoFromJson(json);

  static const toJsonFactory = _$EventRegistrationInfoToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationInfoToJson(this);

  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String eventId;
  @JsonKey(name: 'notification', includeIfNull: false)
  final bool? notification;
  @JsonKey(name: 'email', includeIfNull: false)
  final bool? email;
  @JsonKey(name: 'sms', includeIfNull: false)
  final bool? sms;
  @JsonKey(name: 'voice', includeIfNull: false)
  final bool? voice;
  @JsonKey(name: 'fcm', includeIfNull: false)
  final bool? fcm;
  @JsonKey(name: 'emailId', includeIfNull: false, defaultValue: '')
  final String? emailId;
  @JsonKey(name: 'phoneNumber', includeIfNull: false, defaultValue: '')
  final String? phoneNumber;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(
      name: 'targetDeviceIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? targetDeviceIds;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$EventRegistrationInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationInfo &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.notification, notification) ||
                const DeepCollectionEquality()
                    .equals(other.notification, notification)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.sms, sms) ||
                const DeepCollectionEquality().equals(other.sms, sms)) &&
            (identical(other.voice, voice) ||
                const DeepCollectionEquality().equals(other.voice, voice)) &&
            (identical(other.fcm, fcm) ||
                const DeepCollectionEquality().equals(other.fcm, fcm)) &&
            (identical(other.emailId, emailId) ||
                const DeepCollectionEquality()
                    .equals(other.emailId, emailId)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.targetDeviceIds, targetDeviceIds) ||
                const DeepCollectionEquality()
                    .equals(other.targetDeviceIds, targetDeviceIds)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(notification) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(sms) ^
      const DeepCollectionEquality().hash(voice) ^
      const DeepCollectionEquality().hash(fcm) ^
      const DeepCollectionEquality().hash(emailId) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(targetDeviceIds) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $EventRegistrationInfoExtension on EventRegistrationInfo {
  EventRegistrationInfo copyWith(
      {String? eventId,
      bool? notification,
      bool? email,
      bool? sms,
      bool? voice,
      bool? fcm,
      String? emailId,
      String? phoneNumber,
      String? name,
      List<String>? targetDeviceIds,
      List<String>? tags}) {
    return EventRegistrationInfo(
        eventId: eventId ?? this.eventId,
        notification: notification ?? this.notification,
        email: email ?? this.email,
        sms: sms ?? this.sms,
        voice: voice ?? this.voice,
        fcm: fcm ?? this.fcm,
        emailId: emailId ?? this.emailId,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        name: name ?? this.name,
        targetDeviceIds: targetDeviceIds ?? this.targetDeviceIds,
        tags: tags ?? this.tags);
  }

  EventRegistrationInfo copyWithWrapped(
      {Wrapped<String>? eventId,
      Wrapped<bool?>? notification,
      Wrapped<bool?>? email,
      Wrapped<bool?>? sms,
      Wrapped<bool?>? voice,
      Wrapped<bool?>? fcm,
      Wrapped<String?>? emailId,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? name,
      Wrapped<List<String>?>? targetDeviceIds,
      Wrapped<List<String>?>? tags}) {
    return EventRegistrationInfo(
        eventId: (eventId != null ? eventId.value : this.eventId),
        notification:
            (notification != null ? notification.value : this.notification),
        email: (email != null ? email.value : this.email),
        sms: (sms != null ? sms.value : this.sms),
        voice: (voice != null ? voice.value : this.voice),
        fcm: (fcm != null ? fcm.value : this.fcm),
        emailId: (emailId != null ? emailId.value : this.emailId),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        name: (name != null ? name.value : this.name),
        targetDeviceIds: (targetDeviceIds != null
            ? targetDeviceIds.value
            : this.targetDeviceIds),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationBase {
  const EventRegistrationBase({
    required this.userId,
  });

  factory EventRegistrationBase.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationBaseFromJson(json);

  static const toJsonFactory = _$EventRegistrationBaseToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationBaseToJson(this);

  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String userId;
  static const fromJsonFactory = _$EventRegistrationBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationBase &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^ runtimeType.hashCode;
}

extension $EventRegistrationBaseExtension on EventRegistrationBase {
  EventRegistrationBase copyWith({String? userId}) {
    return EventRegistrationBase(userId: userId ?? this.userId);
  }

  EventRegistrationBase copyWithWrapped({Wrapped<String>? userId}) {
    return EventRegistrationBase(
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistration {
  const EventRegistration({
    required this.domainKey,
    required this.id,
    required this.name,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
    this.tags,
    required this.eventId,
    this.notification,
    this.email,
    this.sms,
    this.voice,
    this.fcm,
    this.emailId,
    this.phoneNumber,
    this.targetDeviceIds,
    required this.userId,
  });

  factory EventRegistration.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationFromJson(json);

  static const toJsonFactory = _$EventRegistrationToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationToJson(this);

  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String eventId;
  @JsonKey(name: 'notification', includeIfNull: false)
  final bool? notification;
  @JsonKey(name: 'email', includeIfNull: false)
  final bool? email;
  @JsonKey(name: 'sms', includeIfNull: false)
  final bool? sms;
  @JsonKey(name: 'voice', includeIfNull: false)
  final bool? voice;
  @JsonKey(name: 'fcm', includeIfNull: false)
  final bool? fcm;
  @JsonKey(name: 'emailId', includeIfNull: false, defaultValue: '')
  final String? emailId;
  @JsonKey(name: 'phoneNumber', includeIfNull: false, defaultValue: '')
  final String? phoneNumber;
  @JsonKey(
      name: 'targetDeviceIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? targetDeviceIds;
  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String userId;
  static const fromJsonFactory = _$EventRegistrationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistration &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.notification, notification) ||
                const DeepCollectionEquality()
                    .equals(other.notification, notification)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.sms, sms) ||
                const DeepCollectionEquality().equals(other.sms, sms)) &&
            (identical(other.voice, voice) ||
                const DeepCollectionEquality().equals(other.voice, voice)) &&
            (identical(other.fcm, fcm) ||
                const DeepCollectionEquality().equals(other.fcm, fcm)) &&
            (identical(other.emailId, emailId) ||
                const DeepCollectionEquality()
                    .equals(other.emailId, emailId)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.targetDeviceIds, targetDeviceIds) ||
                const DeepCollectionEquality()
                    .equals(other.targetDeviceIds, targetDeviceIds)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(notification) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(sms) ^
      const DeepCollectionEquality().hash(voice) ^
      const DeepCollectionEquality().hash(fcm) ^
      const DeepCollectionEquality().hash(emailId) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(targetDeviceIds) ^
      const DeepCollectionEquality().hash(userId) ^
      runtimeType.hashCode;
}

extension $EventRegistrationExtension on EventRegistration {
  EventRegistration copyWith(
      {String? domainKey,
      String? id,
      String? name,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      List<String>? tags,
      String? eventId,
      bool? notification,
      bool? email,
      bool? sms,
      bool? voice,
      bool? fcm,
      String? emailId,
      String? phoneNumber,
      List<String>? targetDeviceIds,
      String? userId}) {
    return EventRegistration(
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        name: name ?? this.name,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        tags: tags ?? this.tags,
        eventId: eventId ?? this.eventId,
        notification: notification ?? this.notification,
        email: email ?? this.email,
        sms: sms ?? this.sms,
        voice: voice ?? this.voice,
        fcm: fcm ?? this.fcm,
        emailId: emailId ?? this.emailId,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        targetDeviceIds: targetDeviceIds ?? this.targetDeviceIds,
        userId: userId ?? this.userId);
  }

  EventRegistration copyWithWrapped(
      {Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp,
      Wrapped<List<String>?>? tags,
      Wrapped<String>? eventId,
      Wrapped<bool?>? notification,
      Wrapped<bool?>? email,
      Wrapped<bool?>? sms,
      Wrapped<bool?>? voice,
      Wrapped<bool?>? fcm,
      Wrapped<String?>? emailId,
      Wrapped<String?>? phoneNumber,
      Wrapped<List<String>?>? targetDeviceIds,
      Wrapped<String>? userId}) {
    return EventRegistration(
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        tags: (tags != null ? tags.value : this.tags),
        eventId: (eventId != null ? eventId.value : this.eventId),
        notification:
            (notification != null ? notification.value : this.notification),
        email: (email != null ? email.value : this.email),
        sms: (sms != null ? sms.value : this.sms),
        voice: (voice != null ? voice.value : this.voice),
        fcm: (fcm != null ? fcm.value : this.fcm),
        emailId: (emailId != null ? emailId.value : this.emailId),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        targetDeviceIds: (targetDeviceIds != null
            ? targetDeviceIds.value
            : this.targetDeviceIds),
        userId: (userId != null ? userId.value : this.userId));
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationEntity {
  const EventRegistrationEntity({
    this.entity,
  });

  factory EventRegistrationEntity.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationEntityFromJson(json);

  static const toJsonFactory = _$EventRegistrationEntityToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final EventRegistration? entity;
  static const fromJsonFactory = _$EventRegistrationEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $EventRegistrationEntityExtension on EventRegistrationEntity {
  EventRegistrationEntity copyWith({EventRegistration? entity}) {
    return EventRegistrationEntity(entity: entity ?? this.entity);
  }

  EventRegistrationEntity copyWithWrapped(
      {Wrapped<EventRegistration?>? entity}) {
    return EventRegistrationEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationEntityRes {
  const EventRegistrationEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory EventRegistrationEntityRes.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationEntityResFromJson(json);

  static const toJsonFactory = _$EventRegistrationEntityResToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final EventRegistration? entity;
  static const fromJsonFactory = _$EventRegistrationEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $EventRegistrationEntityResExtension on EventRegistrationEntityRes {
  EventRegistrationEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      EventRegistration? entity}) {
    return EventRegistrationEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  EventRegistrationEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<EventRegistration?>? entity}) {
    return EventRegistrationEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationArray {
  const EventRegistrationArray({
    this.values,
  });

  factory EventRegistrationArray.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationArrayFromJson(json);

  static const toJsonFactory = _$EventRegistrationArrayToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationArrayToJson(this);

  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <EventRegistration>[])
  final List<EventRegistration>? values;
  static const fromJsonFactory = _$EventRegistrationArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $EventRegistrationArrayExtension on EventRegistrationArray {
  EventRegistrationArray copyWith({List<EventRegistration>? values}) {
    return EventRegistrationArray(values: values ?? this.values);
  }

  EventRegistrationArray copyWithWrapped(
      {Wrapped<List<EventRegistration>?>? values}) {
    return EventRegistrationArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class EventRegistrationArrayRes {
  const EventRegistrationArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory EventRegistrationArrayRes.fromJson(Map<String, dynamic> json) =>
      _$EventRegistrationArrayResFromJson(json);

  static const toJsonFactory = _$EventRegistrationArrayResToJson;
  Map<String, dynamic> toJson() => _$EventRegistrationArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <EventRegistration>[])
  final List<EventRegistration>? values;
  static const fromJsonFactory = _$EventRegistrationArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EventRegistrationArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $EventRegistrationArrayResExtension on EventRegistrationArrayRes {
  EventRegistrationArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<EventRegistration>? values}) {
    return EventRegistrationArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  EventRegistrationArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<EventRegistration>?>? values}) {
    return EventRegistrationArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredEvent {
  const TriggeredEvent({
    required this.eventId,
    required this.modelId,
    required this.deviceId,
    required this.hardwareDeviceId,
    this.notificationTitle,
    this.notificationContent,
    this.emailSubject,
    this.emailContent,
    this.smsMessage,
    this.fcmTitle,
    this.fcmContent,
    this.voiceMessage,
    this.icon,
    required this.userId,
    required this.eventType,
    required this.deliveryStatus,
    this.deliveryErrors,
    this.deviceIcon,
    required this.domainKey,
    required this.id,
    required this.name,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
    this.tags,
  });

  factory TriggeredEvent.fromJson(Map<String, dynamic> json) =>
      _$TriggeredEventFromJson(json);

  static const toJsonFactory = _$TriggeredEventToJson;
  Map<String, dynamic> toJson() => _$TriggeredEventToJson(this);

  @JsonKey(name: 'eventId', includeIfNull: false, defaultValue: '')
  final String eventId;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'deviceId', includeIfNull: false, defaultValue: '')
  final String deviceId;
  @JsonKey(name: 'hardwareDeviceId', includeIfNull: false, defaultValue: '')
  final String hardwareDeviceId;
  @JsonKey(name: 'notificationTitle', includeIfNull: false, defaultValue: '')
  final String? notificationTitle;
  @JsonKey(name: 'notificationContent', includeIfNull: false, defaultValue: '')
  final String? notificationContent;
  @JsonKey(name: 'emailSubject', includeIfNull: false, defaultValue: '')
  final String? emailSubject;
  @JsonKey(name: 'emailContent', includeIfNull: false, defaultValue: '')
  final String? emailContent;
  @JsonKey(name: 'smsMessage', includeIfNull: false, defaultValue: '')
  final String? smsMessage;
  @JsonKey(name: 'fcmTitle', includeIfNull: false, defaultValue: '')
  final String? fcmTitle;
  @JsonKey(name: 'fcmContent', includeIfNull: false, defaultValue: '')
  final String? fcmContent;
  @JsonKey(name: 'voiceMessage', includeIfNull: false, defaultValue: '')
  final String? voiceMessage;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'userId', includeIfNull: false, defaultValue: '')
  final String userId;
  @JsonKey(
    name: 'eventType',
    includeIfNull: false,
    toJson: triggeredEventEventTypeToJson,
    fromJson: triggeredEventEventTypeFromJson,
  )
  final enums.TriggeredEventEventType eventType;
  @JsonKey(
    name: 'deliveryStatus',
    includeIfNull: false,
    toJson: triggeredEventDeliveryStatusToJson,
    fromJson: triggeredEventDeliveryStatusFromJson,
  )
  final enums.TriggeredEventDeliveryStatus deliveryStatus;
  @JsonKey(
      name: 'deliveryErrors', includeIfNull: false, defaultValue: <String>[])
  final List<String>? deliveryErrors;
  @JsonKey(name: 'deviceIcon', includeIfNull: false, defaultValue: '')
  final String? deviceIcon;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$TriggeredEventFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredEvent &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.hardwareDeviceId, hardwareDeviceId) ||
                const DeepCollectionEquality()
                    .equals(other.hardwareDeviceId, hardwareDeviceId)) &&
            (identical(other.notificationTitle, notificationTitle) ||
                const DeepCollectionEquality()
                    .equals(other.notificationTitle, notificationTitle)) &&
            (identical(other.notificationContent, notificationContent) ||
                const DeepCollectionEquality()
                    .equals(other.notificationContent, notificationContent)) &&
            (identical(other.emailSubject, emailSubject) ||
                const DeepCollectionEquality()
                    .equals(other.emailSubject, emailSubject)) &&
            (identical(other.emailContent, emailContent) ||
                const DeepCollectionEquality()
                    .equals(other.emailContent, emailContent)) &&
            (identical(other.smsMessage, smsMessage) ||
                const DeepCollectionEquality()
                    .equals(other.smsMessage, smsMessage)) &&
            (identical(other.fcmTitle, fcmTitle) ||
                const DeepCollectionEquality()
                    .equals(other.fcmTitle, fcmTitle)) &&
            (identical(other.fcmContent, fcmContent) ||
                const DeepCollectionEquality()
                    .equals(other.fcmContent, fcmContent)) &&
            (identical(other.voiceMessage, voiceMessage) ||
                const DeepCollectionEquality()
                    .equals(other.voiceMessage, voiceMessage)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality()
                    .equals(other.eventType, eventType)) &&
            (identical(other.deliveryStatus, deliveryStatus) ||
                const DeepCollectionEquality()
                    .equals(other.deliveryStatus, deliveryStatus)) &&
            (identical(other.deliveryErrors, deliveryErrors) ||
                const DeepCollectionEquality()
                    .equals(other.deliveryErrors, deliveryErrors)) &&
            (identical(other.deviceIcon, deviceIcon) ||
                const DeepCollectionEquality()
                    .equals(other.deviceIcon, deviceIcon)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) || const DeepCollectionEquality().equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) || const DeepCollectionEquality().equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.tags, tags) || const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(hardwareDeviceId) ^
      const DeepCollectionEquality().hash(notificationTitle) ^
      const DeepCollectionEquality().hash(notificationContent) ^
      const DeepCollectionEquality().hash(emailSubject) ^
      const DeepCollectionEquality().hash(emailContent) ^
      const DeepCollectionEquality().hash(smsMessage) ^
      const DeepCollectionEquality().hash(fcmTitle) ^
      const DeepCollectionEquality().hash(fcmContent) ^
      const DeepCollectionEquality().hash(voiceMessage) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(deliveryStatus) ^
      const DeepCollectionEquality().hash(deliveryErrors) ^
      const DeepCollectionEquality().hash(deviceIcon) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $TriggeredEventExtension on TriggeredEvent {
  TriggeredEvent copyWith(
      {String? eventId,
      String? modelId,
      String? deviceId,
      String? hardwareDeviceId,
      String? notificationTitle,
      String? notificationContent,
      String? emailSubject,
      String? emailContent,
      String? smsMessage,
      String? fcmTitle,
      String? fcmContent,
      String? voiceMessage,
      String? icon,
      String? userId,
      enums.TriggeredEventEventType? eventType,
      enums.TriggeredEventDeliveryStatus? deliveryStatus,
      List<String>? deliveryErrors,
      String? deviceIcon,
      String? domainKey,
      String? id,
      String? name,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      List<String>? tags}) {
    return TriggeredEvent(
        eventId: eventId ?? this.eventId,
        modelId: modelId ?? this.modelId,
        deviceId: deviceId ?? this.deviceId,
        hardwareDeviceId: hardwareDeviceId ?? this.hardwareDeviceId,
        notificationTitle: notificationTitle ?? this.notificationTitle,
        notificationContent: notificationContent ?? this.notificationContent,
        emailSubject: emailSubject ?? this.emailSubject,
        emailContent: emailContent ?? this.emailContent,
        smsMessage: smsMessage ?? this.smsMessage,
        fcmTitle: fcmTitle ?? this.fcmTitle,
        fcmContent: fcmContent ?? this.fcmContent,
        voiceMessage: voiceMessage ?? this.voiceMessage,
        icon: icon ?? this.icon,
        userId: userId ?? this.userId,
        eventType: eventType ?? this.eventType,
        deliveryStatus: deliveryStatus ?? this.deliveryStatus,
        deliveryErrors: deliveryErrors ?? this.deliveryErrors,
        deviceIcon: deviceIcon ?? this.deviceIcon,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        name: name ?? this.name,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        tags: tags ?? this.tags);
  }

  TriggeredEvent copyWithWrapped(
      {Wrapped<String>? eventId,
      Wrapped<String>? modelId,
      Wrapped<String>? deviceId,
      Wrapped<String>? hardwareDeviceId,
      Wrapped<String?>? notificationTitle,
      Wrapped<String?>? notificationContent,
      Wrapped<String?>? emailSubject,
      Wrapped<String?>? emailContent,
      Wrapped<String?>? smsMessage,
      Wrapped<String?>? fcmTitle,
      Wrapped<String?>? fcmContent,
      Wrapped<String?>? voiceMessage,
      Wrapped<String?>? icon,
      Wrapped<String>? userId,
      Wrapped<enums.TriggeredEventEventType>? eventType,
      Wrapped<enums.TriggeredEventDeliveryStatus>? deliveryStatus,
      Wrapped<List<String>?>? deliveryErrors,
      Wrapped<String?>? deviceIcon,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp,
      Wrapped<List<String>?>? tags}) {
    return TriggeredEvent(
        eventId: (eventId != null ? eventId.value : this.eventId),
        modelId: (modelId != null ? modelId.value : this.modelId),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        hardwareDeviceId: (hardwareDeviceId != null
            ? hardwareDeviceId.value
            : this.hardwareDeviceId),
        notificationTitle: (notificationTitle != null
            ? notificationTitle.value
            : this.notificationTitle),
        notificationContent: (notificationContent != null
            ? notificationContent.value
            : this.notificationContent),
        emailSubject:
            (emailSubject != null ? emailSubject.value : this.emailSubject),
        emailContent:
            (emailContent != null ? emailContent.value : this.emailContent),
        smsMessage: (smsMessage != null ? smsMessage.value : this.smsMessage),
        fcmTitle: (fcmTitle != null ? fcmTitle.value : this.fcmTitle),
        fcmContent: (fcmContent != null ? fcmContent.value : this.fcmContent),
        voiceMessage:
            (voiceMessage != null ? voiceMessage.value : this.voiceMessage),
        icon: (icon != null ? icon.value : this.icon),
        userId: (userId != null ? userId.value : this.userId),
        eventType: (eventType != null ? eventType.value : this.eventType),
        deliveryStatus: (deliveryStatus != null
            ? deliveryStatus.value
            : this.deliveryStatus),
        deliveryErrors: (deliveryErrors != null
            ? deliveryErrors.value
            : this.deliveryErrors),
        deviceIcon: (deviceIcon != null ? deviceIcon.value : this.deviceIcon),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredEventArray {
  const TriggeredEventArray({
    this.values,
  });

  factory TriggeredEventArray.fromJson(Map<String, dynamic> json) =>
      _$TriggeredEventArrayFromJson(json);

  static const toJsonFactory = _$TriggeredEventArrayToJson;
  Map<String, dynamic> toJson() => _$TriggeredEventArrayToJson(this);

  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <TriggeredEvent>[])
  final List<TriggeredEvent>? values;
  static const fromJsonFactory = _$TriggeredEventArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredEventArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TriggeredEventArrayExtension on TriggeredEventArray {
  TriggeredEventArray copyWith({List<TriggeredEvent>? values}) {
    return TriggeredEventArray(values: values ?? this.values);
  }

  TriggeredEventArray copyWithWrapped(
      {Wrapped<List<TriggeredEvent>?>? values}) {
    return TriggeredEventArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredEventArrayRes {
  const TriggeredEventArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TriggeredEventArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TriggeredEventArrayResFromJson(json);

  static const toJsonFactory = _$TriggeredEventArrayResToJson;
  Map<String, dynamic> toJson() => _$TriggeredEventArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <TriggeredEvent>[])
  final List<TriggeredEvent>? values;
  static const fromJsonFactory = _$TriggeredEventArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredEventArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TriggeredEventArrayResExtension on TriggeredEventArrayRes {
  TriggeredEventArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<TriggeredEvent>? values}) {
    return TriggeredEventArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  TriggeredEventArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<TriggeredEvent>?>? values}) {
    return TriggeredEventArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredControlArray {
  const TriggeredControlArray({
    this.values,
  });

  factory TriggeredControlArray.fromJson(Map<String, dynamic> json) =>
      _$TriggeredControlArrayFromJson(json);

  static const toJsonFactory = _$TriggeredControlArrayToJson;
  Map<String, dynamic> toJson() => _$TriggeredControlArrayToJson(this);

  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <TriggeredControl>[])
  final List<TriggeredControl>? values;
  static const fromJsonFactory = _$TriggeredControlArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredControlArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TriggeredControlArrayExtension on TriggeredControlArray {
  TriggeredControlArray copyWith({List<TriggeredControl>? values}) {
    return TriggeredControlArray(values: values ?? this.values);
  }

  TriggeredControlArray copyWithWrapped(
      {Wrapped<List<TriggeredControl>?>? values}) {
    return TriggeredControlArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TriggeredControlArrayRes {
  const TriggeredControlArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TriggeredControlArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TriggeredControlArrayResFromJson(json);

  static const toJsonFactory = _$TriggeredControlArrayResToJson;
  Map<String, dynamic> toJson() => _$TriggeredControlArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <TriggeredControl>[])
  final List<TriggeredControl>? values;
  static const fromJsonFactory = _$TriggeredControlArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TriggeredControlArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TriggeredControlArrayResExtension on TriggeredControlArrayRes {
  TriggeredControlArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<TriggeredControl>? values}) {
    return TriggeredControlArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  TriggeredControlArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<TriggeredControl>?>? values}) {
    return TriggeredControlArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class NoCodeInfo {
  const NoCodeInfo({
    required this.orgId,
    required this.stripeCustomerId,
    required this.production,
  });

  factory NoCodeInfo.fromJson(Map<String, dynamic> json) =>
      _$NoCodeInfoFromJson(json);

  static const toJsonFactory = _$NoCodeInfoToJson;
  Map<String, dynamic> toJson() => _$NoCodeInfoToJson(this);

  @JsonKey(name: 'orgId', includeIfNull: false, defaultValue: '')
  final String orgId;
  @JsonKey(name: 'stripeCustomerId', includeIfNull: false, defaultValue: '')
  final String stripeCustomerId;
  @JsonKey(name: 'production', includeIfNull: false)
  final bool production;
  static const fromJsonFactory = _$NoCodeInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NoCodeInfo &&
            (identical(other.orgId, orgId) ||
                const DeepCollectionEquality().equals(other.orgId, orgId)) &&
            (identical(other.stripeCustomerId, stripeCustomerId) ||
                const DeepCollectionEquality()
                    .equals(other.stripeCustomerId, stripeCustomerId)) &&
            (identical(other.production, production) ||
                const DeepCollectionEquality()
                    .equals(other.production, production)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(orgId) ^
      const DeepCollectionEquality().hash(stripeCustomerId) ^
      const DeepCollectionEquality().hash(production) ^
      runtimeType.hashCode;
}

extension $NoCodeInfoExtension on NoCodeInfo {
  NoCodeInfo copyWith(
      {String? orgId, String? stripeCustomerId, bool? production}) {
    return NoCodeInfo(
        orgId: orgId ?? this.orgId,
        stripeCustomerId: stripeCustomerId ?? this.stripeCustomerId,
        production: production ?? this.production);
  }

  NoCodeInfo copyWithWrapped(
      {Wrapped<String>? orgId,
      Wrapped<String>? stripeCustomerId,
      Wrapped<bool>? production}) {
    return NoCodeInfo(
        orgId: (orgId != null ? orgId.value : this.orgId),
        stripeCustomerId: (stripeCustomerId != null
            ? stripeCustomerId.value
            : this.stripeCustomerId),
        production: (production != null ? production.value : this.production));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinInfo {
  const TwinInfo({
    required this.twinDomainKey,
    required this.twinApiKey,
    required this.twinAccountId,
    required this.twinPlanId,
    this.stripeUserSubscriptionId,
    this.stripeDeviceSubscriptionId,
  });

  factory TwinInfo.fromJson(Map<String, dynamic> json) =>
      _$TwinInfoFromJson(json);

  static const toJsonFactory = _$TwinInfoToJson;
  Map<String, dynamic> toJson() => _$TwinInfoToJson(this);

  @JsonKey(name: 'twinDomainKey', includeIfNull: false, defaultValue: '')
  final String twinDomainKey;
  @JsonKey(name: 'twinApiKey', includeIfNull: false, defaultValue: '')
  final String twinApiKey;
  @JsonKey(name: 'twinAccountId', includeIfNull: false, defaultValue: '')
  final String twinAccountId;
  @JsonKey(name: 'twinPlanId', includeIfNull: false, defaultValue: '')
  final String twinPlanId;
  @JsonKey(
      name: 'stripeUserSubscriptionId', includeIfNull: false, defaultValue: '')
  final String? stripeUserSubscriptionId;
  @JsonKey(
      name: 'stripeDeviceSubscriptionId',
      includeIfNull: false,
      defaultValue: '')
  final String? stripeDeviceSubscriptionId;
  static const fromJsonFactory = _$TwinInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinInfo &&
            (identical(other.twinDomainKey, twinDomainKey) ||
                const DeepCollectionEquality()
                    .equals(other.twinDomainKey, twinDomainKey)) &&
            (identical(other.twinApiKey, twinApiKey) ||
                const DeepCollectionEquality()
                    .equals(other.twinApiKey, twinApiKey)) &&
            (identical(other.twinAccountId, twinAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.twinAccountId, twinAccountId)) &&
            (identical(other.twinPlanId, twinPlanId) ||
                const DeepCollectionEquality()
                    .equals(other.twinPlanId, twinPlanId)) &&
            (identical(
                    other.stripeUserSubscriptionId, stripeUserSubscriptionId) ||
                const DeepCollectionEquality().equals(
                    other.stripeUserSubscriptionId,
                    stripeUserSubscriptionId)) &&
            (identical(other.stripeDeviceSubscriptionId,
                    stripeDeviceSubscriptionId) ||
                const DeepCollectionEquality().equals(
                    other.stripeDeviceSubscriptionId,
                    stripeDeviceSubscriptionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(twinDomainKey) ^
      const DeepCollectionEquality().hash(twinApiKey) ^
      const DeepCollectionEquality().hash(twinAccountId) ^
      const DeepCollectionEquality().hash(twinPlanId) ^
      const DeepCollectionEquality().hash(stripeUserSubscriptionId) ^
      const DeepCollectionEquality().hash(stripeDeviceSubscriptionId) ^
      runtimeType.hashCode;
}

extension $TwinInfoExtension on TwinInfo {
  TwinInfo copyWith(
      {String? twinDomainKey,
      String? twinApiKey,
      String? twinAccountId,
      String? twinPlanId,
      String? stripeUserSubscriptionId,
      String? stripeDeviceSubscriptionId}) {
    return TwinInfo(
        twinDomainKey: twinDomainKey ?? this.twinDomainKey,
        twinApiKey: twinApiKey ?? this.twinApiKey,
        twinAccountId: twinAccountId ?? this.twinAccountId,
        twinPlanId: twinPlanId ?? this.twinPlanId,
        stripeUserSubscriptionId:
            stripeUserSubscriptionId ?? this.stripeUserSubscriptionId,
        stripeDeviceSubscriptionId:
            stripeDeviceSubscriptionId ?? this.stripeDeviceSubscriptionId);
  }

  TwinInfo copyWithWrapped(
      {Wrapped<String>? twinDomainKey,
      Wrapped<String>? twinApiKey,
      Wrapped<String>? twinAccountId,
      Wrapped<String>? twinPlanId,
      Wrapped<String?>? stripeUserSubscriptionId,
      Wrapped<String?>? stripeDeviceSubscriptionId}) {
    return TwinInfo(
        twinDomainKey:
            (twinDomainKey != null ? twinDomainKey.value : this.twinDomainKey),
        twinApiKey: (twinApiKey != null ? twinApiKey.value : this.twinApiKey),
        twinAccountId:
            (twinAccountId != null ? twinAccountId.value : this.twinAccountId),
        twinPlanId: (twinPlanId != null ? twinPlanId.value : this.twinPlanId),
        stripeUserSubscriptionId: (stripeUserSubscriptionId != null
            ? stripeUserSubscriptionId.value
            : this.stripeUserSubscriptionId),
        stripeDeviceSubscriptionId: (stripeDeviceSubscriptionId != null
            ? stripeDeviceSubscriptionId.value
            : this.stripeDeviceSubscriptionId));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinInfoRes {
  const TwinInfoRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.twinDomainKey,
    required this.twinApiKey,
    required this.twinAccountId,
    required this.twinPlanId,
    this.stripeUserSubscriptionId,
    this.stripeDeviceSubscriptionId,
  });

  factory TwinInfoRes.fromJson(Map<String, dynamic> json) =>
      _$TwinInfoResFromJson(json);

  static const toJsonFactory = _$TwinInfoResToJson;
  Map<String, dynamic> toJson() => _$TwinInfoResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'twinDomainKey', includeIfNull: false, defaultValue: '')
  final String twinDomainKey;
  @JsonKey(name: 'twinApiKey', includeIfNull: false, defaultValue: '')
  final String twinApiKey;
  @JsonKey(name: 'twinAccountId', includeIfNull: false, defaultValue: '')
  final String twinAccountId;
  @JsonKey(name: 'twinPlanId', includeIfNull: false, defaultValue: '')
  final String twinPlanId;
  @JsonKey(
      name: 'stripeUserSubscriptionId', includeIfNull: false, defaultValue: '')
  final String? stripeUserSubscriptionId;
  @JsonKey(
      name: 'stripeDeviceSubscriptionId',
      includeIfNull: false,
      defaultValue: '')
  final String? stripeDeviceSubscriptionId;
  static const fromJsonFactory = _$TwinInfoResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinInfoRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.twinDomainKey, twinDomainKey) ||
                const DeepCollectionEquality()
                    .equals(other.twinDomainKey, twinDomainKey)) &&
            (identical(other.twinApiKey, twinApiKey) ||
                const DeepCollectionEquality()
                    .equals(other.twinApiKey, twinApiKey)) &&
            (identical(other.twinAccountId, twinAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.twinAccountId, twinAccountId)) &&
            (identical(other.twinPlanId, twinPlanId) ||
                const DeepCollectionEquality()
                    .equals(other.twinPlanId, twinPlanId)) &&
            (identical(
                    other.stripeUserSubscriptionId, stripeUserSubscriptionId) ||
                const DeepCollectionEquality().equals(
                    other.stripeUserSubscriptionId,
                    stripeUserSubscriptionId)) &&
            (identical(other.stripeDeviceSubscriptionId,
                    stripeDeviceSubscriptionId) ||
                const DeepCollectionEquality().equals(
                    other.stripeDeviceSubscriptionId,
                    stripeDeviceSubscriptionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(twinDomainKey) ^
      const DeepCollectionEquality().hash(twinApiKey) ^
      const DeepCollectionEquality().hash(twinAccountId) ^
      const DeepCollectionEquality().hash(twinPlanId) ^
      const DeepCollectionEquality().hash(stripeUserSubscriptionId) ^
      const DeepCollectionEquality().hash(stripeDeviceSubscriptionId) ^
      runtimeType.hashCode;
}

extension $TwinInfoResExtension on TwinInfoRes {
  TwinInfoRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      String? twinDomainKey,
      String? twinApiKey,
      String? twinAccountId,
      String? twinPlanId,
      String? stripeUserSubscriptionId,
      String? stripeDeviceSubscriptionId}) {
    return TwinInfoRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        twinDomainKey: twinDomainKey ?? this.twinDomainKey,
        twinApiKey: twinApiKey ?? this.twinApiKey,
        twinAccountId: twinAccountId ?? this.twinAccountId,
        twinPlanId: twinPlanId ?? this.twinPlanId,
        stripeUserSubscriptionId:
            stripeUserSubscriptionId ?? this.stripeUserSubscriptionId,
        stripeDeviceSubscriptionId:
            stripeDeviceSubscriptionId ?? this.stripeDeviceSubscriptionId);
  }

  TwinInfoRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<String>? twinDomainKey,
      Wrapped<String>? twinApiKey,
      Wrapped<String>? twinAccountId,
      Wrapped<String>? twinPlanId,
      Wrapped<String?>? stripeUserSubscriptionId,
      Wrapped<String?>? stripeDeviceSubscriptionId}) {
    return TwinInfoRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        twinDomainKey:
            (twinDomainKey != null ? twinDomainKey.value : this.twinDomainKey),
        twinApiKey: (twinApiKey != null ? twinApiKey.value : this.twinApiKey),
        twinAccountId:
            (twinAccountId != null ? twinAccountId.value : this.twinAccountId),
        twinPlanId: (twinPlanId != null ? twinPlanId.value : this.twinPlanId),
        stripeUserSubscriptionId: (stripeUserSubscriptionId != null
            ? stripeUserSubscriptionId.value
            : this.stripeUserSubscriptionId),
        stripeDeviceSubscriptionId: (stripeDeviceSubscriptionId != null
            ? stripeDeviceSubscriptionId.value
            : this.stripeDeviceSubscriptionId));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetInfo {
  const DisplayWidgetInfo({
    required this.name,
    this.description,
    this.label,
    required this.modelId,
    this.tags,
    this.tooltip,
    required this.widgetType,
    required this.attributes,
  });

  factory DisplayWidgetInfo.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetInfoFromJson(json);

  static const toJsonFactory = _$DisplayWidgetInfoToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'widgetType', includeIfNull: false, defaultValue: '')
  final String widgetType;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  static const fromJsonFactory = _$DisplayWidgetInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality()
                    .equals(other.tooltip, tooltip)) &&
            (identical(other.widgetType, widgetType) ||
                const DeepCollectionEquality()
                    .equals(other.widgetType, widgetType)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality()
                    .equals(other.attributes, attributes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(widgetType) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $DisplayWidgetInfoExtension on DisplayWidgetInfo {
  DisplayWidgetInfo copyWith(
      {String? name,
      String? description,
      String? label,
      String? modelId,
      List<String>? tags,
      String? tooltip,
      String? widgetType,
      Object? attributes}) {
    return DisplayWidgetInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        modelId: modelId ?? this.modelId,
        tags: tags ?? this.tags,
        tooltip: tooltip ?? this.tooltip,
        widgetType: widgetType ?? this.widgetType,
        attributes: attributes ?? this.attributes);
  }

  DisplayWidgetInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<String>? modelId,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? tooltip,
      Wrapped<String>? widgetType,
      Wrapped<Object>? attributes}) {
    return DisplayWidgetInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        modelId: (modelId != null ? modelId.value : this.modelId),
        tags: (tags != null ? tags.value : this.tags),
        tooltip: (tooltip != null ? tooltip.value : this.tooltip),
        widgetType: (widgetType != null ? widgetType.value : this.widgetType),
        attributes: (attributes != null ? attributes.value : this.attributes));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidget {
  const DisplayWidget({
    required this.name,
    this.description,
    this.label,
    required this.modelId,
    this.tags,
    this.tooltip,
    required this.widgetType,
    required this.attributes,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory DisplayWidget.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetFromJson(json);

  static const toJsonFactory = _$DisplayWidgetToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'widgetType', includeIfNull: false, defaultValue: '')
  final String widgetType;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$DisplayWidgetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidget &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality()
                    .equals(other.tooltip, tooltip)) &&
            (identical(other.widgetType, widgetType) ||
                const DeepCollectionEquality()
                    .equals(other.widgetType, widgetType)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality()
                    .equals(other.attributes, attributes)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(widgetType) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $DisplayWidgetExtension on DisplayWidget {
  DisplayWidget copyWith(
      {String? name,
      String? description,
      String? label,
      String? modelId,
      List<String>? tags,
      String? tooltip,
      String? widgetType,
      Object? attributes,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return DisplayWidget(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        modelId: modelId ?? this.modelId,
        tags: tags ?? this.tags,
        tooltip: tooltip ?? this.tooltip,
        widgetType: widgetType ?? this.widgetType,
        attributes: attributes ?? this.attributes,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  DisplayWidget copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<String>? modelId,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? tooltip,
      Wrapped<String>? widgetType,
      Wrapped<Object>? attributes,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return DisplayWidget(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        modelId: (modelId != null ? modelId.value : this.modelId),
        tags: (tags != null ? tags.value : this.tags),
        tooltip: (tooltip != null ? tooltip.value : this.tooltip),
        widgetType: (widgetType != null ? widgetType.value : this.widgetType),
        attributes: (attributes != null ? attributes.value : this.attributes),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetEntity {
  const DisplayWidgetEntity({
    this.entity,
  });

  factory DisplayWidgetEntity.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetEntityFromJson(json);

  static const toJsonFactory = _$DisplayWidgetEntityToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DisplayWidget? entity;
  static const fromJsonFactory = _$DisplayWidgetEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DisplayWidgetEntityExtension on DisplayWidgetEntity {
  DisplayWidgetEntity copyWith({DisplayWidget? entity}) {
    return DisplayWidgetEntity(entity: entity ?? this.entity);
  }

  DisplayWidgetEntity copyWithWrapped({Wrapped<DisplayWidget?>? entity}) {
    return DisplayWidgetEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetEntityRes {
  const DisplayWidgetEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DisplayWidgetEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetEntityResFromJson(json);

  static const toJsonFactory = _$DisplayWidgetEntityResToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DisplayWidget? entity;
  static const fromJsonFactory = _$DisplayWidgetEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DisplayWidgetEntityResExtension on DisplayWidgetEntityRes {
  DisplayWidgetEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      DisplayWidget? entity}) {
    return DisplayWidgetEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  DisplayWidgetEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<DisplayWidget?>? entity}) {
    return DisplayWidgetEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetArray {
  const DisplayWidgetArray({
    this.values,
  });

  factory DisplayWidgetArray.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetArrayFromJson(json);

  static const toJsonFactory = _$DisplayWidgetArrayToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetArrayToJson(this);

  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <DisplayWidget>[])
  final List<DisplayWidget>? values;
  static const fromJsonFactory = _$DisplayWidgetArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DisplayWidgetArrayExtension on DisplayWidgetArray {
  DisplayWidgetArray copyWith({List<DisplayWidget>? values}) {
    return DisplayWidgetArray(values: values ?? this.values);
  }

  DisplayWidgetArray copyWithWrapped({Wrapped<List<DisplayWidget>?>? values}) {
    return DisplayWidgetArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayWidgetArrayRes {
  const DisplayWidgetArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DisplayWidgetArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DisplayWidgetArrayResFromJson(json);

  static const toJsonFactory = _$DisplayWidgetArrayResToJson;
  Map<String, dynamic> toJson() => _$DisplayWidgetArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <DisplayWidget>[])
  final List<DisplayWidget>? values;
  static const fromJsonFactory = _$DisplayWidgetArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayWidgetArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DisplayWidgetArrayResExtension on DisplayWidgetArrayRes {
  DisplayWidgetArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<DisplayWidget>? values}) {
    return DisplayWidgetArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  DisplayWidgetArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<DisplayWidget>?>? values}) {
    return DisplayWidgetArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetInfo {
  const ScreenWidgetInfo({
    required this.name,
    this.description,
    this.label,
    this.tags,
    this.tooltip,
    required this.widgetType,
    required this.attributes,
    this.target,
  });

  factory ScreenWidgetInfo.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetInfoFromJson(json);

  static const toJsonFactory = _$ScreenWidgetInfoToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'widgetType', includeIfNull: false, defaultValue: '')
  final String widgetType;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: screenWidgetInfoTargetNullableToJson,
    fromJson: screenWidgetInfoTargetNullableFromJson,
  )
  final enums.ScreenWidgetInfoTarget? target;
  static const fromJsonFactory = _$ScreenWidgetInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality()
                    .equals(other.tooltip, tooltip)) &&
            (identical(other.widgetType, widgetType) ||
                const DeepCollectionEquality()
                    .equals(other.widgetType, widgetType)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality()
                    .equals(other.attributes, attributes)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(widgetType) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(target) ^
      runtimeType.hashCode;
}

extension $ScreenWidgetInfoExtension on ScreenWidgetInfo {
  ScreenWidgetInfo copyWith(
      {String? name,
      String? description,
      String? label,
      List<String>? tags,
      String? tooltip,
      String? widgetType,
      Object? attributes,
      enums.ScreenWidgetInfoTarget? target}) {
    return ScreenWidgetInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        tags: tags ?? this.tags,
        tooltip: tooltip ?? this.tooltip,
        widgetType: widgetType ?? this.widgetType,
        attributes: attributes ?? this.attributes,
        target: target ?? this.target);
  }

  ScreenWidgetInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? tooltip,
      Wrapped<String>? widgetType,
      Wrapped<Object>? attributes,
      Wrapped<enums.ScreenWidgetInfoTarget?>? target}) {
    return ScreenWidgetInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        tags: (tags != null ? tags.value : this.tags),
        tooltip: (tooltip != null ? tooltip.value : this.tooltip),
        widgetType: (widgetType != null ? widgetType.value : this.widgetType),
        attributes: (attributes != null ? attributes.value : this.attributes),
        target: (target != null ? target.value : this.target));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidget {
  const ScreenWidget({
    required this.name,
    this.description,
    this.label,
    this.tags,
    this.tooltip,
    required this.widgetType,
    required this.attributes,
    this.target,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory ScreenWidget.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetFromJson(json);

  static const toJsonFactory = _$ScreenWidgetToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'tooltip', includeIfNull: false, defaultValue: '')
  final String? tooltip;
  @JsonKey(name: 'widgetType', includeIfNull: false, defaultValue: '')
  final String widgetType;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: screenWidgetTargetNullableToJson,
    fromJson: screenWidgetTargetNullableFromJson,
  )
  final enums.ScreenWidgetTarget? target;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$ScreenWidgetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidget &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.tooltip, tooltip) ||
                const DeepCollectionEquality()
                    .equals(other.tooltip, tooltip)) &&
            (identical(other.widgetType, widgetType) ||
                const DeepCollectionEquality()
                    .equals(other.widgetType, widgetType)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality()
                    .equals(other.attributes, attributes)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(tooltip) ^
      const DeepCollectionEquality().hash(widgetType) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $ScreenWidgetExtension on ScreenWidget {
  ScreenWidget copyWith(
      {String? name,
      String? description,
      String? label,
      List<String>? tags,
      String? tooltip,
      String? widgetType,
      Object? attributes,
      enums.ScreenWidgetTarget? target,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return ScreenWidget(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        tags: tags ?? this.tags,
        tooltip: tooltip ?? this.tooltip,
        widgetType: widgetType ?? this.widgetType,
        attributes: attributes ?? this.attributes,
        target: target ?? this.target,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  ScreenWidget copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? tooltip,
      Wrapped<String>? widgetType,
      Wrapped<Object>? attributes,
      Wrapped<enums.ScreenWidgetTarget?>? target,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return ScreenWidget(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        tags: (tags != null ? tags.value : this.tags),
        tooltip: (tooltip != null ? tooltip.value : this.tooltip),
        widgetType: (widgetType != null ? widgetType.value : this.widgetType),
        attributes: (attributes != null ? attributes.value : this.attributes),
        target: (target != null ? target.value : this.target),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetEntity {
  const ScreenWidgetEntity({
    this.entity,
  });

  factory ScreenWidgetEntity.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetEntityFromJson(json);

  static const toJsonFactory = _$ScreenWidgetEntityToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ScreenWidget? entity;
  static const fromJsonFactory = _$ScreenWidgetEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ScreenWidgetEntityExtension on ScreenWidgetEntity {
  ScreenWidgetEntity copyWith({ScreenWidget? entity}) {
    return ScreenWidgetEntity(entity: entity ?? this.entity);
  }

  ScreenWidgetEntity copyWithWrapped({Wrapped<ScreenWidget?>? entity}) {
    return ScreenWidgetEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetEntityRes {
  const ScreenWidgetEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ScreenWidgetEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetEntityResFromJson(json);

  static const toJsonFactory = _$ScreenWidgetEntityResToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final ScreenWidget? entity;
  static const fromJsonFactory = _$ScreenWidgetEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ScreenWidgetEntityResExtension on ScreenWidgetEntityRes {
  ScreenWidgetEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      ScreenWidget? entity}) {
    return ScreenWidgetEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  ScreenWidgetEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<ScreenWidget?>? entity}) {
    return ScreenWidgetEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetArray {
  const ScreenWidgetArray({
    this.values,
  });

  factory ScreenWidgetArray.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetArrayFromJson(json);

  static const toJsonFactory = _$ScreenWidgetArrayToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <ScreenWidget>[])
  final List<ScreenWidget>? values;
  static const fromJsonFactory = _$ScreenWidgetArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ScreenWidgetArrayExtension on ScreenWidgetArray {
  ScreenWidgetArray copyWith({List<ScreenWidget>? values}) {
    return ScreenWidgetArray(values: values ?? this.values);
  }

  ScreenWidgetArray copyWithWrapped({Wrapped<List<ScreenWidget>?>? values}) {
    return ScreenWidgetArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenWidgetArrayRes {
  const ScreenWidgetArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ScreenWidgetArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ScreenWidgetArrayResFromJson(json);

  static const toJsonFactory = _$ScreenWidgetArrayResToJson;
  Map<String, dynamic> toJson() => _$ScreenWidgetArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <ScreenWidget>[])
  final List<ScreenWidget>? values;
  static const fromJsonFactory = _$ScreenWidgetArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenWidgetArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ScreenWidgetArrayResExtension on ScreenWidgetArrayRes {
  ScreenWidgetArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<ScreenWidget>? values}) {
    return ScreenWidgetArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  ScreenWidgetArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<ScreenWidget>?>? values}) {
    return ScreenWidgetArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoLocation {
  const GeoLocation({
    this.type,
    required this.coordinates,
  });

  factory GeoLocation.fromJson(Map<String, dynamic> json) =>
      _$GeoLocationFromJson(json);

  static const toJsonFactory = _$GeoLocationToJson;
  Map<String, dynamic> toJson() => _$GeoLocationToJson(this);

  @JsonKey(name: 'type', includeIfNull: false, defaultValue: '')
  final String? type;
  @JsonKey(name: 'coordinates', includeIfNull: false, defaultValue: <double>[])
  final List<double> coordinates;
  static const fromJsonFactory = _$GeoLocationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoLocation &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.coordinates, coordinates) ||
                const DeepCollectionEquality()
                    .equals(other.coordinates, coordinates)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(coordinates) ^
      runtimeType.hashCode;
}

extension $GeoLocationExtension on GeoLocation {
  GeoLocation copyWith({String? type, List<double>? coordinates}) {
    return GeoLocation(
        type: type ?? this.type, coordinates: coordinates ?? this.coordinates);
  }

  GeoLocation copyWithWrapped(
      {Wrapped<String?>? type, Wrapped<List<double>>? coordinates}) {
    return GeoLocation(
        type: (type != null ? type.value : this.type),
        coordinates:
            (coordinates != null ? coordinates.value : this.coordinates));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoLine {
  const GeoLine({
    required this.begin,
    required this.end,
  });

  factory GeoLine.fromJson(Map<String, dynamic> json) =>
      _$GeoLineFromJson(json);

  static const toJsonFactory = _$GeoLineToJson;
  Map<String, dynamic> toJson() => _$GeoLineToJson(this);

  @JsonKey(name: 'begin', includeIfNull: false)
  final GeoLocation begin;
  @JsonKey(name: 'end', includeIfNull: false)
  final GeoLocation end;
  static const fromJsonFactory = _$GeoLineFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoLine &&
            (identical(other.begin, begin) ||
                const DeepCollectionEquality().equals(other.begin, begin)) &&
            (identical(other.end, end) ||
                const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(begin) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $GeoLineExtension on GeoLine {
  GeoLine copyWith({GeoLocation? begin, GeoLocation? end}) {
    return GeoLine(begin: begin ?? this.begin, end: end ?? this.end);
  }

  GeoLine copyWithWrapped(
      {Wrapped<GeoLocation>? begin, Wrapped<GeoLocation>? end}) {
    return GeoLine(
        begin: (begin != null ? begin.value : this.begin),
        end: (end != null ? end.value : this.end));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoEnvelope {
  const GeoEnvelope({
    required this.leftTop,
    required this.rightBottom,
  });

  factory GeoEnvelope.fromJson(Map<String, dynamic> json) =>
      _$GeoEnvelopeFromJson(json);

  static const toJsonFactory = _$GeoEnvelopeToJson;
  Map<String, dynamic> toJson() => _$GeoEnvelopeToJson(this);

  @JsonKey(name: 'leftTop', includeIfNull: false)
  final GeoLocation leftTop;
  @JsonKey(name: 'rightBottom', includeIfNull: false)
  final GeoLocation rightBottom;
  static const fromJsonFactory = _$GeoEnvelopeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoEnvelope &&
            (identical(other.leftTop, leftTop) ||
                const DeepCollectionEquality()
                    .equals(other.leftTop, leftTop)) &&
            (identical(other.rightBottom, rightBottom) ||
                const DeepCollectionEquality()
                    .equals(other.rightBottom, rightBottom)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(leftTop) ^
      const DeepCollectionEquality().hash(rightBottom) ^
      runtimeType.hashCode;
}

extension $GeoEnvelopeExtension on GeoEnvelope {
  GeoEnvelope copyWith({GeoLocation? leftTop, GeoLocation? rightBottom}) {
    return GeoEnvelope(
        leftTop: leftTop ?? this.leftTop,
        rightBottom: rightBottom ?? this.rightBottom);
  }

  GeoEnvelope copyWithWrapped(
      {Wrapped<GeoLocation>? leftTop, Wrapped<GeoLocation>? rightBottom}) {
    return GeoEnvelope(
        leftTop: (leftTop != null ? leftTop.value : this.leftTop),
        rightBottom:
            (rightBottom != null ? rightBottom.value : this.rightBottom));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoPolygon {
  const GeoPolygon({
    required this.points,
  });

  factory GeoPolygon.fromJson(Map<String, dynamic> json) =>
      _$GeoPolygonFromJson(json);

  static const toJsonFactory = _$GeoPolygonToJson;
  Map<String, dynamic> toJson() => _$GeoPolygonToJson(this);

  @JsonKey(name: 'points', includeIfNull: false, defaultValue: <GeoLocation>[])
  final List<GeoLocation> points;
  static const fromJsonFactory = _$GeoPolygonFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoPolygon &&
            (identical(other.points, points) ||
                const DeepCollectionEquality().equals(other.points, points)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(points) ^ runtimeType.hashCode;
}

extension $GeoPolygonExtension on GeoPolygon {
  GeoPolygon copyWith({List<GeoLocation>? points}) {
    return GeoPolygon(points: points ?? this.points);
  }

  GeoPolygon copyWithWrapped({Wrapped<List<GeoLocation>>? points}) {
    return GeoPolygon(points: (points != null ? points.value : this.points));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoMultiPoint {
  const GeoMultiPoint({
    required this.first,
    required this.second,
  });

  factory GeoMultiPoint.fromJson(Map<String, dynamic> json) =>
      _$GeoMultiPointFromJson(json);

  static const toJsonFactory = _$GeoMultiPointToJson;
  Map<String, dynamic> toJson() => _$GeoMultiPointToJson(this);

  @JsonKey(name: 'first', includeIfNull: false)
  final GeoLocation first;
  @JsonKey(name: 'second', includeIfNull: false)
  final GeoLocation second;
  static const fromJsonFactory = _$GeoMultiPointFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoMultiPoint &&
            (identical(other.first, first) ||
                const DeepCollectionEquality().equals(other.first, first)) &&
            (identical(other.second, second) ||
                const DeepCollectionEquality().equals(other.second, second)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(first) ^
      const DeepCollectionEquality().hash(second) ^
      runtimeType.hashCode;
}

extension $GeoMultiPointExtension on GeoMultiPoint {
  GeoMultiPoint copyWith({GeoLocation? first, GeoLocation? second}) {
    return GeoMultiPoint(
        first: first ?? this.first, second: second ?? this.second);
  }

  GeoMultiPoint copyWithWrapped(
      {Wrapped<GeoLocation>? first, Wrapped<GeoLocation>? second}) {
    return GeoMultiPoint(
        first: (first != null ? first.value : this.first),
        second: (second != null ? second.value : this.second));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoMultiLine {
  const GeoMultiLine({
    required this.points,
  });

  factory GeoMultiLine.fromJson(Map<String, dynamic> json) =>
      _$GeoMultiLineFromJson(json);

  static const toJsonFactory = _$GeoMultiLineToJson;
  Map<String, dynamic> toJson() => _$GeoMultiLineToJson(this);

  @JsonKey(name: 'points', includeIfNull: false, defaultValue: <GeoLine>[])
  final List<GeoLine> points;
  static const fromJsonFactory = _$GeoMultiLineFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoMultiLine &&
            (identical(other.points, points) ||
                const DeepCollectionEquality().equals(other.points, points)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(points) ^ runtimeType.hashCode;
}

extension $GeoMultiLineExtension on GeoMultiLine {
  GeoMultiLine copyWith({List<GeoLine>? points}) {
    return GeoMultiLine(points: points ?? this.points);
  }

  GeoMultiLine copyWithWrapped({Wrapped<List<GeoLine>>? points}) {
    return GeoMultiLine(points: (points != null ? points.value : this.points));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoMultiPolygon {
  const GeoMultiPolygon({
    required this.points,
  });

  factory GeoMultiPolygon.fromJson(Map<String, dynamic> json) =>
      _$GeoMultiPolygonFromJson(json);

  static const toJsonFactory = _$GeoMultiPolygonToJson;
  Map<String, dynamic> toJson() => _$GeoMultiPolygonToJson(this);

  @JsonKey(name: 'points', includeIfNull: false, defaultValue: <GeoPolygon>[])
  final List<GeoPolygon> points;
  static const fromJsonFactory = _$GeoMultiPolygonFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoMultiPolygon &&
            (identical(other.points, points) ||
                const DeepCollectionEquality().equals(other.points, points)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(points) ^ runtimeType.hashCode;
}

extension $GeoMultiPolygonExtension on GeoMultiPolygon {
  GeoMultiPolygon copyWith({List<GeoPolygon>? points}) {
    return GeoMultiPolygon(points: points ?? this.points);
  }

  GeoMultiPolygon copyWithWrapped({Wrapped<List<GeoPolygon>>? points}) {
    return GeoMultiPolygon(
        points: (points != null ? points.value : this.points));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoCircle {
  const GeoCircle({
    required this.center,
    required this.radius,
  });

  factory GeoCircle.fromJson(Map<String, dynamic> json) =>
      _$GeoCircleFromJson(json);

  static const toJsonFactory = _$GeoCircleToJson;
  Map<String, dynamic> toJson() => _$GeoCircleToJson(this);

  @JsonKey(name: 'center', includeIfNull: false)
  final GeoLocation center;
  @JsonKey(name: 'radius', includeIfNull: false)
  final int radius;
  static const fromJsonFactory = _$GeoCircleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoCircle &&
            (identical(other.center, center) ||
                const DeepCollectionEquality().equals(other.center, center)) &&
            (identical(other.radius, radius) ||
                const DeepCollectionEquality().equals(other.radius, radius)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(center) ^
      const DeepCollectionEquality().hash(radius) ^
      runtimeType.hashCode;
}

extension $GeoCircleExtension on GeoCircle {
  GeoCircle copyWith({GeoLocation? center, int? radius}) {
    return GeoCircle(
        center: center ?? this.center, radius: radius ?? this.radius);
  }

  GeoCircle copyWithWrapped(
      {Wrapped<GeoLocation>? center, Wrapped<int>? radius}) {
    return GeoCircle(
        center: (center != null ? center.value : this.center),
        radius: (radius != null ? radius.value : this.radius));
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorInfo {
  const PreprocessorInfo({
    required this.name,
    required this.className,
    this.code,
    this.description,
    this.tags,
  });

  factory PreprocessorInfo.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorInfoFromJson(json);

  static const toJsonFactory = _$PreprocessorInfoToJson;
  Map<String, dynamic> toJson() => _$PreprocessorInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'className', includeIfNull: false, defaultValue: '')
  final String className;
  @JsonKey(name: 'code', includeIfNull: false, defaultValue: '')
  final String? code;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$PreprocessorInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.className, className) ||
                const DeepCollectionEquality()
                    .equals(other.className, className)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(className) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $PreprocessorInfoExtension on PreprocessorInfo {
  PreprocessorInfo copyWith(
      {String? name,
      String? className,
      String? code,
      String? description,
      List<String>? tags}) {
    return PreprocessorInfo(
        name: name ?? this.name,
        className: className ?? this.className,
        code: code ?? this.code,
        description: description ?? this.description,
        tags: tags ?? this.tags);
  }

  PreprocessorInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? className,
      Wrapped<String?>? code,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags}) {
    return PreprocessorInfo(
        name: (name != null ? name.value : this.name),
        className: (className != null ? className.value : this.className),
        code: (code != null ? code.value : this.code),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class Preprocessor {
  const Preprocessor({
    required this.name,
    required this.className,
    this.code,
    this.description,
    this.tags,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Preprocessor.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorFromJson(json);

  static const toJsonFactory = _$PreprocessorToJson;
  Map<String, dynamic> toJson() => _$PreprocessorToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'className', includeIfNull: false, defaultValue: '')
  final String className;
  @JsonKey(name: 'code', includeIfNull: false, defaultValue: '')
  final String? code;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$PreprocessorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Preprocessor &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.className, className) ||
                const DeepCollectionEquality()
                    .equals(other.className, className)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(className) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $PreprocessorExtension on Preprocessor {
  Preprocessor copyWith(
      {String? name,
      String? className,
      String? code,
      String? description,
      List<String>? tags,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Preprocessor(
        name: name ?? this.name,
        className: className ?? this.className,
        code: code ?? this.code,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Preprocessor copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? className,
      Wrapped<String?>? code,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Preprocessor(
        name: (name != null ? name.value : this.name),
        className: (className != null ? className.value : this.className),
        code: (code != null ? code.value : this.code),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorEntity {
  const PreprocessorEntity({
    this.entity,
  });

  factory PreprocessorEntity.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorEntityFromJson(json);

  static const toJsonFactory = _$PreprocessorEntityToJson;
  Map<String, dynamic> toJson() => _$PreprocessorEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Preprocessor? entity;
  static const fromJsonFactory = _$PreprocessorEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $PreprocessorEntityExtension on PreprocessorEntity {
  PreprocessorEntity copyWith({Preprocessor? entity}) {
    return PreprocessorEntity(entity: entity ?? this.entity);
  }

  PreprocessorEntity copyWithWrapped({Wrapped<Preprocessor?>? entity}) {
    return PreprocessorEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorEntityRes {
  const PreprocessorEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory PreprocessorEntityRes.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorEntityResFromJson(json);

  static const toJsonFactory = _$PreprocessorEntityResToJson;
  Map<String, dynamic> toJson() => _$PreprocessorEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Preprocessor? entity;
  static const fromJsonFactory = _$PreprocessorEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $PreprocessorEntityResExtension on PreprocessorEntityRes {
  PreprocessorEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Preprocessor? entity}) {
    return PreprocessorEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  PreprocessorEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Preprocessor?>? entity}) {
    return PreprocessorEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorArray {
  const PreprocessorArray({
    this.values,
  });

  factory PreprocessorArray.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorArrayFromJson(json);

  static const toJsonFactory = _$PreprocessorArrayToJson;
  Map<String, dynamic> toJson() => _$PreprocessorArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Preprocessor>[])
  final List<Preprocessor>? values;
  static const fromJsonFactory = _$PreprocessorArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $PreprocessorArrayExtension on PreprocessorArray {
  PreprocessorArray copyWith({List<Preprocessor>? values}) {
    return PreprocessorArray(values: values ?? this.values);
  }

  PreprocessorArray copyWithWrapped({Wrapped<List<Preprocessor>?>? values}) {
    return PreprocessorArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class PreprocessorArrayRes {
  const PreprocessorArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory PreprocessorArrayRes.fromJson(Map<String, dynamic> json) =>
      _$PreprocessorArrayResFromJson(json);

  static const toJsonFactory = _$PreprocessorArrayResToJson;
  Map<String, dynamic> toJson() => _$PreprocessorArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Preprocessor>[])
  final List<Preprocessor>? values;
  static const fromJsonFactory = _$PreprocessorArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreprocessorArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $PreprocessorArrayResExtension on PreprocessorArrayRes {
  PreprocessorArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Preprocessor>? values}) {
    return PreprocessorArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  PreprocessorArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Preprocessor>?>? values}) {
    return PreprocessorArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FilterMatchGroup {
  const FilterMatchGroup({
    required this.matchType,
    this.conditionIds,
  });

  factory FilterMatchGroup.fromJson(Map<String, dynamic> json) =>
      _$FilterMatchGroupFromJson(json);

  static const toJsonFactory = _$FilterMatchGroupToJson;
  Map<String, dynamic> toJson() => _$FilterMatchGroupToJson(this);

  @JsonKey(
    name: 'matchType',
    includeIfNull: false,
    toJson: filterMatchGroupMatchTypeToJson,
    fromJson: filterMatchGroupMatchTypeFromJson,
  )
  final enums.FilterMatchGroupMatchType matchType;
  @JsonKey(name: 'conditionIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? conditionIds;
  static const fromJsonFactory = _$FilterMatchGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterMatchGroup &&
            (identical(other.matchType, matchType) ||
                const DeepCollectionEquality()
                    .equals(other.matchType, matchType)) &&
            (identical(other.conditionIds, conditionIds) ||
                const DeepCollectionEquality()
                    .equals(other.conditionIds, conditionIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(matchType) ^
      const DeepCollectionEquality().hash(conditionIds) ^
      runtimeType.hashCode;
}

extension $FilterMatchGroupExtension on FilterMatchGroup {
  FilterMatchGroup copyWith(
      {enums.FilterMatchGroupMatchType? matchType,
      List<String>? conditionIds}) {
    return FilterMatchGroup(
        matchType: matchType ?? this.matchType,
        conditionIds: conditionIds ?? this.conditionIds);
  }

  FilterMatchGroup copyWithWrapped(
      {Wrapped<enums.FilterMatchGroupMatchType>? matchType,
      Wrapped<List<String>?>? conditionIds}) {
    return FilterMatchGroup(
        matchType: (matchType != null ? matchType.value : this.matchType),
        conditionIds:
            (conditionIds != null ? conditionIds.value : this.conditionIds));
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterInfo {
  const DataFilterInfo({
    required this.modelId,
    required this.name,
    required this.label,
    this.icon,
    this.description,
    this.tags,
    required this.matchGroups,
  });

  factory DataFilterInfo.fromJson(Map<String, dynamic> json) =>
      _$DataFilterInfoFromJson(json);

  static const toJsonFactory = _$DataFilterInfoToJson;
  Map<String, dynamic> toJson() => _$DataFilterInfoToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String label;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
      name: 'matchGroups',
      includeIfNull: false,
      defaultValue: <FilterMatchGroup>[])
  final List<FilterMatchGroup> matchGroups;
  static const fromJsonFactory = _$DataFilterInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterInfo &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.matchGroups, matchGroups) ||
                const DeepCollectionEquality()
                    .equals(other.matchGroups, matchGroups)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(matchGroups) ^
      runtimeType.hashCode;
}

extension $DataFilterInfoExtension on DataFilterInfo {
  DataFilterInfo copyWith(
      {String? modelId,
      String? name,
      String? label,
      String? icon,
      String? description,
      List<String>? tags,
      List<FilterMatchGroup>? matchGroups}) {
    return DataFilterInfo(
        modelId: modelId ?? this.modelId,
        name: name ?? this.name,
        label: label ?? this.label,
        icon: icon ?? this.icon,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        matchGroups: matchGroups ?? this.matchGroups);
  }

  DataFilterInfo copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<String>? name,
      Wrapped<String>? label,
      Wrapped<String?>? icon,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<List<FilterMatchGroup>>? matchGroups}) {
    return DataFilterInfo(
        modelId: (modelId != null ? modelId.value : this.modelId),
        name: (name != null ? name.value : this.name),
        label: (label != null ? label.value : this.label),
        icon: (icon != null ? icon.value : this.icon),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        matchGroups:
            (matchGroups != null ? matchGroups.value : this.matchGroups));
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilter {
  const DataFilter({
    required this.modelId,
    required this.name,
    required this.label,
    this.icon,
    this.description,
    this.tags,
    required this.matchGroups,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory DataFilter.fromJson(Map<String, dynamic> json) =>
      _$DataFilterFromJson(json);

  static const toJsonFactory = _$DataFilterToJson;
  Map<String, dynamic> toJson() => _$DataFilterToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String label;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
      name: 'matchGroups',
      includeIfNull: false,
      defaultValue: <FilterMatchGroup>[])
  final List<FilterMatchGroup> matchGroups;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$DataFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilter &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.matchGroups, matchGroups) ||
                const DeepCollectionEquality()
                    .equals(other.matchGroups, matchGroups)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(matchGroups) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $DataFilterExtension on DataFilter {
  DataFilter copyWith(
      {String? modelId,
      String? name,
      String? label,
      String? icon,
      String? description,
      List<String>? tags,
      List<FilterMatchGroup>? matchGroups,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return DataFilter(
        modelId: modelId ?? this.modelId,
        name: name ?? this.name,
        label: label ?? this.label,
        icon: icon ?? this.icon,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        matchGroups: matchGroups ?? this.matchGroups,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  DataFilter copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<String>? name,
      Wrapped<String>? label,
      Wrapped<String?>? icon,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<List<FilterMatchGroup>>? matchGroups,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return DataFilter(
        modelId: (modelId != null ? modelId.value : this.modelId),
        name: (name != null ? name.value : this.name),
        label: (label != null ? label.value : this.label),
        icon: (icon != null ? icon.value : this.icon),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        matchGroups:
            (matchGroups != null ? matchGroups.value : this.matchGroups),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterEntity {
  const DataFilterEntity({
    this.entity,
  });

  factory DataFilterEntity.fromJson(Map<String, dynamic> json) =>
      _$DataFilterEntityFromJson(json);

  static const toJsonFactory = _$DataFilterEntityToJson;
  Map<String, dynamic> toJson() => _$DataFilterEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final DataFilter? entity;
  static const fromJsonFactory = _$DataFilterEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $DataFilterEntityExtension on DataFilterEntity {
  DataFilterEntity copyWith({DataFilter? entity}) {
    return DataFilterEntity(entity: entity ?? this.entity);
  }

  DataFilterEntity copyWithWrapped({Wrapped<DataFilter?>? entity}) {
    return DataFilterEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterEntityRes {
  const DataFilterEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory DataFilterEntityRes.fromJson(Map<String, dynamic> json) =>
      _$DataFilterEntityResFromJson(json);

  static const toJsonFactory = _$DataFilterEntityResToJson;
  Map<String, dynamic> toJson() => _$DataFilterEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final DataFilter? entity;
  static const fromJsonFactory = _$DataFilterEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $DataFilterEntityResExtension on DataFilterEntityRes {
  DataFilterEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      DataFilter? entity}) {
    return DataFilterEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  DataFilterEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<DataFilter?>? entity}) {
    return DataFilterEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterArray {
  const DataFilterArray({
    this.values,
  });

  factory DataFilterArray.fromJson(Map<String, dynamic> json) =>
      _$DataFilterArrayFromJson(json);

  static const toJsonFactory = _$DataFilterArrayToJson;
  Map<String, dynamic> toJson() => _$DataFilterArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DataFilter>[])
  final List<DataFilter>? values;
  static const fromJsonFactory = _$DataFilterArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $DataFilterArrayExtension on DataFilterArray {
  DataFilterArray copyWith({List<DataFilter>? values}) {
    return DataFilterArray(values: values ?? this.values);
  }

  DataFilterArray copyWithWrapped({Wrapped<List<DataFilter>?>? values}) {
    return DataFilterArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class DataFilterArrayRes {
  const DataFilterArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory DataFilterArrayRes.fromJson(Map<String, dynamic> json) =>
      _$DataFilterArrayResFromJson(json);

  static const toJsonFactory = _$DataFilterArrayResToJson;
  Map<String, dynamic> toJson() => _$DataFilterArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <DataFilter>[])
  final List<DataFilter>? values;
  static const fromJsonFactory = _$DataFilterArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataFilterArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $DataFilterArrayResExtension on DataFilterArrayRes {
  DataFilterArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<DataFilter>? values}) {
    return DataFilterArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  DataFilterArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<DataFilter>?>? values}) {
    return DataFilterArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceInfo {
  const GeoFenceInfo({
    required this.name,
    required this.label,
    this.description,
    this.tags,
    required this.fenceType,
    this.point,
    this.line,
    this.envelope,
    this.polygon,
    this.multipoint,
    this.multiline,
    this.multipolygon,
    this.circle,
  });

  factory GeoFenceInfo.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceInfoFromJson(json);

  static const toJsonFactory = _$GeoFenceInfoToJson;
  Map<String, dynamic> toJson() => _$GeoFenceInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'fenceType',
    includeIfNull: false,
    toJson: geoFenceInfoFenceTypeToJson,
    fromJson: geoFenceInfoFenceTypeFromJson,
  )
  final enums.GeoFenceInfoFenceType fenceType;
  @JsonKey(name: 'point', includeIfNull: false)
  final GeoLocation? point;
  @JsonKey(name: 'line', includeIfNull: false)
  final GeoLine? line;
  @JsonKey(name: 'envelope', includeIfNull: false)
  final GeoEnvelope? envelope;
  @JsonKey(name: 'polygon', includeIfNull: false)
  final GeoPolygon? polygon;
  @JsonKey(name: 'multipoint', includeIfNull: false)
  final GeoMultiPoint? multipoint;
  @JsonKey(name: 'multiline', includeIfNull: false)
  final GeoMultiLine? multiline;
  @JsonKey(name: 'multipolygon', includeIfNull: false)
  final GeoMultiPolygon? multipolygon;
  @JsonKey(name: 'circle', includeIfNull: false)
  final GeoCircle? circle;
  static const fromJsonFactory = _$GeoFenceInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.fenceType, fenceType) ||
                const DeepCollectionEquality()
                    .equals(other.fenceType, fenceType)) &&
            (identical(other.point, point) ||
                const DeepCollectionEquality().equals(other.point, point)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)) &&
            (identical(other.envelope, envelope) ||
                const DeepCollectionEquality()
                    .equals(other.envelope, envelope)) &&
            (identical(other.polygon, polygon) ||
                const DeepCollectionEquality()
                    .equals(other.polygon, polygon)) &&
            (identical(other.multipoint, multipoint) ||
                const DeepCollectionEquality()
                    .equals(other.multipoint, multipoint)) &&
            (identical(other.multiline, multiline) ||
                const DeepCollectionEquality()
                    .equals(other.multiline, multiline)) &&
            (identical(other.multipolygon, multipolygon) ||
                const DeepCollectionEquality()
                    .equals(other.multipolygon, multipolygon)) &&
            (identical(other.circle, circle) ||
                const DeepCollectionEquality().equals(other.circle, circle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(fenceType) ^
      const DeepCollectionEquality().hash(point) ^
      const DeepCollectionEquality().hash(line) ^
      const DeepCollectionEquality().hash(envelope) ^
      const DeepCollectionEquality().hash(polygon) ^
      const DeepCollectionEquality().hash(multipoint) ^
      const DeepCollectionEquality().hash(multiline) ^
      const DeepCollectionEquality().hash(multipolygon) ^
      const DeepCollectionEquality().hash(circle) ^
      runtimeType.hashCode;
}

extension $GeoFenceInfoExtension on GeoFenceInfo {
  GeoFenceInfo copyWith(
      {String? name,
      String? label,
      String? description,
      List<String>? tags,
      enums.GeoFenceInfoFenceType? fenceType,
      GeoLocation? point,
      GeoLine? line,
      GeoEnvelope? envelope,
      GeoPolygon? polygon,
      GeoMultiPoint? multipoint,
      GeoMultiLine? multiline,
      GeoMultiPolygon? multipolygon,
      GeoCircle? circle}) {
    return GeoFenceInfo(
        name: name ?? this.name,
        label: label ?? this.label,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        fenceType: fenceType ?? this.fenceType,
        point: point ?? this.point,
        line: line ?? this.line,
        envelope: envelope ?? this.envelope,
        polygon: polygon ?? this.polygon,
        multipoint: multipoint ?? this.multipoint,
        multiline: multiline ?? this.multiline,
        multipolygon: multipolygon ?? this.multipolygon,
        circle: circle ?? this.circle);
  }

  GeoFenceInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? label,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<enums.GeoFenceInfoFenceType>? fenceType,
      Wrapped<GeoLocation?>? point,
      Wrapped<GeoLine?>? line,
      Wrapped<GeoEnvelope?>? envelope,
      Wrapped<GeoPolygon?>? polygon,
      Wrapped<GeoMultiPoint?>? multipoint,
      Wrapped<GeoMultiLine?>? multiline,
      Wrapped<GeoMultiPolygon?>? multipolygon,
      Wrapped<GeoCircle?>? circle}) {
    return GeoFenceInfo(
        name: (name != null ? name.value : this.name),
        label: (label != null ? label.value : this.label),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        fenceType: (fenceType != null ? fenceType.value : this.fenceType),
        point: (point != null ? point.value : this.point),
        line: (line != null ? line.value : this.line),
        envelope: (envelope != null ? envelope.value : this.envelope),
        polygon: (polygon != null ? polygon.value : this.polygon),
        multipoint: (multipoint != null ? multipoint.value : this.multipoint),
        multiline: (multiline != null ? multiline.value : this.multiline),
        multipolygon:
            (multipolygon != null ? multipolygon.value : this.multipolygon),
        circle: (circle != null ? circle.value : this.circle));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceBase {
  const GeoFenceBase({
    required this.fence,
  });

  factory GeoFenceBase.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceBaseFromJson(json);

  static const toJsonFactory = _$GeoFenceBaseToJson;
  Map<String, dynamic> toJson() => _$GeoFenceBaseToJson(this);

  @JsonKey(name: 'fence', includeIfNull: false)
  final Object fence;
  static const fromJsonFactory = _$GeoFenceBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceBase &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fence) ^ runtimeType.hashCode;
}

extension $GeoFenceBaseExtension on GeoFenceBase {
  GeoFenceBase copyWith({Object? fence}) {
    return GeoFenceBase(fence: fence ?? this.fence);
  }

  GeoFenceBase copyWithWrapped({Wrapped<Object>? fence}) {
    return GeoFenceBase(fence: (fence != null ? fence.value : this.fence));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFence {
  const GeoFence({
    required this.name,
    required this.label,
    this.description,
    this.tags,
    required this.fenceType,
    this.point,
    this.line,
    this.envelope,
    this.polygon,
    this.multipoint,
    this.multiline,
    this.multipolygon,
    this.circle,
    required this.fence,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory GeoFence.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceFromJson(json);

  static const toJsonFactory = _$GeoFenceToJson;
  Map<String, dynamic> toJson() => _$GeoFenceToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'fenceType',
    includeIfNull: false,
    toJson: geoFenceFenceTypeToJson,
    fromJson: geoFenceFenceTypeFromJson,
  )
  final enums.GeoFenceFenceType fenceType;
  @JsonKey(name: 'point', includeIfNull: false)
  final GeoLocation? point;
  @JsonKey(name: 'line', includeIfNull: false)
  final GeoLine? line;
  @JsonKey(name: 'envelope', includeIfNull: false)
  final GeoEnvelope? envelope;
  @JsonKey(name: 'polygon', includeIfNull: false)
  final GeoPolygon? polygon;
  @JsonKey(name: 'multipoint', includeIfNull: false)
  final GeoMultiPoint? multipoint;
  @JsonKey(name: 'multiline', includeIfNull: false)
  final GeoMultiLine? multiline;
  @JsonKey(name: 'multipolygon', includeIfNull: false)
  final GeoMultiPolygon? multipolygon;
  @JsonKey(name: 'circle', includeIfNull: false)
  final GeoCircle? circle;
  @JsonKey(name: 'fence', includeIfNull: false)
  final Object fence;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$GeoFenceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFence &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.fenceType, fenceType) ||
                const DeepCollectionEquality()
                    .equals(other.fenceType, fenceType)) &&
            (identical(other.point, point) ||
                const DeepCollectionEquality().equals(other.point, point)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)) &&
            (identical(other.envelope, envelope) ||
                const DeepCollectionEquality()
                    .equals(other.envelope, envelope)) &&
            (identical(other.polygon, polygon) ||
                const DeepCollectionEquality()
                    .equals(other.polygon, polygon)) &&
            (identical(other.multipoint, multipoint) ||
                const DeepCollectionEquality()
                    .equals(other.multipoint, multipoint)) &&
            (identical(other.multiline, multiline) ||
                const DeepCollectionEquality()
                    .equals(other.multiline, multiline)) &&
            (identical(other.multipolygon, multipolygon) ||
                const DeepCollectionEquality()
                    .equals(other.multipolygon, multipolygon)) &&
            (identical(other.circle, circle) ||
                const DeepCollectionEquality().equals(other.circle, circle)) &&
            (identical(other.fence, fence) ||
                const DeepCollectionEquality().equals(other.fence, fence)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(fenceType) ^
      const DeepCollectionEquality().hash(point) ^
      const DeepCollectionEquality().hash(line) ^
      const DeepCollectionEquality().hash(envelope) ^
      const DeepCollectionEquality().hash(polygon) ^
      const DeepCollectionEquality().hash(multipoint) ^
      const DeepCollectionEquality().hash(multiline) ^
      const DeepCollectionEquality().hash(multipolygon) ^
      const DeepCollectionEquality().hash(circle) ^
      const DeepCollectionEquality().hash(fence) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $GeoFenceExtension on GeoFence {
  GeoFence copyWith(
      {String? name,
      String? label,
      String? description,
      List<String>? tags,
      enums.GeoFenceFenceType? fenceType,
      GeoLocation? point,
      GeoLine? line,
      GeoEnvelope? envelope,
      GeoPolygon? polygon,
      GeoMultiPoint? multipoint,
      GeoMultiLine? multiline,
      GeoMultiPolygon? multipolygon,
      GeoCircle? circle,
      Object? fence,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return GeoFence(
        name: name ?? this.name,
        label: label ?? this.label,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        fenceType: fenceType ?? this.fenceType,
        point: point ?? this.point,
        line: line ?? this.line,
        envelope: envelope ?? this.envelope,
        polygon: polygon ?? this.polygon,
        multipoint: multipoint ?? this.multipoint,
        multiline: multiline ?? this.multiline,
        multipolygon: multipolygon ?? this.multipolygon,
        circle: circle ?? this.circle,
        fence: fence ?? this.fence,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  GeoFence copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? label,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<enums.GeoFenceFenceType>? fenceType,
      Wrapped<GeoLocation?>? point,
      Wrapped<GeoLine?>? line,
      Wrapped<GeoEnvelope?>? envelope,
      Wrapped<GeoPolygon?>? polygon,
      Wrapped<GeoMultiPoint?>? multipoint,
      Wrapped<GeoMultiLine?>? multiline,
      Wrapped<GeoMultiPolygon?>? multipolygon,
      Wrapped<GeoCircle?>? circle,
      Wrapped<Object>? fence,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return GeoFence(
        name: (name != null ? name.value : this.name),
        label: (label != null ? label.value : this.label),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        fenceType: (fenceType != null ? fenceType.value : this.fenceType),
        point: (point != null ? point.value : this.point),
        line: (line != null ? line.value : this.line),
        envelope: (envelope != null ? envelope.value : this.envelope),
        polygon: (polygon != null ? polygon.value : this.polygon),
        multipoint: (multipoint != null ? multipoint.value : this.multipoint),
        multiline: (multiline != null ? multiline.value : this.multiline),
        multipolygon:
            (multipolygon != null ? multipolygon.value : this.multipolygon),
        circle: (circle != null ? circle.value : this.circle),
        fence: (fence != null ? fence.value : this.fence),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceEntity {
  const GeoFenceEntity({
    this.entity,
  });

  factory GeoFenceEntity.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceEntityFromJson(json);

  static const toJsonFactory = _$GeoFenceEntityToJson;
  Map<String, dynamic> toJson() => _$GeoFenceEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final GeoFence? entity;
  static const fromJsonFactory = _$GeoFenceEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $GeoFenceEntityExtension on GeoFenceEntity {
  GeoFenceEntity copyWith({GeoFence? entity}) {
    return GeoFenceEntity(entity: entity ?? this.entity);
  }

  GeoFenceEntity copyWithWrapped({Wrapped<GeoFence?>? entity}) {
    return GeoFenceEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceEntityRes {
  const GeoFenceEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory GeoFenceEntityRes.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceEntityResFromJson(json);

  static const toJsonFactory = _$GeoFenceEntityResToJson;
  Map<String, dynamic> toJson() => _$GeoFenceEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final GeoFence? entity;
  static const fromJsonFactory = _$GeoFenceEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $GeoFenceEntityResExtension on GeoFenceEntityRes {
  GeoFenceEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      GeoFence? entity}) {
    return GeoFenceEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  GeoFenceEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<GeoFence?>? entity}) {
    return GeoFenceEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceArray {
  const GeoFenceArray({
    this.values,
  });

  factory GeoFenceArray.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceArrayFromJson(json);

  static const toJsonFactory = _$GeoFenceArrayToJson;
  Map<String, dynamic> toJson() => _$GeoFenceArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <GeoFence>[])
  final List<GeoFence>? values;
  static const fromJsonFactory = _$GeoFenceArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $GeoFenceArrayExtension on GeoFenceArray {
  GeoFenceArray copyWith({List<GeoFence>? values}) {
    return GeoFenceArray(values: values ?? this.values);
  }

  GeoFenceArray copyWithWrapped({Wrapped<List<GeoFence>?>? values}) {
    return GeoFenceArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoFenceArrayRes {
  const GeoFenceArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory GeoFenceArrayRes.fromJson(Map<String, dynamic> json) =>
      _$GeoFenceArrayResFromJson(json);

  static const toJsonFactory = _$GeoFenceArrayResToJson;
  Map<String, dynamic> toJson() => _$GeoFenceArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <GeoFence>[])
  final List<GeoFence>? values;
  static const fromJsonFactory = _$GeoFenceArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoFenceArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $GeoFenceArrayResExtension on GeoFenceArrayRes {
  GeoFenceArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<GeoFence>? values}) {
    return GeoFenceArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  GeoFenceArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<GeoFence>?>? values}) {
    return GeoFenceArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsRow {
  const AnalyticsRow({
    required this.height,
    required this.flex,
    required this.widgetIds,
    this.label,
    this.description,
  });

  factory AnalyticsRow.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsRowFromJson(json);

  static const toJsonFactory = _$AnalyticsRowToJson;
  Map<String, dynamic> toJson() => _$AnalyticsRowToJson(this);

  @JsonKey(name: 'height', includeIfNull: false)
  final int height;
  @JsonKey(name: 'flex', includeIfNull: false)
  final int flex;
  @JsonKey(name: 'widgetIds', includeIfNull: false, defaultValue: <String>[])
  final List<String> widgetIds;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  static const fromJsonFactory = _$AnalyticsRowFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsRow &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.flex, flex) ||
                const DeepCollectionEquality().equals(other.flex, flex)) &&
            (identical(other.widgetIds, widgetIds) ||
                const DeepCollectionEquality()
                    .equals(other.widgetIds, widgetIds)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(flex) ^
      const DeepCollectionEquality().hash(widgetIds) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $AnalyticsRowExtension on AnalyticsRow {
  AnalyticsRow copyWith(
      {int? height,
      int? flex,
      List<String>? widgetIds,
      String? label,
      String? description}) {
    return AnalyticsRow(
        height: height ?? this.height,
        flex: flex ?? this.flex,
        widgetIds: widgetIds ?? this.widgetIds,
        label: label ?? this.label,
        description: description ?? this.description);
  }

  AnalyticsRow copyWithWrapped(
      {Wrapped<int>? height,
      Wrapped<int>? flex,
      Wrapped<List<String>>? widgetIds,
      Wrapped<String?>? label,
      Wrapped<String?>? description}) {
    return AnalyticsRow(
        height: (height != null ? height.value : this.height),
        flex: (flex != null ? flex.value : this.flex),
        widgetIds: (widgetIds != null ? widgetIds.value : this.widgetIds),
        label: (label != null ? label.value : this.label),
        description:
            (description != null ? description.value : this.description));
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenInfo {
  const AnalyticsScreenInfo({
    required this.name,
    this.label,
    this.description,
    this.icon,
    this.tags,
    this.showDefault,
    required this.rows,
  });

  factory AnalyticsScreenInfo.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenInfoFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenInfoToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'showDefault', includeIfNull: false, defaultValue: false)
  final bool? showDefault;
  @JsonKey(name: 'rows', includeIfNull: false, defaultValue: <AnalyticsRow>[])
  final List<AnalyticsRow> rows;
  static const fromJsonFactory = _$AnalyticsScreenInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.showDefault, showDefault) ||
                const DeepCollectionEquality()
                    .equals(other.showDefault, showDefault)) &&
            (identical(other.rows, rows) ||
                const DeepCollectionEquality().equals(other.rows, rows)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(showDefault) ^
      const DeepCollectionEquality().hash(rows) ^
      runtimeType.hashCode;
}

extension $AnalyticsScreenInfoExtension on AnalyticsScreenInfo {
  AnalyticsScreenInfo copyWith(
      {String? name,
      String? label,
      String? description,
      String? icon,
      List<String>? tags,
      bool? showDefault,
      List<AnalyticsRow>? rows}) {
    return AnalyticsScreenInfo(
        name: name ?? this.name,
        label: label ?? this.label,
        description: description ?? this.description,
        icon: icon ?? this.icon,
        tags: tags ?? this.tags,
        showDefault: showDefault ?? this.showDefault,
        rows: rows ?? this.rows);
  }

  AnalyticsScreenInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? label,
      Wrapped<String?>? description,
      Wrapped<String?>? icon,
      Wrapped<List<String>?>? tags,
      Wrapped<bool?>? showDefault,
      Wrapped<List<AnalyticsRow>>? rows}) {
    return AnalyticsScreenInfo(
        name: (name != null ? name.value : this.name),
        label: (label != null ? label.value : this.label),
        description:
            (description != null ? description.value : this.description),
        icon: (icon != null ? icon.value : this.icon),
        tags: (tags != null ? tags.value : this.tags),
        showDefault:
            (showDefault != null ? showDefault.value : this.showDefault),
        rows: (rows != null ? rows.value : this.rows));
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreen {
  const AnalyticsScreen({
    required this.name,
    this.label,
    this.description,
    this.icon,
    this.tags,
    this.showDefault,
    required this.rows,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory AnalyticsScreen.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'showDefault', includeIfNull: false, defaultValue: false)
  final bool? showDefault;
  @JsonKey(name: 'rows', includeIfNull: false, defaultValue: <AnalyticsRow>[])
  final List<AnalyticsRow> rows;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$AnalyticsScreenFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreen &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.showDefault, showDefault) ||
                const DeepCollectionEquality()
                    .equals(other.showDefault, showDefault)) &&
            (identical(other.rows, rows) ||
                const DeepCollectionEquality().equals(other.rows, rows)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(showDefault) ^
      const DeepCollectionEquality().hash(rows) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $AnalyticsScreenExtension on AnalyticsScreen {
  AnalyticsScreen copyWith(
      {String? name,
      String? label,
      String? description,
      String? icon,
      List<String>? tags,
      bool? showDefault,
      List<AnalyticsRow>? rows,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return AnalyticsScreen(
        name: name ?? this.name,
        label: label ?? this.label,
        description: description ?? this.description,
        icon: icon ?? this.icon,
        tags: tags ?? this.tags,
        showDefault: showDefault ?? this.showDefault,
        rows: rows ?? this.rows,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  AnalyticsScreen copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? label,
      Wrapped<String?>? description,
      Wrapped<String?>? icon,
      Wrapped<List<String>?>? tags,
      Wrapped<bool?>? showDefault,
      Wrapped<List<AnalyticsRow>>? rows,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return AnalyticsScreen(
        name: (name != null ? name.value : this.name),
        label: (label != null ? label.value : this.label),
        description:
            (description != null ? description.value : this.description),
        icon: (icon != null ? icon.value : this.icon),
        tags: (tags != null ? tags.value : this.tags),
        showDefault:
            (showDefault != null ? showDefault.value : this.showDefault),
        rows: (rows != null ? rows.value : this.rows),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenEntity {
  const AnalyticsScreenEntity({
    this.entity,
  });

  factory AnalyticsScreenEntity.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenEntityFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenEntityToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final AnalyticsScreen? entity;
  static const fromJsonFactory = _$AnalyticsScreenEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AnalyticsScreenEntityExtension on AnalyticsScreenEntity {
  AnalyticsScreenEntity copyWith({AnalyticsScreen? entity}) {
    return AnalyticsScreenEntity(entity: entity ?? this.entity);
  }

  AnalyticsScreenEntity copyWithWrapped({Wrapped<AnalyticsScreen?>? entity}) {
    return AnalyticsScreenEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenEntityRes {
  const AnalyticsScreenEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AnalyticsScreenEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenEntityResFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenEntityResToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final AnalyticsScreen? entity;
  static const fromJsonFactory = _$AnalyticsScreenEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AnalyticsScreenEntityResExtension on AnalyticsScreenEntityRes {
  AnalyticsScreenEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      AnalyticsScreen? entity}) {
    return AnalyticsScreenEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  AnalyticsScreenEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<AnalyticsScreen?>? entity}) {
    return AnalyticsScreenEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenArray {
  const AnalyticsScreenArray({
    this.values,
  });

  factory AnalyticsScreenArray.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenArrayFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenArrayToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenArrayToJson(this);

  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <AnalyticsScreen>[])
  final List<AnalyticsScreen>? values;
  static const fromJsonFactory = _$AnalyticsScreenArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AnalyticsScreenArrayExtension on AnalyticsScreenArray {
  AnalyticsScreenArray copyWith({List<AnalyticsScreen>? values}) {
    return AnalyticsScreenArray(values: values ?? this.values);
  }

  AnalyticsScreenArray copyWithWrapped(
      {Wrapped<List<AnalyticsScreen>?>? values}) {
    return AnalyticsScreenArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AnalyticsScreenArrayRes {
  const AnalyticsScreenArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AnalyticsScreenArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AnalyticsScreenArrayResFromJson(json);

  static const toJsonFactory = _$AnalyticsScreenArrayResToJson;
  Map<String, dynamic> toJson() => _$AnalyticsScreenArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <AnalyticsScreen>[])
  final List<AnalyticsScreen>? values;
  static const fromJsonFactory = _$AnalyticsScreenArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AnalyticsScreenArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AnalyticsScreenArrayResExtension on AnalyticsScreenArrayRes {
  AnalyticsScreenArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<AnalyticsScreen>? values}) {
    return AnalyticsScreenArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  AnalyticsScreenArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<AnalyticsScreen>?>? values}) {
    return AnalyticsScreenArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TrendValue {
  const TrendValue({
    required this.stamp,
    this.count,
    this.min,
    this.max,
    this.avg,
  });

  factory TrendValue.fromJson(Map<String, dynamic> json) =>
      _$TrendValueFromJson(json);

  static const toJsonFactory = _$TrendValueToJson;
  Map<String, dynamic> toJson() => _$TrendValueToJson(this);

  @JsonKey(name: 'stamp', includeIfNull: false)
  final int stamp;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  @JsonKey(name: 'min', includeIfNull: false)
  final double? min;
  @JsonKey(name: 'max', includeIfNull: false)
  final double? max;
  @JsonKey(name: 'avg', includeIfNull: false)
  final double? avg;
  static const fromJsonFactory = _$TrendValueFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrendValue &&
            (identical(other.stamp, stamp) ||
                const DeepCollectionEquality().equals(other.stamp, stamp)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.min, min) ||
                const DeepCollectionEquality().equals(other.min, min)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)) &&
            (identical(other.avg, avg) ||
                const DeepCollectionEquality().equals(other.avg, avg)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stamp) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(min) ^
      const DeepCollectionEquality().hash(max) ^
      const DeepCollectionEquality().hash(avg) ^
      runtimeType.hashCode;
}

extension $TrendValueExtension on TrendValue {
  TrendValue copyWith(
      {int? stamp, int? count, double? min, double? max, double? avg}) {
    return TrendValue(
        stamp: stamp ?? this.stamp,
        count: count ?? this.count,
        min: min ?? this.min,
        max: max ?? this.max,
        avg: avg ?? this.avg);
  }

  TrendValue copyWithWrapped(
      {Wrapped<int>? stamp,
      Wrapped<int?>? count,
      Wrapped<double?>? min,
      Wrapped<double?>? max,
      Wrapped<double?>? avg}) {
    return TrendValue(
        stamp: (stamp != null ? stamp.value : this.stamp),
        count: (count != null ? count.value : this.count),
        min: (min != null ? min.value : this.min),
        max: (max != null ? max.value : this.max),
        avg: (avg != null ? avg.value : this.avg));
  }
}

@JsonSerializable(explicitToJson: true)
class TrendValueArray {
  const TrendValueArray({
    this.values,
  });

  factory TrendValueArray.fromJson(Map<String, dynamic> json) =>
      _$TrendValueArrayFromJson(json);

  static const toJsonFactory = _$TrendValueArrayToJson;
  Map<String, dynamic> toJson() => _$TrendValueArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TrendValue>[])
  final List<TrendValue>? values;
  static const fromJsonFactory = _$TrendValueArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrendValueArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TrendValueArrayExtension on TrendValueArray {
  TrendValueArray copyWith({List<TrendValue>? values}) {
    return TrendValueArray(values: values ?? this.values);
  }

  TrendValueArray copyWithWrapped({Wrapped<List<TrendValue>?>? values}) {
    return TrendValueArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TrendValueArrayRes {
  const TrendValueArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TrendValueArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TrendValueArrayResFromJson(json);

  static const toJsonFactory = _$TrendValueArrayResToJson;
  Map<String, dynamic> toJson() => _$TrendValueArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TrendValue>[])
  final List<TrendValue>? values;
  static const fromJsonFactory = _$TrendValueArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrendValueArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TrendValueArrayResExtension on TrendValueArrayRes {
  TrendValueArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<TrendValue>? values}) {
    return TrendValueArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  TrendValueArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<TrendValue>?>? values}) {
    return TrendValueArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TimeSeriesValue {
  const TimeSeriesValue({
    required this.updatedStamp,
    this.data,
    this.id,
  });

  factory TimeSeriesValue.fromJson(Map<String, dynamic> json) =>
      _$TimeSeriesValueFromJson(json);

  static const toJsonFactory = _$TimeSeriesValueToJson;
  Map<String, dynamic> toJson() => _$TimeSeriesValueToJson(this);

  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'data', includeIfNull: false)
  final Object? data;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  static const fromJsonFactory = _$TimeSeriesValueFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimeSeriesValue &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $TimeSeriesValueExtension on TimeSeriesValue {
  TimeSeriesValue copyWith({int? updatedStamp, Object? data, String? id}) {
    return TimeSeriesValue(
        updatedStamp: updatedStamp ?? this.updatedStamp,
        data: data ?? this.data,
        id: id ?? this.id);
  }

  TimeSeriesValue copyWithWrapped(
      {Wrapped<int>? updatedStamp,
      Wrapped<Object?>? data,
      Wrapped<String?>? id}) {
    return TimeSeriesValue(
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        data: (data != null ? data.value : this.data),
        id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class TimeSeriesValueArray {
  const TimeSeriesValueArray({
    this.values,
  });

  factory TimeSeriesValueArray.fromJson(Map<String, dynamic> json) =>
      _$TimeSeriesValueArrayFromJson(json);

  static const toJsonFactory = _$TimeSeriesValueArrayToJson;
  Map<String, dynamic> toJson() => _$TimeSeriesValueArrayToJson(this);

  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <TimeSeriesValue>[])
  final List<TimeSeriesValue>? values;
  static const fromJsonFactory = _$TimeSeriesValueArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimeSeriesValueArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TimeSeriesValueArrayExtension on TimeSeriesValueArray {
  TimeSeriesValueArray copyWith({List<TimeSeriesValue>? values}) {
    return TimeSeriesValueArray(values: values ?? this.values);
  }

  TimeSeriesValueArray copyWithWrapped(
      {Wrapped<List<TimeSeriesValue>?>? values}) {
    return TimeSeriesValueArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TimeSeriesValueArrayRes {
  const TimeSeriesValueArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TimeSeriesValueArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TimeSeriesValueArrayResFromJson(json);

  static const toJsonFactory = _$TimeSeriesValueArrayResToJson;
  Map<String, dynamic> toJson() => _$TimeSeriesValueArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <TimeSeriesValue>[])
  final List<TimeSeriesValue>? values;
  static const fromJsonFactory = _$TimeSeriesValueArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimeSeriesValueArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TimeSeriesValueArrayResExtension on TimeSeriesValueArrayRes {
  TimeSeriesValueArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<TimeSeriesValue>? values}) {
    return TimeSeriesValueArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  TimeSeriesValueArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<TimeSeriesValue>?>? values}) {
    return TimeSeriesValueArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class LandingPage {
  const LandingPage({
    this.logoImage,
    this.heading,
    this.subHeading,
    this.line1,
    this.line2,
    this.line3,
    this.line4,
    this.line5,
    this.bgColor,
    this.imageFlex,
    this.contentFlex,
    this.imageWidth,
  });

  factory LandingPage.fromJson(Map<String, dynamic> json) =>
      _$LandingPageFromJson(json);

  static const toJsonFactory = _$LandingPageToJson;
  Map<String, dynamic> toJson() => _$LandingPageToJson(this);

  @JsonKey(name: 'logoImage', includeIfNull: false, defaultValue: '')
  final String? logoImage;
  @JsonKey(name: 'heading', includeIfNull: false, defaultValue: '')
  final String? heading;
  @JsonKey(name: 'subHeading', includeIfNull: false, defaultValue: '')
  final String? subHeading;
  @JsonKey(name: 'line1', includeIfNull: false, defaultValue: '')
  final String? line1;
  @JsonKey(name: 'line2', includeIfNull: false, defaultValue: '')
  final String? line2;
  @JsonKey(name: 'line3', includeIfNull: false, defaultValue: '')
  final String? line3;
  @JsonKey(name: 'line4', includeIfNull: false, defaultValue: '')
  final String? line4;
  @JsonKey(name: 'line5', includeIfNull: false, defaultValue: '')
  final String? line5;
  @JsonKey(name: 'bgColor', includeIfNull: false)
  final int? bgColor;
  @JsonKey(name: 'imageFlex', includeIfNull: false)
  final int? imageFlex;
  @JsonKey(name: 'contentFlex', includeIfNull: false)
  final int? contentFlex;
  @JsonKey(name: 'imageWidth', includeIfNull: false)
  final int? imageWidth;
  static const fromJsonFactory = _$LandingPageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LandingPage &&
            (identical(other.logoImage, logoImage) ||
                const DeepCollectionEquality()
                    .equals(other.logoImage, logoImage)) &&
            (identical(other.heading, heading) ||
                const DeepCollectionEquality()
                    .equals(other.heading, heading)) &&
            (identical(other.subHeading, subHeading) ||
                const DeepCollectionEquality()
                    .equals(other.subHeading, subHeading)) &&
            (identical(other.line1, line1) ||
                const DeepCollectionEquality().equals(other.line1, line1)) &&
            (identical(other.line2, line2) ||
                const DeepCollectionEquality().equals(other.line2, line2)) &&
            (identical(other.line3, line3) ||
                const DeepCollectionEquality().equals(other.line3, line3)) &&
            (identical(other.line4, line4) ||
                const DeepCollectionEquality().equals(other.line4, line4)) &&
            (identical(other.line5, line5) ||
                const DeepCollectionEquality().equals(other.line5, line5)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.imageFlex, imageFlex) ||
                const DeepCollectionEquality()
                    .equals(other.imageFlex, imageFlex)) &&
            (identical(other.contentFlex, contentFlex) ||
                const DeepCollectionEquality()
                    .equals(other.contentFlex, contentFlex)) &&
            (identical(other.imageWidth, imageWidth) ||
                const DeepCollectionEquality()
                    .equals(other.imageWidth, imageWidth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(logoImage) ^
      const DeepCollectionEquality().hash(heading) ^
      const DeepCollectionEquality().hash(subHeading) ^
      const DeepCollectionEquality().hash(line1) ^
      const DeepCollectionEquality().hash(line2) ^
      const DeepCollectionEquality().hash(line3) ^
      const DeepCollectionEquality().hash(line4) ^
      const DeepCollectionEquality().hash(line5) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(imageFlex) ^
      const DeepCollectionEquality().hash(contentFlex) ^
      const DeepCollectionEquality().hash(imageWidth) ^
      runtimeType.hashCode;
}

extension $LandingPageExtension on LandingPage {
  LandingPage copyWith(
      {String? logoImage,
      String? heading,
      String? subHeading,
      String? line1,
      String? line2,
      String? line3,
      String? line4,
      String? line5,
      int? bgColor,
      int? imageFlex,
      int? contentFlex,
      int? imageWidth}) {
    return LandingPage(
        logoImage: logoImage ?? this.logoImage,
        heading: heading ?? this.heading,
        subHeading: subHeading ?? this.subHeading,
        line1: line1 ?? this.line1,
        line2: line2 ?? this.line2,
        line3: line3 ?? this.line3,
        line4: line4 ?? this.line4,
        line5: line5 ?? this.line5,
        bgColor: bgColor ?? this.bgColor,
        imageFlex: imageFlex ?? this.imageFlex,
        contentFlex: contentFlex ?? this.contentFlex,
        imageWidth: imageWidth ?? this.imageWidth);
  }

  LandingPage copyWithWrapped(
      {Wrapped<String?>? logoImage,
      Wrapped<String?>? heading,
      Wrapped<String?>? subHeading,
      Wrapped<String?>? line1,
      Wrapped<String?>? line2,
      Wrapped<String?>? line3,
      Wrapped<String?>? line4,
      Wrapped<String?>? line5,
      Wrapped<int?>? bgColor,
      Wrapped<int?>? imageFlex,
      Wrapped<int?>? contentFlex,
      Wrapped<int?>? imageWidth}) {
    return LandingPage(
        logoImage: (logoImage != null ? logoImage.value : this.logoImage),
        heading: (heading != null ? heading.value : this.heading),
        subHeading: (subHeading != null ? subHeading.value : this.subHeading),
        line1: (line1 != null ? line1.value : this.line1),
        line2: (line2 != null ? line2.value : this.line2),
        line3: (line3 != null ? line3.value : this.line3),
        line4: (line4 != null ? line4.value : this.line4),
        line5: (line5 != null ? line5.value : this.line5),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        imageFlex: (imageFlex != null ? imageFlex.value : this.imageFlex),
        contentFlex:
            (contentFlex != null ? contentFlex.value : this.contentFlex),
        imageWidth: (imageWidth != null ? imageWidth.value : this.imageWidth));
  }
}

@JsonSerializable(explicitToJson: true)
class ElasticEmailConfig {
  const ElasticEmailConfig({
    required this.apiKey,
  });

  factory ElasticEmailConfig.fromJson(Map<String, dynamic> json) =>
      _$ElasticEmailConfigFromJson(json);

  static const toJsonFactory = _$ElasticEmailConfigToJson;
  Map<String, dynamic> toJson() => _$ElasticEmailConfigToJson(this);

  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  static const fromJsonFactory = _$ElasticEmailConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ElasticEmailConfig &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^ runtimeType.hashCode;
}

extension $ElasticEmailConfigExtension on ElasticEmailConfig {
  ElasticEmailConfig copyWith({String? apiKey}) {
    return ElasticEmailConfig(apiKey: apiKey ?? this.apiKey);
  }

  ElasticEmailConfig copyWithWrapped({Wrapped<String>? apiKey}) {
    return ElasticEmailConfig(
        apiKey: (apiKey != null ? apiKey.value : this.apiKey));
  }
}

@JsonSerializable(explicitToJson: true)
class TwilioConfig {
  const TwilioConfig({
    required this.apiKey,
  });

  factory TwilioConfig.fromJson(Map<String, dynamic> json) =>
      _$TwilioConfigFromJson(json);

  static const toJsonFactory = _$TwilioConfigToJson;
  Map<String, dynamic> toJson() => _$TwilioConfigToJson(this);

  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  static const fromJsonFactory = _$TwilioConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwilioConfig &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^ runtimeType.hashCode;
}

extension $TwilioConfigExtension on TwilioConfig {
  TwilioConfig copyWith({String? apiKey}) {
    return TwilioConfig(apiKey: apiKey ?? this.apiKey);
  }

  TwilioConfig copyWithWrapped({Wrapped<String>? apiKey}) {
    return TwilioConfig(apiKey: (apiKey != null ? apiKey.value : this.apiKey));
  }
}

@JsonSerializable(explicitToJson: true)
class TextLocalConfig {
  const TextLocalConfig({
    required this.apiKey,
  });

  factory TextLocalConfig.fromJson(Map<String, dynamic> json) =>
      _$TextLocalConfigFromJson(json);

  static const toJsonFactory = _$TextLocalConfigToJson;
  Map<String, dynamic> toJson() => _$TextLocalConfigToJson(this);

  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  static const fromJsonFactory = _$TextLocalConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TextLocalConfig &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^ runtimeType.hashCode;
}

extension $TextLocalConfigExtension on TextLocalConfig {
  TextLocalConfig copyWith({String? apiKey}) {
    return TextLocalConfig(apiKey: apiKey ?? this.apiKey);
  }

  TextLocalConfig copyWithWrapped({Wrapped<String>? apiKey}) {
    return TextLocalConfig(
        apiKey: (apiKey != null ? apiKey.value : this.apiKey));
  }
}

@JsonSerializable(explicitToJson: true)
class GeoapifyConfig {
  const GeoapifyConfig({
    required this.apiKey,
  });

  factory GeoapifyConfig.fromJson(Map<String, dynamic> json) =>
      _$GeoapifyConfigFromJson(json);

  static const toJsonFactory = _$GeoapifyConfigToJson;
  Map<String, dynamic> toJson() => _$GeoapifyConfigToJson(this);

  @JsonKey(name: 'apiKey', includeIfNull: false, defaultValue: '')
  final String apiKey;
  static const fromJsonFactory = _$GeoapifyConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeoapifyConfig &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^ runtimeType.hashCode;
}

extension $GeoapifyConfigExtension on GeoapifyConfig {
  GeoapifyConfig copyWith({String? apiKey}) {
    return GeoapifyConfig(apiKey: apiKey ?? this.apiKey);
  }

  GeoapifyConfig copyWithWrapped({Wrapped<String>? apiKey}) {
    return GeoapifyConfig(
        apiKey: (apiKey != null ? apiKey.value : this.apiKey));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysInfo {
  const TwinSysInfo({
    this.logoImage,
    this.bannerImage,
    this.font,
    this.fontSize,
    this.fontColor,
    this.headerFont,
    this.headerFontSize,
    this.headerFontColor,
    this.subHeaderFont,
    this.subHeaderFontSize,
    this.subHeaderFontColor,
    this.menuFont,
    this.menuFontSize,
    this.menuFontColor,
    this.toolFont,
    this.toolFontSize,
    this.toolFontColor,
    this.toolIconColor,
    this.labelFont,
    this.labelFontSize,
    this.labelFontColor,
    this.labelIconColor,
    this.enableSelfRegistration,
    this.selfRegistrationDomain,
    this.autoApproveSelfRegistration,
    this.landingPages,
    this.emailProvider,
    this.smsProvider,
    this.voiceProvider,
    this.elasticEmailConfig,
    this.twilioConfig,
    this.textLocalConfig,
    this.geoapifyConfig,
    this.enforceRoles,
    this.headerBgColor,
    this.pageBgColor,
    this.appName,
    this.logoText,
    this.enforceClient,
    this.useMenuAsLanding,
  });

  factory TwinSysInfo.fromJson(Map<String, dynamic> json) =>
      _$TwinSysInfoFromJson(json);

  static const toJsonFactory = _$TwinSysInfoToJson;
  Map<String, dynamic> toJson() => _$TwinSysInfoToJson(this);

  @JsonKey(name: 'logoImage', includeIfNull: false, defaultValue: '')
  final String? logoImage;
  @JsonKey(name: 'bannerImage', includeIfNull: false, defaultValue: '')
  final String? bannerImage;
  @JsonKey(name: 'font', includeIfNull: false, defaultValue: '')
  final String? font;
  @JsonKey(name: 'fontSize', includeIfNull: false)
  final double? fontSize;
  @JsonKey(name: 'fontColor', includeIfNull: false)
  final int? fontColor;
  @JsonKey(name: 'headerFont', includeIfNull: false, defaultValue: '')
  final String? headerFont;
  @JsonKey(name: 'headerFontSize', includeIfNull: false)
  final double? headerFontSize;
  @JsonKey(name: 'headerFontColor', includeIfNull: false)
  final int? headerFontColor;
  @JsonKey(name: 'subHeaderFont', includeIfNull: false, defaultValue: '')
  final String? subHeaderFont;
  @JsonKey(name: 'subHeaderFontSize', includeIfNull: false)
  final double? subHeaderFontSize;
  @JsonKey(name: 'subHeaderFontColor', includeIfNull: false)
  final int? subHeaderFontColor;
  @JsonKey(name: 'menuFont', includeIfNull: false, defaultValue: '')
  final String? menuFont;
  @JsonKey(name: 'menuFontSize', includeIfNull: false)
  final double? menuFontSize;
  @JsonKey(name: 'menuFontColor', includeIfNull: false)
  final int? menuFontColor;
  @JsonKey(name: 'toolFont', includeIfNull: false, defaultValue: '')
  final String? toolFont;
  @JsonKey(name: 'toolFontSize', includeIfNull: false)
  final double? toolFontSize;
  @JsonKey(name: 'toolFontColor', includeIfNull: false)
  final int? toolFontColor;
  @JsonKey(name: 'toolIconColor', includeIfNull: false)
  final int? toolIconColor;
  @JsonKey(name: 'labelFont', includeIfNull: false, defaultValue: '')
  final String? labelFont;
  @JsonKey(name: 'labelFontSize', includeIfNull: false)
  final double? labelFontSize;
  @JsonKey(name: 'labelFontColor', includeIfNull: false)
  final int? labelFontColor;
  @JsonKey(name: 'labelIconColor', includeIfNull: false)
  final int? labelIconColor;
  @JsonKey(
      name: 'enableSelfRegistration', includeIfNull: false, defaultValue: true)
  final bool? enableSelfRegistration;
  @JsonKey(
      name: 'selfRegistrationDomain', includeIfNull: false, defaultValue: '')
  final String? selfRegistrationDomain;
  @JsonKey(
      name: 'autoApproveSelfRegistration',
      includeIfNull: false,
      defaultValue: true)
  final bool? autoApproveSelfRegistration;
  @JsonKey(
      name: 'landingPages', includeIfNull: false, defaultValue: <LandingPage>[])
  final List<LandingPage>? landingPages;
  @JsonKey(
    name: 'emailProvider',
    includeIfNull: false,
    toJson: twinSysInfoEmailProviderNullableToJson,
    fromJson: twinSysInfoEmailProviderNullableFromJson,
  )
  final enums.TwinSysInfoEmailProvider? emailProvider;
  @JsonKey(
    name: 'smsProvider',
    includeIfNull: false,
    toJson: twinSysInfoSmsProviderNullableToJson,
    fromJson: twinSysInfoSmsProviderNullableFromJson,
  )
  final enums.TwinSysInfoSmsProvider? smsProvider;
  @JsonKey(
    name: 'voiceProvider',
    includeIfNull: false,
    toJson: twinSysInfoVoiceProviderNullableToJson,
    fromJson: twinSysInfoVoiceProviderNullableFromJson,
  )
  final enums.TwinSysInfoVoiceProvider? voiceProvider;
  @JsonKey(name: 'elasticEmailConfig', includeIfNull: false)
  final ElasticEmailConfig? elasticEmailConfig;
  @JsonKey(name: 'twilioConfig', includeIfNull: false)
  final TwilioConfig? twilioConfig;
  @JsonKey(name: 'textLocalConfig', includeIfNull: false)
  final TextLocalConfig? textLocalConfig;
  @JsonKey(name: 'geoapifyConfig', includeIfNull: false)
  final GeoapifyConfig? geoapifyConfig;
  @JsonKey(name: 'enforceRoles', includeIfNull: false, defaultValue: false)
  final bool? enforceRoles;
  @JsonKey(name: 'headerBgColor', includeIfNull: false)
  final int? headerBgColor;
  @JsonKey(name: 'pageBgColor', includeIfNull: false)
  final int? pageBgColor;
  @JsonKey(name: 'appName', includeIfNull: false, defaultValue: '')
  final String? appName;
  @JsonKey(name: 'logoText', includeIfNull: false, defaultValue: '')
  final String? logoText;
  @JsonKey(name: 'enforceClient', includeIfNull: false, defaultValue: false)
  final bool? enforceClient;
  @JsonKey(name: 'useMenuAsLanding', includeIfNull: false, defaultValue: false)
  final bool? useMenuAsLanding;
  static const fromJsonFactory = _$TwinSysInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysInfo &&
            (identical(other.logoImage, logoImage) ||
                const DeepCollectionEquality()
                    .equals(other.logoImage, logoImage)) &&
            (identical(other.bannerImage, bannerImage) ||
                const DeepCollectionEquality()
                    .equals(other.bannerImage, bannerImage)) &&
            (identical(other.font, font) ||
                const DeepCollectionEquality().equals(other.font, font)) &&
            (identical(other.fontSize, fontSize) ||
                const DeepCollectionEquality()
                    .equals(other.fontSize, fontSize)) &&
            (identical(other.fontColor, fontColor) ||
                const DeepCollectionEquality()
                    .equals(other.fontColor, fontColor)) &&
            (identical(other.headerFont, headerFont) ||
                const DeepCollectionEquality()
                    .equals(other.headerFont, headerFont)) &&
            (identical(other.headerFontSize, headerFontSize) ||
                const DeepCollectionEquality()
                    .equals(other.headerFontSize, headerFontSize)) &&
            (identical(other.headerFontColor, headerFontColor) ||
                const DeepCollectionEquality()
                    .equals(other.headerFontColor, headerFontColor)) &&
            (identical(other.subHeaderFont, subHeaderFont) ||
                const DeepCollectionEquality()
                    .equals(other.subHeaderFont, subHeaderFont)) &&
            (identical(other.subHeaderFontSize, subHeaderFontSize) ||
                const DeepCollectionEquality()
                    .equals(other.subHeaderFontSize, subHeaderFontSize)) &&
            (identical(other.subHeaderFontColor, subHeaderFontColor) ||
                const DeepCollectionEquality()
                    .equals(other.subHeaderFontColor, subHeaderFontColor)) &&
            (identical(other.menuFont, menuFont) ||
                const DeepCollectionEquality()
                    .equals(other.menuFont, menuFont)) &&
            (identical(other.menuFontSize, menuFontSize) ||
                const DeepCollectionEquality()
                    .equals(other.menuFontSize, menuFontSize)) &&
            (identical(other.menuFontColor, menuFontColor) ||
                const DeepCollectionEquality()
                    .equals(other.menuFontColor, menuFontColor)) &&
            (identical(other.toolFont, toolFont) ||
                const DeepCollectionEquality()
                    .equals(other.toolFont, toolFont)) &&
            (identical(other.toolFontSize, toolFontSize) ||
                const DeepCollectionEquality()
                    .equals(other.toolFontSize, toolFontSize)) &&
            (identical(other.toolFontColor, toolFontColor) ||
                const DeepCollectionEquality()
                    .equals(other.toolFontColor, toolFontColor)) &&
            (identical(other.toolIconColor, toolIconColor) ||
                const DeepCollectionEquality()
                    .equals(other.toolIconColor, toolIconColor)) &&
            (identical(other.labelFont, labelFont) ||
                const DeepCollectionEquality()
                    .equals(other.labelFont, labelFont)) &&
            (identical(other.labelFontSize, labelFontSize) ||
                const DeepCollectionEquality()
                    .equals(other.labelFontSize, labelFontSize)) &&
            (identical(other.labelFontColor, labelFontColor) ||
                const DeepCollectionEquality()
                    .equals(other.labelFontColor, labelFontColor)) &&
            (identical(other.labelIconColor, labelIconColor) ||
                const DeepCollectionEquality()
                    .equals(other.labelIconColor, labelIconColor)) &&
            (identical(other.enableSelfRegistration, enableSelfRegistration) || const DeepCollectionEquality().equals(other.enableSelfRegistration, enableSelfRegistration)) &&
            (identical(other.selfRegistrationDomain, selfRegistrationDomain) || const DeepCollectionEquality().equals(other.selfRegistrationDomain, selfRegistrationDomain)) &&
            (identical(other.autoApproveSelfRegistration, autoApproveSelfRegistration) || const DeepCollectionEquality().equals(other.autoApproveSelfRegistration, autoApproveSelfRegistration)) &&
            (identical(other.landingPages, landingPages) || const DeepCollectionEquality().equals(other.landingPages, landingPages)) &&
            (identical(other.emailProvider, emailProvider) || const DeepCollectionEquality().equals(other.emailProvider, emailProvider)) &&
            (identical(other.smsProvider, smsProvider) || const DeepCollectionEquality().equals(other.smsProvider, smsProvider)) &&
            (identical(other.voiceProvider, voiceProvider) || const DeepCollectionEquality().equals(other.voiceProvider, voiceProvider)) &&
            (identical(other.elasticEmailConfig, elasticEmailConfig) || const DeepCollectionEquality().equals(other.elasticEmailConfig, elasticEmailConfig)) &&
            (identical(other.twilioConfig, twilioConfig) || const DeepCollectionEquality().equals(other.twilioConfig, twilioConfig)) &&
            (identical(other.textLocalConfig, textLocalConfig) || const DeepCollectionEquality().equals(other.textLocalConfig, textLocalConfig)) &&
            (identical(other.geoapifyConfig, geoapifyConfig) || const DeepCollectionEquality().equals(other.geoapifyConfig, geoapifyConfig)) &&
            (identical(other.enforceRoles, enforceRoles) || const DeepCollectionEquality().equals(other.enforceRoles, enforceRoles)) &&
            (identical(other.headerBgColor, headerBgColor) || const DeepCollectionEquality().equals(other.headerBgColor, headerBgColor)) &&
            (identical(other.pageBgColor, pageBgColor) || const DeepCollectionEquality().equals(other.pageBgColor, pageBgColor)) &&
            (identical(other.appName, appName) || const DeepCollectionEquality().equals(other.appName, appName)) &&
            (identical(other.logoText, logoText) || const DeepCollectionEquality().equals(other.logoText, logoText)) &&
            (identical(other.enforceClient, enforceClient) || const DeepCollectionEquality().equals(other.enforceClient, enforceClient)) &&
            (identical(other.useMenuAsLanding, useMenuAsLanding) || const DeepCollectionEquality().equals(other.useMenuAsLanding, useMenuAsLanding)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(logoImage) ^
      const DeepCollectionEquality().hash(bannerImage) ^
      const DeepCollectionEquality().hash(font) ^
      const DeepCollectionEquality().hash(fontSize) ^
      const DeepCollectionEquality().hash(fontColor) ^
      const DeepCollectionEquality().hash(headerFont) ^
      const DeepCollectionEquality().hash(headerFontSize) ^
      const DeepCollectionEquality().hash(headerFontColor) ^
      const DeepCollectionEquality().hash(subHeaderFont) ^
      const DeepCollectionEquality().hash(subHeaderFontSize) ^
      const DeepCollectionEquality().hash(subHeaderFontColor) ^
      const DeepCollectionEquality().hash(menuFont) ^
      const DeepCollectionEquality().hash(menuFontSize) ^
      const DeepCollectionEquality().hash(menuFontColor) ^
      const DeepCollectionEquality().hash(toolFont) ^
      const DeepCollectionEquality().hash(toolFontSize) ^
      const DeepCollectionEquality().hash(toolFontColor) ^
      const DeepCollectionEquality().hash(toolIconColor) ^
      const DeepCollectionEquality().hash(labelFont) ^
      const DeepCollectionEquality().hash(labelFontSize) ^
      const DeepCollectionEquality().hash(labelFontColor) ^
      const DeepCollectionEquality().hash(labelIconColor) ^
      const DeepCollectionEquality().hash(enableSelfRegistration) ^
      const DeepCollectionEquality().hash(selfRegistrationDomain) ^
      const DeepCollectionEquality().hash(autoApproveSelfRegistration) ^
      const DeepCollectionEquality().hash(landingPages) ^
      const DeepCollectionEquality().hash(emailProvider) ^
      const DeepCollectionEquality().hash(smsProvider) ^
      const DeepCollectionEquality().hash(voiceProvider) ^
      const DeepCollectionEquality().hash(elasticEmailConfig) ^
      const DeepCollectionEquality().hash(twilioConfig) ^
      const DeepCollectionEquality().hash(textLocalConfig) ^
      const DeepCollectionEquality().hash(geoapifyConfig) ^
      const DeepCollectionEquality().hash(enforceRoles) ^
      const DeepCollectionEquality().hash(headerBgColor) ^
      const DeepCollectionEquality().hash(pageBgColor) ^
      const DeepCollectionEquality().hash(appName) ^
      const DeepCollectionEquality().hash(logoText) ^
      const DeepCollectionEquality().hash(enforceClient) ^
      const DeepCollectionEquality().hash(useMenuAsLanding) ^
      runtimeType.hashCode;
}

extension $TwinSysInfoExtension on TwinSysInfo {
  TwinSysInfo copyWith(
      {String? logoImage,
      String? bannerImage,
      String? font,
      double? fontSize,
      int? fontColor,
      String? headerFont,
      double? headerFontSize,
      int? headerFontColor,
      String? subHeaderFont,
      double? subHeaderFontSize,
      int? subHeaderFontColor,
      String? menuFont,
      double? menuFontSize,
      int? menuFontColor,
      String? toolFont,
      double? toolFontSize,
      int? toolFontColor,
      int? toolIconColor,
      String? labelFont,
      double? labelFontSize,
      int? labelFontColor,
      int? labelIconColor,
      bool? enableSelfRegistration,
      String? selfRegistrationDomain,
      bool? autoApproveSelfRegistration,
      List<LandingPage>? landingPages,
      enums.TwinSysInfoEmailProvider? emailProvider,
      enums.TwinSysInfoSmsProvider? smsProvider,
      enums.TwinSysInfoVoiceProvider? voiceProvider,
      ElasticEmailConfig? elasticEmailConfig,
      TwilioConfig? twilioConfig,
      TextLocalConfig? textLocalConfig,
      GeoapifyConfig? geoapifyConfig,
      bool? enforceRoles,
      int? headerBgColor,
      int? pageBgColor,
      String? appName,
      String? logoText,
      bool? enforceClient,
      bool? useMenuAsLanding}) {
    return TwinSysInfo(
        logoImage: logoImage ?? this.logoImage,
        bannerImage: bannerImage ?? this.bannerImage,
        font: font ?? this.font,
        fontSize: fontSize ?? this.fontSize,
        fontColor: fontColor ?? this.fontColor,
        headerFont: headerFont ?? this.headerFont,
        headerFontSize: headerFontSize ?? this.headerFontSize,
        headerFontColor: headerFontColor ?? this.headerFontColor,
        subHeaderFont: subHeaderFont ?? this.subHeaderFont,
        subHeaderFontSize: subHeaderFontSize ?? this.subHeaderFontSize,
        subHeaderFontColor: subHeaderFontColor ?? this.subHeaderFontColor,
        menuFont: menuFont ?? this.menuFont,
        menuFontSize: menuFontSize ?? this.menuFontSize,
        menuFontColor: menuFontColor ?? this.menuFontColor,
        toolFont: toolFont ?? this.toolFont,
        toolFontSize: toolFontSize ?? this.toolFontSize,
        toolFontColor: toolFontColor ?? this.toolFontColor,
        toolIconColor: toolIconColor ?? this.toolIconColor,
        labelFont: labelFont ?? this.labelFont,
        labelFontSize: labelFontSize ?? this.labelFontSize,
        labelFontColor: labelFontColor ?? this.labelFontColor,
        labelIconColor: labelIconColor ?? this.labelIconColor,
        enableSelfRegistration:
            enableSelfRegistration ?? this.enableSelfRegistration,
        selfRegistrationDomain:
            selfRegistrationDomain ?? this.selfRegistrationDomain,
        autoApproveSelfRegistration:
            autoApproveSelfRegistration ?? this.autoApproveSelfRegistration,
        landingPages: landingPages ?? this.landingPages,
        emailProvider: emailProvider ?? this.emailProvider,
        smsProvider: smsProvider ?? this.smsProvider,
        voiceProvider: voiceProvider ?? this.voiceProvider,
        elasticEmailConfig: elasticEmailConfig ?? this.elasticEmailConfig,
        twilioConfig: twilioConfig ?? this.twilioConfig,
        textLocalConfig: textLocalConfig ?? this.textLocalConfig,
        geoapifyConfig: geoapifyConfig ?? this.geoapifyConfig,
        enforceRoles: enforceRoles ?? this.enforceRoles,
        headerBgColor: headerBgColor ?? this.headerBgColor,
        pageBgColor: pageBgColor ?? this.pageBgColor,
        appName: appName ?? this.appName,
        logoText: logoText ?? this.logoText,
        enforceClient: enforceClient ?? this.enforceClient,
        useMenuAsLanding: useMenuAsLanding ?? this.useMenuAsLanding);
  }

  TwinSysInfo copyWithWrapped(
      {Wrapped<String?>? logoImage,
      Wrapped<String?>? bannerImage,
      Wrapped<String?>? font,
      Wrapped<double?>? fontSize,
      Wrapped<int?>? fontColor,
      Wrapped<String?>? headerFont,
      Wrapped<double?>? headerFontSize,
      Wrapped<int?>? headerFontColor,
      Wrapped<String?>? subHeaderFont,
      Wrapped<double?>? subHeaderFontSize,
      Wrapped<int?>? subHeaderFontColor,
      Wrapped<String?>? menuFont,
      Wrapped<double?>? menuFontSize,
      Wrapped<int?>? menuFontColor,
      Wrapped<String?>? toolFont,
      Wrapped<double?>? toolFontSize,
      Wrapped<int?>? toolFontColor,
      Wrapped<int?>? toolIconColor,
      Wrapped<String?>? labelFont,
      Wrapped<double?>? labelFontSize,
      Wrapped<int?>? labelFontColor,
      Wrapped<int?>? labelIconColor,
      Wrapped<bool?>? enableSelfRegistration,
      Wrapped<String?>? selfRegistrationDomain,
      Wrapped<bool?>? autoApproveSelfRegistration,
      Wrapped<List<LandingPage>?>? landingPages,
      Wrapped<enums.TwinSysInfoEmailProvider?>? emailProvider,
      Wrapped<enums.TwinSysInfoSmsProvider?>? smsProvider,
      Wrapped<enums.TwinSysInfoVoiceProvider?>? voiceProvider,
      Wrapped<ElasticEmailConfig?>? elasticEmailConfig,
      Wrapped<TwilioConfig?>? twilioConfig,
      Wrapped<TextLocalConfig?>? textLocalConfig,
      Wrapped<GeoapifyConfig?>? geoapifyConfig,
      Wrapped<bool?>? enforceRoles,
      Wrapped<int?>? headerBgColor,
      Wrapped<int?>? pageBgColor,
      Wrapped<String?>? appName,
      Wrapped<String?>? logoText,
      Wrapped<bool?>? enforceClient,
      Wrapped<bool?>? useMenuAsLanding}) {
    return TwinSysInfo(
        logoImage: (logoImage != null ? logoImage.value : this.logoImage),
        bannerImage:
            (bannerImage != null ? bannerImage.value : this.bannerImage),
        font: (font != null ? font.value : this.font),
        fontSize: (fontSize != null ? fontSize.value : this.fontSize),
        fontColor: (fontColor != null ? fontColor.value : this.fontColor),
        headerFont: (headerFont != null ? headerFont.value : this.headerFont),
        headerFontSize: (headerFontSize != null
            ? headerFontSize.value
            : this.headerFontSize),
        headerFontColor: (headerFontColor != null
            ? headerFontColor.value
            : this.headerFontColor),
        subHeaderFont:
            (subHeaderFont != null ? subHeaderFont.value : this.subHeaderFont),
        subHeaderFontSize: (subHeaderFontSize != null
            ? subHeaderFontSize.value
            : this.subHeaderFontSize),
        subHeaderFontColor: (subHeaderFontColor != null
            ? subHeaderFontColor.value
            : this.subHeaderFontColor),
        menuFont: (menuFont != null ? menuFont.value : this.menuFont),
        menuFontSize:
            (menuFontSize != null ? menuFontSize.value : this.menuFontSize),
        menuFontColor:
            (menuFontColor != null ? menuFontColor.value : this.menuFontColor),
        toolFont: (toolFont != null ? toolFont.value : this.toolFont),
        toolFontSize:
            (toolFontSize != null ? toolFontSize.value : this.toolFontSize),
        toolFontColor:
            (toolFontColor != null ? toolFontColor.value : this.toolFontColor),
        toolIconColor:
            (toolIconColor != null ? toolIconColor.value : this.toolIconColor),
        labelFont: (labelFont != null ? labelFont.value : this.labelFont),
        labelFontSize:
            (labelFontSize != null ? labelFontSize.value : this.labelFontSize),
        labelFontColor: (labelFontColor != null
            ? labelFontColor.value
            : this.labelFontColor),
        labelIconColor: (labelIconColor != null
            ? labelIconColor.value
            : this.labelIconColor),
        enableSelfRegistration: (enableSelfRegistration != null
            ? enableSelfRegistration.value
            : this.enableSelfRegistration),
        selfRegistrationDomain: (selfRegistrationDomain != null
            ? selfRegistrationDomain.value
            : this.selfRegistrationDomain),
        autoApproveSelfRegistration: (autoApproveSelfRegistration != null
            ? autoApproveSelfRegistration.value
            : this.autoApproveSelfRegistration),
        landingPages:
            (landingPages != null ? landingPages.value : this.landingPages),
        emailProvider:
            (emailProvider != null ? emailProvider.value : this.emailProvider),
        smsProvider:
            (smsProvider != null ? smsProvider.value : this.smsProvider),
        voiceProvider:
            (voiceProvider != null ? voiceProvider.value : this.voiceProvider),
        elasticEmailConfig: (elasticEmailConfig != null
            ? elasticEmailConfig.value
            : this.elasticEmailConfig),
        twilioConfig:
            (twilioConfig != null ? twilioConfig.value : this.twilioConfig),
        textLocalConfig: (textLocalConfig != null
            ? textLocalConfig.value
            : this.textLocalConfig),
        geoapifyConfig: (geoapifyConfig != null
            ? geoapifyConfig.value
            : this.geoapifyConfig),
        enforceRoles:
            (enforceRoles != null ? enforceRoles.value : this.enforceRoles),
        headerBgColor:
            (headerBgColor != null ? headerBgColor.value : this.headerBgColor),
        pageBgColor:
            (pageBgColor != null ? pageBgColor.value : this.pageBgColor),
        appName: (appName != null ? appName.value : this.appName),
        logoText: (logoText != null ? logoText.value : this.logoText),
        enforceClient:
            (enforceClient != null ? enforceClient.value : this.enforceClient),
        useMenuAsLanding: (useMenuAsLanding != null
            ? useMenuAsLanding.value
            : this.useMenuAsLanding));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysInfoEntity {
  const TwinSysInfoEntity({
    this.entity,
  });

  factory TwinSysInfoEntity.fromJson(Map<String, dynamic> json) =>
      _$TwinSysInfoEntityFromJson(json);

  static const toJsonFactory = _$TwinSysInfoEntityToJson;
  Map<String, dynamic> toJson() => _$TwinSysInfoEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinSysInfo? entity;
  static const fromJsonFactory = _$TwinSysInfoEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysInfoEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $TwinSysInfoEntityExtension on TwinSysInfoEntity {
  TwinSysInfoEntity copyWith({TwinSysInfo? entity}) {
    return TwinSysInfoEntity(entity: entity ?? this.entity);
  }

  TwinSysInfoEntity copyWithWrapped({Wrapped<TwinSysInfo?>? entity}) {
    return TwinSysInfoEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysInfoEntityRes {
  const TwinSysInfoEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory TwinSysInfoEntityRes.fromJson(Map<String, dynamic> json) =>
      _$TwinSysInfoEntityResFromJson(json);

  static const toJsonFactory = _$TwinSysInfoEntityResToJson;
  Map<String, dynamic> toJson() => _$TwinSysInfoEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinSysInfo? entity;
  static const fromJsonFactory = _$TwinSysInfoEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysInfoEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $TwinSysInfoEntityResExtension on TwinSysInfoEntityRes {
  TwinSysInfoEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      TwinSysInfo? entity}) {
    return TwinSysInfoEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  TwinSysInfoEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<TwinSysInfo?>? entity}) {
    return TwinSysInfoEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysConfigInfo {
  const TwinSysConfigInfo({
    this.info,
  });

  factory TwinSysConfigInfo.fromJson(Map<String, dynamic> json) =>
      _$TwinSysConfigInfoFromJson(json);

  static const toJsonFactory = _$TwinSysConfigInfoToJson;
  Map<String, dynamic> toJson() => _$TwinSysConfigInfoToJson(this);

  @JsonKey(name: 'info', includeIfNull: false)
  final TwinSysInfo? info;
  static const fromJsonFactory = _$TwinSysConfigInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysConfigInfo &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(info) ^ runtimeType.hashCode;
}

extension $TwinSysConfigInfoExtension on TwinSysConfigInfo {
  TwinSysConfigInfo copyWith({TwinSysInfo? info}) {
    return TwinSysConfigInfo(info: info ?? this.info);
  }

  TwinSysConfigInfo copyWithWrapped({Wrapped<TwinSysInfo?>? info}) {
    return TwinSysConfigInfo(info: (info != null ? info.value : this.info));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysConfig {
  const TwinSysConfig({
    this.info,
    required this.domainKey,
    required this.id,
    required this.name,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
    this.tags,
  });

  factory TwinSysConfig.fromJson(Map<String, dynamic> json) =>
      _$TwinSysConfigFromJson(json);

  static const toJsonFactory = _$TwinSysConfigToJson;
  Map<String, dynamic> toJson() => _$TwinSysConfigToJson(this);

  @JsonKey(name: 'info', includeIfNull: false)
  final TwinSysInfo? info;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$TwinSysConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysConfig &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(info) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $TwinSysConfigExtension on TwinSysConfig {
  TwinSysConfig copyWith(
      {TwinSysInfo? info,
      String? domainKey,
      String? id,
      String? name,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      List<String>? tags}) {
    return TwinSysConfig(
        info: info ?? this.info,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        name: name ?? this.name,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        tags: tags ?? this.tags);
  }

  TwinSysConfig copyWithWrapped(
      {Wrapped<TwinSysInfo?>? info,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp,
      Wrapped<List<String>?>? tags}) {
    return TwinSysConfig(
        info: (info != null ? info.value : this.info),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysConfigEntity {
  const TwinSysConfigEntity({
    this.entity,
  });

  factory TwinSysConfigEntity.fromJson(Map<String, dynamic> json) =>
      _$TwinSysConfigEntityFromJson(json);

  static const toJsonFactory = _$TwinSysConfigEntityToJson;
  Map<String, dynamic> toJson() => _$TwinSysConfigEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinSysConfig? entity;
  static const fromJsonFactory = _$TwinSysConfigEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysConfigEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $TwinSysConfigEntityExtension on TwinSysConfigEntity {
  TwinSysConfigEntity copyWith({TwinSysConfig? entity}) {
    return TwinSysConfigEntity(entity: entity ?? this.entity);
  }

  TwinSysConfigEntity copyWithWrapped({Wrapped<TwinSysConfig?>? entity}) {
    return TwinSysConfigEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinSysConfigEntityRes {
  const TwinSysConfigEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory TwinSysConfigEntityRes.fromJson(Map<String, dynamic> json) =>
      _$TwinSysConfigEntityResFromJson(json);

  static const toJsonFactory = _$TwinSysConfigEntityResToJson;
  Map<String, dynamic> toJson() => _$TwinSysConfigEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinSysConfig? entity;
  static const fromJsonFactory = _$TwinSysConfigEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinSysConfigEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $TwinSysConfigEntityResExtension on TwinSysConfigEntityRes {
  TwinSysConfigEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      TwinSysConfig? entity}) {
    return TwinSysConfigEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  TwinSysConfigEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<TwinSysConfig?>? entity}) {
    return TwinSysConfigEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorInfo {
  const FloorInfo({
    required this.premiseId,
    required this.facilityId,
    required this.name,
    this.description,
    this.tags,
    this.floorPlan,
    this.assets,
    this.roles,
    this.location,
    required this.floorLevel,
    required this.floorType,
    this.clientIds,
    this.reportedStamp,
  });

  factory FloorInfo.fromJson(Map<String, dynamic> json) =>
      _$FloorInfoFromJson(json);

  static const toJsonFactory = _$FloorInfoToJson;
  Map<String, dynamic> toJson() => _$FloorInfoToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String facilityId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'floorPlan', includeIfNull: false, defaultValue: '')
  final String? floorPlan;
  @JsonKey(name: 'assets', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assets;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'floorLevel', includeIfNull: false)
  final int floorLevel;
  @JsonKey(
    name: 'floorType',
    includeIfNull: false,
    toJson: floorInfoFloorTypeToJson,
    fromJson: floorInfoFloorTypeFloorTypeFromJson,
  )
  final enums.FloorInfoFloorType floorType;
  static enums.FloorInfoFloorType floorInfoFloorTypeFloorTypeFromJson(
          Object? value) =>
      floorInfoFloorTypeFromJson(value, enums.FloorInfoFloorType.onground);

  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  static const fromJsonFactory = _$FloorInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorInfo &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality()
                    .equals(other.facilityId, facilityId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.floorPlan, floorPlan) ||
                const DeepCollectionEquality()
                    .equals(other.floorPlan, floorPlan)) &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.floorLevel, floorLevel) ||
                const DeepCollectionEquality()
                    .equals(other.floorLevel, floorLevel)) &&
            (identical(other.floorType, floorType) ||
                const DeepCollectionEquality()
                    .equals(other.floorType, floorType)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(floorPlan) ^
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(floorLevel) ^
      const DeepCollectionEquality().hash(floorType) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      runtimeType.hashCode;
}

extension $FloorInfoExtension on FloorInfo {
  FloorInfo copyWith(
      {String? premiseId,
      String? facilityId,
      String? name,
      String? description,
      List<String>? tags,
      String? floorPlan,
      List<String>? assets,
      List<String>? roles,
      GeoLocation? location,
      int? floorLevel,
      enums.FloorInfoFloorType? floorType,
      List<String>? clientIds,
      int? reportedStamp}) {
    return FloorInfo(
        premiseId: premiseId ?? this.premiseId,
        facilityId: facilityId ?? this.facilityId,
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        floorPlan: floorPlan ?? this.floorPlan,
        assets: assets ?? this.assets,
        roles: roles ?? this.roles,
        location: location ?? this.location,
        floorLevel: floorLevel ?? this.floorLevel,
        floorType: floorType ?? this.floorType,
        clientIds: clientIds ?? this.clientIds,
        reportedStamp: reportedStamp ?? this.reportedStamp);
  }

  FloorInfo copyWithWrapped(
      {Wrapped<String>? premiseId,
      Wrapped<String>? facilityId,
      Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? floorPlan,
      Wrapped<List<String>?>? assets,
      Wrapped<List<String>?>? roles,
      Wrapped<GeoLocation?>? location,
      Wrapped<int>? floorLevel,
      Wrapped<enums.FloorInfoFloorType>? floorType,
      Wrapped<List<String>?>? clientIds,
      Wrapped<int?>? reportedStamp}) {
    return FloorInfo(
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        facilityId: (facilityId != null ? facilityId.value : this.facilityId),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        floorPlan: (floorPlan != null ? floorPlan.value : this.floorPlan),
        assets: (assets != null ? assets.value : this.assets),
        roles: (roles != null ? roles.value : this.roles),
        location: (location != null ? location.value : this.location),
        floorLevel: (floorLevel != null ? floorLevel.value : this.floorLevel),
        floorType: (floorType != null ? floorType.value : this.floorType),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class Floor {
  const Floor({
    required this.premiseId,
    required this.facilityId,
    required this.name,
    this.description,
    this.tags,
    this.floorPlan,
    this.assets,
    this.roles,
    this.location,
    required this.floorLevel,
    required this.floorType,
    this.clientIds,
    this.reportedStamp,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Floor.fromJson(Map<String, dynamic> json) => _$FloorFromJson(json);

  static const toJsonFactory = _$FloorToJson;
  Map<String, dynamic> toJson() => _$FloorToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String facilityId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'floorPlan', includeIfNull: false, defaultValue: '')
  final String? floorPlan;
  @JsonKey(name: 'assets', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assets;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'floorLevel', includeIfNull: false)
  final int floorLevel;
  @JsonKey(
    name: 'floorType',
    includeIfNull: false,
    toJson: floorFloorTypeToJson,
    fromJson: floorFloorTypeFloorTypeFromJson,
  )
  final enums.FloorFloorType floorType;
  static enums.FloorFloorType floorFloorTypeFloorTypeFromJson(Object? value) =>
      floorFloorTypeFromJson(value, enums.FloorFloorType.onground);

  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$FloorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Floor &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality()
                    .equals(other.facilityId, facilityId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.floorPlan, floorPlan) ||
                const DeepCollectionEquality()
                    .equals(other.floorPlan, floorPlan)) &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.floorLevel, floorLevel) ||
                const DeepCollectionEquality()
                    .equals(other.floorLevel, floorLevel)) &&
            (identical(other.floorType, floorType) ||
                const DeepCollectionEquality()
                    .equals(other.floorType, floorType)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(floorPlan) ^
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(floorLevel) ^
      const DeepCollectionEquality().hash(floorType) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $FloorExtension on Floor {
  Floor copyWith(
      {String? premiseId,
      String? facilityId,
      String? name,
      String? description,
      List<String>? tags,
      String? floorPlan,
      List<String>? assets,
      List<String>? roles,
      GeoLocation? location,
      int? floorLevel,
      enums.FloorFloorType? floorType,
      List<String>? clientIds,
      int? reportedStamp,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Floor(
        premiseId: premiseId ?? this.premiseId,
        facilityId: facilityId ?? this.facilityId,
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        floorPlan: floorPlan ?? this.floorPlan,
        assets: assets ?? this.assets,
        roles: roles ?? this.roles,
        location: location ?? this.location,
        floorLevel: floorLevel ?? this.floorLevel,
        floorType: floorType ?? this.floorType,
        clientIds: clientIds ?? this.clientIds,
        reportedStamp: reportedStamp ?? this.reportedStamp,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Floor copyWithWrapped(
      {Wrapped<String>? premiseId,
      Wrapped<String>? facilityId,
      Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? floorPlan,
      Wrapped<List<String>?>? assets,
      Wrapped<List<String>?>? roles,
      Wrapped<GeoLocation?>? location,
      Wrapped<int>? floorLevel,
      Wrapped<enums.FloorFloorType>? floorType,
      Wrapped<List<String>?>? clientIds,
      Wrapped<int?>? reportedStamp,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Floor(
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        facilityId: (facilityId != null ? facilityId.value : this.facilityId),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        floorPlan: (floorPlan != null ? floorPlan.value : this.floorPlan),
        assets: (assets != null ? assets.value : this.assets),
        roles: (roles != null ? roles.value : this.roles),
        location: (location != null ? location.value : this.location),
        floorLevel: (floorLevel != null ? floorLevel.value : this.floorLevel),
        floorType: (floorType != null ? floorType.value : this.floorType),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorEntity {
  const FloorEntity({
    this.entity,
  });

  factory FloorEntity.fromJson(Map<String, dynamic> json) =>
      _$FloorEntityFromJson(json);

  static const toJsonFactory = _$FloorEntityToJson;
  Map<String, dynamic> toJson() => _$FloorEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Floor? entity;
  static const fromJsonFactory = _$FloorEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FloorEntityExtension on FloorEntity {
  FloorEntity copyWith({Floor? entity}) {
    return FloorEntity(entity: entity ?? this.entity);
  }

  FloorEntity copyWithWrapped({Wrapped<Floor?>? entity}) {
    return FloorEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorEntityRes {
  const FloorEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory FloorEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FloorEntityResFromJson(json);

  static const toJsonFactory = _$FloorEntityResToJson;
  Map<String, dynamic> toJson() => _$FloorEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Floor? entity;
  static const fromJsonFactory = _$FloorEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $FloorEntityResExtension on FloorEntityRes {
  FloorEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Floor? entity}) {
    return FloorEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  FloorEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Floor?>? entity}) {
    return FloorEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorArray {
  const FloorArray({
    this.values,
  });

  factory FloorArray.fromJson(Map<String, dynamic> json) =>
      _$FloorArrayFromJson(json);

  static const toJsonFactory = _$FloorArrayToJson;
  Map<String, dynamic> toJson() => _$FloorArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Floor>[])
  final List<Floor>? values;
  static const fromJsonFactory = _$FloorArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $FloorArrayExtension on FloorArray {
  FloorArray copyWith({List<Floor>? values}) {
    return FloorArray(values: values ?? this.values);
  }

  FloorArray copyWithWrapped({Wrapped<List<Floor>?>? values}) {
    return FloorArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorArrayRes {
  const FloorArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory FloorArrayRes.fromJson(Map<String, dynamic> json) =>
      _$FloorArrayResFromJson(json);

  static const toJsonFactory = _$FloorArrayResToJson;
  Map<String, dynamic> toJson() => _$FloorArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Floor>[])
  final List<Floor>? values;
  static const fromJsonFactory = _$FloorArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $FloorArrayResExtension on FloorArrayRes {
  FloorArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Floor>? values}) {
    return FloorArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  FloorArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Floor>?>? values}) {
    return FloorArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetInfo {
  const AssetInfo({
    required this.premiseId,
    required this.facilityId,
    required this.floorId,
    required this.name,
    this.description,
    this.tags,
    this.selectedImage,
    this.images,
    this.devices,
    this.roles,
    this.location,
    this.position,
    required this.assetModelId,
    this.clientIds,
    this.reportedStamp,
  });

  factory AssetInfo.fromJson(Map<String, dynamic> json) =>
      _$AssetInfoFromJson(json);

  static const toJsonFactory = _$AssetInfoToJson;
  Map<String, dynamic> toJson() => _$AssetInfoToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String floorId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'devices', includeIfNull: false, defaultValue: <String>[])
  final List<String>? devices;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'position', includeIfNull: false)
  final ScreenPosition? position;
  @JsonKey(name: 'assetModelId', includeIfNull: false, defaultValue: '')
  final String assetModelId;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  static const fromJsonFactory = _$AssetInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetInfo &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality()
                    .equals(other.facilityId, facilityId)) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality()
                    .equals(other.floorId, floorId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality()
                    .equals(other.devices, devices)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality()
                    .equals(other.position, position)) &&
            (identical(other.assetModelId, assetModelId) ||
                const DeepCollectionEquality()
                    .equals(other.assetModelId, assetModelId)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(devices) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(assetModelId) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      runtimeType.hashCode;
}

extension $AssetInfoExtension on AssetInfo {
  AssetInfo copyWith(
      {String? premiseId,
      String? facilityId,
      String? floorId,
      String? name,
      String? description,
      List<String>? tags,
      int? selectedImage,
      List<String>? images,
      List<String>? devices,
      List<String>? roles,
      GeoLocation? location,
      ScreenPosition? position,
      String? assetModelId,
      List<String>? clientIds,
      int? reportedStamp}) {
    return AssetInfo(
        premiseId: premiseId ?? this.premiseId,
        facilityId: facilityId ?? this.facilityId,
        floorId: floorId ?? this.floorId,
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        selectedImage: selectedImage ?? this.selectedImage,
        images: images ?? this.images,
        devices: devices ?? this.devices,
        roles: roles ?? this.roles,
        location: location ?? this.location,
        position: position ?? this.position,
        assetModelId: assetModelId ?? this.assetModelId,
        clientIds: clientIds ?? this.clientIds,
        reportedStamp: reportedStamp ?? this.reportedStamp);
  }

  AssetInfo copyWithWrapped(
      {Wrapped<String>? premiseId,
      Wrapped<String>? facilityId,
      Wrapped<String>? floorId,
      Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<int?>? selectedImage,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? devices,
      Wrapped<List<String>?>? roles,
      Wrapped<GeoLocation?>? location,
      Wrapped<ScreenPosition?>? position,
      Wrapped<String>? assetModelId,
      Wrapped<List<String>?>? clientIds,
      Wrapped<int?>? reportedStamp}) {
    return AssetInfo(
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        facilityId: (facilityId != null ? facilityId.value : this.facilityId),
        floorId: (floorId != null ? floorId.value : this.floorId),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        images: (images != null ? images.value : this.images),
        devices: (devices != null ? devices.value : this.devices),
        roles: (roles != null ? roles.value : this.roles),
        location: (location != null ? location.value : this.location),
        position: (position != null ? position.value : this.position),
        assetModelId:
            (assetModelId != null ? assetModelId.value : this.assetModelId),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class Asset {
  const Asset({
    required this.premiseId,
    required this.facilityId,
    required this.floorId,
    required this.name,
    this.description,
    this.tags,
    this.selectedImage,
    this.images,
    this.devices,
    this.roles,
    this.location,
    this.position,
    required this.assetModelId,
    this.clientIds,
    this.reportedStamp,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Asset.fromJson(Map<String, dynamic> json) => _$AssetFromJson(json);

  static const toJsonFactory = _$AssetToJson;
  Map<String, dynamic> toJson() => _$AssetToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String premiseId;
  @JsonKey(name: 'facilityId', includeIfNull: false, defaultValue: '')
  final String facilityId;
  @JsonKey(name: 'floorId', includeIfNull: false, defaultValue: '')
  final String floorId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'devices', includeIfNull: false, defaultValue: <String>[])
  final List<String>? devices;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'position', includeIfNull: false)
  final ScreenPosition? position;
  @JsonKey(name: 'assetModelId', includeIfNull: false, defaultValue: '')
  final String assetModelId;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$AssetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Asset &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)) &&
            (identical(other.facilityId, facilityId) ||
                const DeepCollectionEquality()
                    .equals(other.facilityId, facilityId)) &&
            (identical(other.floorId, floorId) ||
                const DeepCollectionEquality()
                    .equals(other.floorId, floorId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality()
                    .equals(other.devices, devices)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality()
                    .equals(other.position, position)) &&
            (identical(other.assetModelId, assetModelId) ||
                const DeepCollectionEquality()
                    .equals(other.assetModelId, assetModelId)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(facilityId) ^
      const DeepCollectionEquality().hash(floorId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(devices) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(assetModelId) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $AssetExtension on Asset {
  Asset copyWith(
      {String? premiseId,
      String? facilityId,
      String? floorId,
      String? name,
      String? description,
      List<String>? tags,
      int? selectedImage,
      List<String>? images,
      List<String>? devices,
      List<String>? roles,
      GeoLocation? location,
      ScreenPosition? position,
      String? assetModelId,
      List<String>? clientIds,
      int? reportedStamp,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Asset(
        premiseId: premiseId ?? this.premiseId,
        facilityId: facilityId ?? this.facilityId,
        floorId: floorId ?? this.floorId,
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        selectedImage: selectedImage ?? this.selectedImage,
        images: images ?? this.images,
        devices: devices ?? this.devices,
        roles: roles ?? this.roles,
        location: location ?? this.location,
        position: position ?? this.position,
        assetModelId: assetModelId ?? this.assetModelId,
        clientIds: clientIds ?? this.clientIds,
        reportedStamp: reportedStamp ?? this.reportedStamp,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Asset copyWithWrapped(
      {Wrapped<String>? premiseId,
      Wrapped<String>? facilityId,
      Wrapped<String>? floorId,
      Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<int?>? selectedImage,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? devices,
      Wrapped<List<String>?>? roles,
      Wrapped<GeoLocation?>? location,
      Wrapped<ScreenPosition?>? position,
      Wrapped<String>? assetModelId,
      Wrapped<List<String>?>? clientIds,
      Wrapped<int?>? reportedStamp,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Asset(
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        facilityId: (facilityId != null ? facilityId.value : this.facilityId),
        floorId: (floorId != null ? floorId.value : this.floorId),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        images: (images != null ? images.value : this.images),
        devices: (devices != null ? devices.value : this.devices),
        roles: (roles != null ? roles.value : this.roles),
        location: (location != null ? location.value : this.location),
        position: (position != null ? position.value : this.position),
        assetModelId:
            (assetModelId != null ? assetModelId.value : this.assetModelId),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetEntity {
  const AssetEntity({
    this.entity,
  });

  factory AssetEntity.fromJson(Map<String, dynamic> json) =>
      _$AssetEntityFromJson(json);

  static const toJsonFactory = _$AssetEntityToJson;
  Map<String, dynamic> toJson() => _$AssetEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Asset? entity;
  static const fromJsonFactory = _$AssetEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AssetEntityExtension on AssetEntity {
  AssetEntity copyWith({Asset? entity}) {
    return AssetEntity(entity: entity ?? this.entity);
  }

  AssetEntity copyWithWrapped({Wrapped<Asset?>? entity}) {
    return AssetEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetEntityRes {
  const AssetEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AssetEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AssetEntityResFromJson(json);

  static const toJsonFactory = _$AssetEntityResToJson;
  Map<String, dynamic> toJson() => _$AssetEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Asset? entity;
  static const fromJsonFactory = _$AssetEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AssetEntityResExtension on AssetEntityRes {
  AssetEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Asset? entity}) {
    return AssetEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  AssetEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Asset?>? entity}) {
    return AssetEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetArray {
  const AssetArray({
    this.values,
  });

  factory AssetArray.fromJson(Map<String, dynamic> json) =>
      _$AssetArrayFromJson(json);

  static const toJsonFactory = _$AssetArrayToJson;
  Map<String, dynamic> toJson() => _$AssetArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Asset>[])
  final List<Asset>? values;
  static const fromJsonFactory = _$AssetArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AssetArrayExtension on AssetArray {
  AssetArray copyWith({List<Asset>? values}) {
    return AssetArray(values: values ?? this.values);
  }

  AssetArray copyWithWrapped({Wrapped<List<Asset>?>? values}) {
    return AssetArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetArrayRes {
  const AssetArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AssetArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AssetArrayResFromJson(json);

  static const toJsonFactory = _$AssetArrayResToJson;
  Map<String, dynamic> toJson() => _$AssetArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Asset>[])
  final List<Asset>? values;
  static const fromJsonFactory = _$AssetArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AssetArrayResExtension on AssetArrayRes {
  AssetArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Asset>? values}) {
    return AssetArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  AssetArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Asset>?>? values}) {
    return AssetArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityInfo {
  const FacilityInfo({
    required this.premiseId,
    required this.name,
    this.description,
    this.tags,
    this.selectedImage,
    this.images,
    this.roles,
    this.location,
    this.clientIds,
    this.reportedStamp,
  });

  factory FacilityInfo.fromJson(Map<String, dynamic> json) =>
      _$FacilityInfoFromJson(json);

  static const toJsonFactory = _$FacilityInfoToJson;
  Map<String, dynamic> toJson() => _$FacilityInfoToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String premiseId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  static const fromJsonFactory = _$FacilityInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityInfo &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      runtimeType.hashCode;
}

extension $FacilityInfoExtension on FacilityInfo {
  FacilityInfo copyWith(
      {String? premiseId,
      String? name,
      String? description,
      List<String>? tags,
      int? selectedImage,
      List<String>? images,
      List<String>? roles,
      GeoLocation? location,
      List<String>? clientIds,
      int? reportedStamp}) {
    return FacilityInfo(
        premiseId: premiseId ?? this.premiseId,
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        selectedImage: selectedImage ?? this.selectedImage,
        images: images ?? this.images,
        roles: roles ?? this.roles,
        location: location ?? this.location,
        clientIds: clientIds ?? this.clientIds,
        reportedStamp: reportedStamp ?? this.reportedStamp);
  }

  FacilityInfo copyWithWrapped(
      {Wrapped<String>? premiseId,
      Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<int?>? selectedImage,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? roles,
      Wrapped<GeoLocation?>? location,
      Wrapped<List<String>?>? clientIds,
      Wrapped<int?>? reportedStamp}) {
    return FacilityInfo(
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        images: (images != null ? images.value : this.images),
        roles: (roles != null ? roles.value : this.roles),
        location: (location != null ? location.value : this.location),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class Facility {
  const Facility({
    required this.premiseId,
    required this.name,
    this.description,
    this.tags,
    this.selectedImage,
    this.images,
    this.roles,
    this.location,
    this.clientIds,
    this.reportedStamp,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Facility.fromJson(Map<String, dynamic> json) =>
      _$FacilityFromJson(json);

  static const toJsonFactory = _$FacilityToJson;
  Map<String, dynamic> toJson() => _$FacilityToJson(this);

  @JsonKey(name: 'premiseId', includeIfNull: false, defaultValue: '')
  final String premiseId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$FacilityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Facility &&
            (identical(other.premiseId, premiseId) ||
                const DeepCollectionEquality()
                    .equals(other.premiseId, premiseId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(premiseId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $FacilityExtension on Facility {
  Facility copyWith(
      {String? premiseId,
      String? name,
      String? description,
      List<String>? tags,
      int? selectedImage,
      List<String>? images,
      List<String>? roles,
      GeoLocation? location,
      List<String>? clientIds,
      int? reportedStamp,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Facility(
        premiseId: premiseId ?? this.premiseId,
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        selectedImage: selectedImage ?? this.selectedImage,
        images: images ?? this.images,
        roles: roles ?? this.roles,
        location: location ?? this.location,
        clientIds: clientIds ?? this.clientIds,
        reportedStamp: reportedStamp ?? this.reportedStamp,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Facility copyWithWrapped(
      {Wrapped<String>? premiseId,
      Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<int?>? selectedImage,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? roles,
      Wrapped<GeoLocation?>? location,
      Wrapped<List<String>?>? clientIds,
      Wrapped<int?>? reportedStamp,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Facility(
        premiseId: (premiseId != null ? premiseId.value : this.premiseId),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        images: (images != null ? images.value : this.images),
        roles: (roles != null ? roles.value : this.roles),
        location: (location != null ? location.value : this.location),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityEntity {
  const FacilityEntity({
    this.entity,
  });

  factory FacilityEntity.fromJson(Map<String, dynamic> json) =>
      _$FacilityEntityFromJson(json);

  static const toJsonFactory = _$FacilityEntityToJson;
  Map<String, dynamic> toJson() => _$FacilityEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Facility? entity;
  static const fromJsonFactory = _$FacilityEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FacilityEntityExtension on FacilityEntity {
  FacilityEntity copyWith({Facility? entity}) {
    return FacilityEntity(entity: entity ?? this.entity);
  }

  FacilityEntity copyWithWrapped({Wrapped<Facility?>? entity}) {
    return FacilityEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityEntityRes {
  const FacilityEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory FacilityEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FacilityEntityResFromJson(json);

  static const toJsonFactory = _$FacilityEntityResToJson;
  Map<String, dynamic> toJson() => _$FacilityEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Facility? entity;
  static const fromJsonFactory = _$FacilityEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $FacilityEntityResExtension on FacilityEntityRes {
  FacilityEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Facility? entity}) {
    return FacilityEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  FacilityEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Facility?>? entity}) {
    return FacilityEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityArray {
  const FacilityArray({
    this.values,
  });

  factory FacilityArray.fromJson(Map<String, dynamic> json) =>
      _$FacilityArrayFromJson(json);

  static const toJsonFactory = _$FacilityArrayToJson;
  Map<String, dynamic> toJson() => _$FacilityArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Facility>[])
  final List<Facility>? values;
  static const fromJsonFactory = _$FacilityArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $FacilityArrayExtension on FacilityArray {
  FacilityArray copyWith({List<Facility>? values}) {
    return FacilityArray(values: values ?? this.values);
  }

  FacilityArray copyWithWrapped({Wrapped<List<Facility>?>? values}) {
    return FacilityArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityArrayRes {
  const FacilityArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory FacilityArrayRes.fromJson(Map<String, dynamic> json) =>
      _$FacilityArrayResFromJson(json);

  static const toJsonFactory = _$FacilityArrayResToJson;
  Map<String, dynamic> toJson() => _$FacilityArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Facility>[])
  final List<Facility>? values;
  static const fromJsonFactory = _$FacilityArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $FacilityArrayResExtension on FacilityArrayRes {
  FacilityArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Facility>? values}) {
    return FacilityArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  FacilityArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Facility>?>? values}) {
    return FacilityArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserInfo {
  const TwinUserInfo({
    required this.name,
    required this.email,
    this.description,
    this.tags,
    this.phone,
    this.address,
    this.selectedImage,
    this.images,
    this.roles,
    this.userState,
    this.clientIds,
  });

  factory TwinUserInfo.fromJson(Map<String, dynamic> json) =>
      _$TwinUserInfoFromJson(json);

  static const toJsonFactory = _$TwinUserInfoToJson;
  Map<String, dynamic> toJson() => _$TwinUserInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String email;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'userState', includeIfNull: false)
  final int? userState;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  static const fromJsonFactory = _$TwinUserInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.userState, userState) ||
                const DeepCollectionEquality()
                    .equals(other.userState, userState)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(userState) ^
      const DeepCollectionEquality().hash(clientIds) ^
      runtimeType.hashCode;
}

extension $TwinUserInfoExtension on TwinUserInfo {
  TwinUserInfo copyWith(
      {String? name,
      String? email,
      String? description,
      List<String>? tags,
      String? phone,
      String? address,
      int? selectedImage,
      List<String>? images,
      List<String>? roles,
      int? userState,
      List<String>? clientIds}) {
    return TwinUserInfo(
        name: name ?? this.name,
        email: email ?? this.email,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        phone: phone ?? this.phone,
        address: address ?? this.address,
        selectedImage: selectedImage ?? this.selectedImage,
        images: images ?? this.images,
        roles: roles ?? this.roles,
        userState: userState ?? this.userState,
        clientIds: clientIds ?? this.clientIds);
  }

  TwinUserInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? email,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? phone,
      Wrapped<String?>? address,
      Wrapped<int?>? selectedImage,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? roles,
      Wrapped<int?>? userState,
      Wrapped<List<String>?>? clientIds}) {
    return TwinUserInfo(
        name: (name != null ? name.value : this.name),
        email: (email != null ? email.value : this.email),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        phone: (phone != null ? phone.value : this.phone),
        address: (address != null ? address.value : this.address),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        images: (images != null ? images.value : this.images),
        roles: (roles != null ? roles.value : this.roles),
        userState: (userState != null ? userState.value : this.userState),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserBase {
  const TwinUserBase({
    this.stripeCustomerId,
    this.stripeSubscriptionId,
    this.platformRoles,
  });

  factory TwinUserBase.fromJson(Map<String, dynamic> json) =>
      _$TwinUserBaseFromJson(json);

  static const toJsonFactory = _$TwinUserBaseToJson;
  Map<String, dynamic> toJson() => _$TwinUserBaseToJson(this);

  @JsonKey(name: 'stripeCustomerId', includeIfNull: false, defaultValue: '')
  final String? stripeCustomerId;
  @JsonKey(name: 'stripeSubscriptionId', includeIfNull: false, defaultValue: '')
  final String? stripeSubscriptionId;
  @JsonKey(
      name: 'platformRoles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? platformRoles;
  static const fromJsonFactory = _$TwinUserBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserBase &&
            (identical(other.stripeCustomerId, stripeCustomerId) ||
                const DeepCollectionEquality()
                    .equals(other.stripeCustomerId, stripeCustomerId)) &&
            (identical(other.stripeSubscriptionId, stripeSubscriptionId) ||
                const DeepCollectionEquality().equals(
                    other.stripeSubscriptionId, stripeSubscriptionId)) &&
            (identical(other.platformRoles, platformRoles) ||
                const DeepCollectionEquality()
                    .equals(other.platformRoles, platformRoles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stripeCustomerId) ^
      const DeepCollectionEquality().hash(stripeSubscriptionId) ^
      const DeepCollectionEquality().hash(platformRoles) ^
      runtimeType.hashCode;
}

extension $TwinUserBaseExtension on TwinUserBase {
  TwinUserBase copyWith(
      {String? stripeCustomerId,
      String? stripeSubscriptionId,
      List<String>? platformRoles}) {
    return TwinUserBase(
        stripeCustomerId: stripeCustomerId ?? this.stripeCustomerId,
        stripeSubscriptionId: stripeSubscriptionId ?? this.stripeSubscriptionId,
        platformRoles: platformRoles ?? this.platformRoles);
  }

  TwinUserBase copyWithWrapped(
      {Wrapped<String?>? stripeCustomerId,
      Wrapped<String?>? stripeSubscriptionId,
      Wrapped<List<String>?>? platformRoles}) {
    return TwinUserBase(
        stripeCustomerId: (stripeCustomerId != null
            ? stripeCustomerId.value
            : this.stripeCustomerId),
        stripeSubscriptionId: (stripeSubscriptionId != null
            ? stripeSubscriptionId.value
            : this.stripeSubscriptionId),
        platformRoles:
            (platformRoles != null ? platformRoles.value : this.platformRoles));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUser {
  const TwinUser({
    required this.name,
    required this.email,
    this.description,
    this.tags,
    this.phone,
    this.address,
    this.selectedImage,
    this.images,
    this.roles,
    this.userState,
    this.clientIds,
    this.stripeCustomerId,
    this.stripeSubscriptionId,
    this.platformRoles,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory TwinUser.fromJson(Map<String, dynamic> json) =>
      _$TwinUserFromJson(json);

  static const toJsonFactory = _$TwinUserToJson;
  Map<String, dynamic> toJson() => _$TwinUserToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String email;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'userState', includeIfNull: false)
  final int? userState;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'stripeCustomerId', includeIfNull: false, defaultValue: '')
  final String? stripeCustomerId;
  @JsonKey(name: 'stripeSubscriptionId', includeIfNull: false, defaultValue: '')
  final String? stripeSubscriptionId;
  @JsonKey(
      name: 'platformRoles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? platformRoles;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$TwinUserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUser &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.userState, userState) ||
                const DeepCollectionEquality()
                    .equals(other.userState, userState)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.stripeCustomerId, stripeCustomerId) ||
                const DeepCollectionEquality()
                    .equals(other.stripeCustomerId, stripeCustomerId)) &&
            (identical(other.stripeSubscriptionId, stripeSubscriptionId) ||
                const DeepCollectionEquality().equals(
                    other.stripeSubscriptionId, stripeSubscriptionId)) &&
            (identical(other.platformRoles, platformRoles) ||
                const DeepCollectionEquality()
                    .equals(other.platformRoles, platformRoles)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(userState) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(stripeCustomerId) ^
      const DeepCollectionEquality().hash(stripeSubscriptionId) ^
      const DeepCollectionEquality().hash(platformRoles) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $TwinUserExtension on TwinUser {
  TwinUser copyWith(
      {String? name,
      String? email,
      String? description,
      List<String>? tags,
      String? phone,
      String? address,
      int? selectedImage,
      List<String>? images,
      List<String>? roles,
      int? userState,
      List<String>? clientIds,
      String? stripeCustomerId,
      String? stripeSubscriptionId,
      List<String>? platformRoles,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return TwinUser(
        name: name ?? this.name,
        email: email ?? this.email,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        phone: phone ?? this.phone,
        address: address ?? this.address,
        selectedImage: selectedImage ?? this.selectedImage,
        images: images ?? this.images,
        roles: roles ?? this.roles,
        userState: userState ?? this.userState,
        clientIds: clientIds ?? this.clientIds,
        stripeCustomerId: stripeCustomerId ?? this.stripeCustomerId,
        stripeSubscriptionId: stripeSubscriptionId ?? this.stripeSubscriptionId,
        platformRoles: platformRoles ?? this.platformRoles,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  TwinUser copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? email,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? phone,
      Wrapped<String?>? address,
      Wrapped<int?>? selectedImage,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? roles,
      Wrapped<int?>? userState,
      Wrapped<List<String>?>? clientIds,
      Wrapped<String?>? stripeCustomerId,
      Wrapped<String?>? stripeSubscriptionId,
      Wrapped<List<String>?>? platformRoles,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return TwinUser(
        name: (name != null ? name.value : this.name),
        email: (email != null ? email.value : this.email),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        phone: (phone != null ? phone.value : this.phone),
        address: (address != null ? address.value : this.address),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        images: (images != null ? images.value : this.images),
        roles: (roles != null ? roles.value : this.roles),
        userState: (userState != null ? userState.value : this.userState),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        stripeCustomerId: (stripeCustomerId != null
            ? stripeCustomerId.value
            : this.stripeCustomerId),
        stripeSubscriptionId: (stripeSubscriptionId != null
            ? stripeSubscriptionId.value
            : this.stripeSubscriptionId),
        platformRoles:
            (platformRoles != null ? platformRoles.value : this.platformRoles),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserEntity {
  const TwinUserEntity({
    this.entity,
  });

  factory TwinUserEntity.fromJson(Map<String, dynamic> json) =>
      _$TwinUserEntityFromJson(json);

  static const toJsonFactory = _$TwinUserEntityToJson;
  Map<String, dynamic> toJson() => _$TwinUserEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinUser? entity;
  static const fromJsonFactory = _$TwinUserEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $TwinUserEntityExtension on TwinUserEntity {
  TwinUserEntity copyWith({TwinUser? entity}) {
    return TwinUserEntity(entity: entity ?? this.entity);
  }

  TwinUserEntity copyWithWrapped({Wrapped<TwinUser?>? entity}) {
    return TwinUserEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserEntityRes {
  const TwinUserEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory TwinUserEntityRes.fromJson(Map<String, dynamic> json) =>
      _$TwinUserEntityResFromJson(json);

  static const toJsonFactory = _$TwinUserEntityResToJson;
  Map<String, dynamic> toJson() => _$TwinUserEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final TwinUser? entity;
  static const fromJsonFactory = _$TwinUserEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $TwinUserEntityResExtension on TwinUserEntityRes {
  TwinUserEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      TwinUser? entity}) {
    return TwinUserEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  TwinUserEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<TwinUser?>? entity}) {
    return TwinUserEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserArray {
  const TwinUserArray({
    this.values,
  });

  factory TwinUserArray.fromJson(Map<String, dynamic> json) =>
      _$TwinUserArrayFromJson(json);

  static const toJsonFactory = _$TwinUserArrayToJson;
  Map<String, dynamic> toJson() => _$TwinUserArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TwinUser>[])
  final List<TwinUser>? values;
  static const fromJsonFactory = _$TwinUserArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TwinUserArrayExtension on TwinUserArray {
  TwinUserArray copyWith({List<TwinUser>? values}) {
    return TwinUserArray(values: values ?? this.values);
  }

  TwinUserArray copyWithWrapped({Wrapped<List<TwinUser>?>? values}) {
    return TwinUserArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class TwinUserArrayRes {
  const TwinUserArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory TwinUserArrayRes.fromJson(Map<String, dynamic> json) =>
      _$TwinUserArrayResFromJson(json);

  static const toJsonFactory = _$TwinUserArrayResToJson;
  Map<String, dynamic> toJson() => _$TwinUserArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <TwinUser>[])
  final List<TwinUser>? values;
  static const fromJsonFactory = _$TwinUserArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwinUserArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TwinUserArrayResExtension on TwinUserArrayRes {
  TwinUserArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<TwinUser>? values}) {
    return TwinUserArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  TwinUserArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<TwinUser>?>? values}) {
    return TwinUserArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class RoleInfo {
  const RoleInfo({
    required this.name,
    this.description,
    this.tags,
  });

  factory RoleInfo.fromJson(Map<String, dynamic> json) =>
      _$RoleInfoFromJson(json);

  static const toJsonFactory = _$RoleInfoToJson;
  Map<String, dynamic> toJson() => _$RoleInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$RoleInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $RoleInfoExtension on RoleInfo {
  RoleInfo copyWith({String? name, String? description, List<String>? tags}) {
    return RoleInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags);
  }

  RoleInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags}) {
    return RoleInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class Role {
  const Role({
    required this.name,
    this.description,
    this.tags,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Role.fromJson(Map<String, dynamic> json) => _$RoleFromJson(json);

  static const toJsonFactory = _$RoleToJson;
  Map<String, dynamic> toJson() => _$RoleToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$RoleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Role &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $RoleExtension on Role {
  Role copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Role(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Role copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Role(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class RoleEntity {
  const RoleEntity({
    this.entity,
  });

  factory RoleEntity.fromJson(Map<String, dynamic> json) =>
      _$RoleEntityFromJson(json);

  static const toJsonFactory = _$RoleEntityToJson;
  Map<String, dynamic> toJson() => _$RoleEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Role? entity;
  static const fromJsonFactory = _$RoleEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $RoleEntityExtension on RoleEntity {
  RoleEntity copyWith({Role? entity}) {
    return RoleEntity(entity: entity ?? this.entity);
  }

  RoleEntity copyWithWrapped({Wrapped<Role?>? entity}) {
    return RoleEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class RoleEntityRes {
  const RoleEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory RoleEntityRes.fromJson(Map<String, dynamic> json) =>
      _$RoleEntityResFromJson(json);

  static const toJsonFactory = _$RoleEntityResToJson;
  Map<String, dynamic> toJson() => _$RoleEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Role? entity;
  static const fromJsonFactory = _$RoleEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $RoleEntityResExtension on RoleEntityRes {
  RoleEntityRes copyWith(
      {bool? ok, String? msg, String? trace, String? errorCode, Role? entity}) {
    return RoleEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  RoleEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Role?>? entity}) {
    return RoleEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class RoleArray {
  const RoleArray({
    this.values,
  });

  factory RoleArray.fromJson(Map<String, dynamic> json) =>
      _$RoleArrayFromJson(json);

  static const toJsonFactory = _$RoleArrayToJson;
  Map<String, dynamic> toJson() => _$RoleArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Role>[])
  final List<Role>? values;
  static const fromJsonFactory = _$RoleArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $RoleArrayExtension on RoleArray {
  RoleArray copyWith({List<Role>? values}) {
    return RoleArray(values: values ?? this.values);
  }

  RoleArray copyWithWrapped({Wrapped<List<Role>?>? values}) {
    return RoleArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class RoleArrayRes {
  const RoleArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory RoleArrayRes.fromJson(Map<String, dynamic> json) =>
      _$RoleArrayResFromJson(json);

  static const toJsonFactory = _$RoleArrayResToJson;
  Map<String, dynamic> toJson() => _$RoleArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Role>[])
  final List<Role>? values;
  static const fromJsonFactory = _$RoleArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RoleArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $RoleArrayResExtension on RoleArrayRes {
  RoleArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Role>? values}) {
    return RoleArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  RoleArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Role>?>? values}) {
    return RoleArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseInfo {
  const PremiseInfo({
    required this.name,
    this.description,
    this.tags,
    this.selectedImage,
    this.images,
    this.location,
    this.roles,
    this.clientIds,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
  });

  factory PremiseInfo.fromJson(Map<String, dynamic> json) =>
      _$PremiseInfoFromJson(json);

  static const toJsonFactory = _$PremiseInfoToJson;
  Map<String, dynamic> toJson() => _$PremiseInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  static const fromJsonFactory = _$PremiseInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $PremiseInfoExtension on PremiseInfo {
  PremiseInfo copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      int? selectedImage,
      List<String>? images,
      GeoLocation? location,
      List<String>? roles,
      List<String>? clientIds,
      int? reportedStamp,
      String? email,
      String? phone,
      String? address}) {
    return PremiseInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        selectedImage: selectedImage ?? this.selectedImage,
        images: images ?? this.images,
        location: location ?? this.location,
        roles: roles ?? this.roles,
        clientIds: clientIds ?? this.clientIds,
        reportedStamp: reportedStamp ?? this.reportedStamp,
        email: email ?? this.email,
        phone: phone ?? this.phone,
        address: address ?? this.address);
  }

  PremiseInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<int?>? selectedImage,
      Wrapped<List<String>?>? images,
      Wrapped<GeoLocation?>? location,
      Wrapped<List<String>?>? roles,
      Wrapped<List<String>?>? clientIds,
      Wrapped<int?>? reportedStamp,
      Wrapped<String?>? email,
      Wrapped<String?>? phone,
      Wrapped<String?>? address}) {
    return PremiseInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        images: (images != null ? images.value : this.images),
        location: (location != null ? location.value : this.location),
        roles: (roles != null ? roles.value : this.roles),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp),
        email: (email != null ? email.value : this.email),
        phone: (phone != null ? phone.value : this.phone),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class Premise {
  const Premise({
    required this.name,
    this.description,
    this.tags,
    this.selectedImage,
    this.images,
    this.location,
    this.roles,
    this.clientIds,
    this.reportedStamp,
    this.email,
    this.phone,
    this.address,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Premise.fromJson(Map<String, dynamic> json) =>
      _$PremiseFromJson(json);

  static const toJsonFactory = _$PremiseToJson;
  Map<String, dynamic> toJson() => _$PremiseToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'location', includeIfNull: false)
  final GeoLocation? location;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'clientIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? clientIds;
  @JsonKey(name: 'reportedStamp', includeIfNull: false)
  final int? reportedStamp;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$PremiseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Premise &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.clientIds, clientIds) ||
                const DeepCollectionEquality()
                    .equals(other.clientIds, clientIds)) &&
            (identical(other.reportedStamp, reportedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.reportedStamp, reportedStamp)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(clientIds) ^
      const DeepCollectionEquality().hash(reportedStamp) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $PremiseExtension on Premise {
  Premise copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      int? selectedImage,
      List<String>? images,
      GeoLocation? location,
      List<String>? roles,
      List<String>? clientIds,
      int? reportedStamp,
      String? email,
      String? phone,
      String? address,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Premise(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        selectedImage: selectedImage ?? this.selectedImage,
        images: images ?? this.images,
        location: location ?? this.location,
        roles: roles ?? this.roles,
        clientIds: clientIds ?? this.clientIds,
        reportedStamp: reportedStamp ?? this.reportedStamp,
        email: email ?? this.email,
        phone: phone ?? this.phone,
        address: address ?? this.address,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Premise copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<int?>? selectedImage,
      Wrapped<List<String>?>? images,
      Wrapped<GeoLocation?>? location,
      Wrapped<List<String>?>? roles,
      Wrapped<List<String>?>? clientIds,
      Wrapped<int?>? reportedStamp,
      Wrapped<String?>? email,
      Wrapped<String?>? phone,
      Wrapped<String?>? address,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Premise(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        images: (images != null ? images.value : this.images),
        location: (location != null ? location.value : this.location),
        roles: (roles != null ? roles.value : this.roles),
        clientIds: (clientIds != null ? clientIds.value : this.clientIds),
        reportedStamp:
            (reportedStamp != null ? reportedStamp.value : this.reportedStamp),
        email: (email != null ? email.value : this.email),
        phone: (phone != null ? phone.value : this.phone),
        address: (address != null ? address.value : this.address),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseEntity {
  const PremiseEntity({
    this.entity,
  });

  factory PremiseEntity.fromJson(Map<String, dynamic> json) =>
      _$PremiseEntityFromJson(json);

  static const toJsonFactory = _$PremiseEntityToJson;
  Map<String, dynamic> toJson() => _$PremiseEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Premise? entity;
  static const fromJsonFactory = _$PremiseEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $PremiseEntityExtension on PremiseEntity {
  PremiseEntity copyWith({Premise? entity}) {
    return PremiseEntity(entity: entity ?? this.entity);
  }

  PremiseEntity copyWithWrapped({Wrapped<Premise?>? entity}) {
    return PremiseEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseEntityRes {
  const PremiseEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory PremiseEntityRes.fromJson(Map<String, dynamic> json) =>
      _$PremiseEntityResFromJson(json);

  static const toJsonFactory = _$PremiseEntityResToJson;
  Map<String, dynamic> toJson() => _$PremiseEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Premise? entity;
  static const fromJsonFactory = _$PremiseEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $PremiseEntityResExtension on PremiseEntityRes {
  PremiseEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Premise? entity}) {
    return PremiseEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  PremiseEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Premise?>? entity}) {
    return PremiseEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseArray {
  const PremiseArray({
    this.values,
  });

  factory PremiseArray.fromJson(Map<String, dynamic> json) =>
      _$PremiseArrayFromJson(json);

  static const toJsonFactory = _$PremiseArrayToJson;
  Map<String, dynamic> toJson() => _$PremiseArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Premise>[])
  final List<Premise>? values;
  static const fromJsonFactory = _$PremiseArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $PremiseArrayExtension on PremiseArray {
  PremiseArray copyWith({List<Premise>? values}) {
    return PremiseArray(values: values ?? this.values);
  }

  PremiseArray copyWithWrapped({Wrapped<List<Premise>?>? values}) {
    return PremiseArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseArrayRes {
  const PremiseArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory PremiseArrayRes.fromJson(Map<String, dynamic> json) =>
      _$PremiseArrayResFromJson(json);

  static const toJsonFactory = _$PremiseArrayResToJson;
  Map<String, dynamic> toJson() => _$PremiseArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Premise>[])
  final List<Premise>? values;
  static const fromJsonFactory = _$PremiseArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $PremiseArrayResExtension on PremiseArrayRes {
  PremiseArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Premise>? values}) {
    return PremiseArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  PremiseArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Premise>?>? values}) {
    return PremiseArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreenPosition {
  const ScreenPosition({
    required this.topX,
    required this.topY,
    this.bottomX,
    this.bottomY,
  });

  factory ScreenPosition.fromJson(Map<String, dynamic> json) =>
      _$ScreenPositionFromJson(json);

  static const toJsonFactory = _$ScreenPositionToJson;
  Map<String, dynamic> toJson() => _$ScreenPositionToJson(this);

  @JsonKey(name: 'topX', includeIfNull: false)
  final int topX;
  @JsonKey(name: 'topY', includeIfNull: false)
  final int topY;
  @JsonKey(name: 'bottomX', includeIfNull: false)
  final int? bottomX;
  @JsonKey(name: 'bottomY', includeIfNull: false)
  final int? bottomY;
  static const fromJsonFactory = _$ScreenPositionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScreenPosition &&
            (identical(other.topX, topX) ||
                const DeepCollectionEquality().equals(other.topX, topX)) &&
            (identical(other.topY, topY) ||
                const DeepCollectionEquality().equals(other.topY, topY)) &&
            (identical(other.bottomX, bottomX) ||
                const DeepCollectionEquality()
                    .equals(other.bottomX, bottomX)) &&
            (identical(other.bottomY, bottomY) ||
                const DeepCollectionEquality().equals(other.bottomY, bottomY)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(topX) ^
      const DeepCollectionEquality().hash(topY) ^
      const DeepCollectionEquality().hash(bottomX) ^
      const DeepCollectionEquality().hash(bottomY) ^
      runtimeType.hashCode;
}

extension $ScreenPositionExtension on ScreenPosition {
  ScreenPosition copyWith({int? topX, int? topY, int? bottomX, int? bottomY}) {
    return ScreenPosition(
        topX: topX ?? this.topX,
        topY: topY ?? this.topY,
        bottomX: bottomX ?? this.bottomX,
        bottomY: bottomY ?? this.bottomY);
  }

  ScreenPosition copyWithWrapped(
      {Wrapped<int>? topX,
      Wrapped<int>? topY,
      Wrapped<int?>? bottomX,
      Wrapped<int?>? bottomY}) {
    return ScreenPosition(
        topX: (topX != null ? topX.value : this.topX),
        topY: (topY != null ? topY.value : this.topY),
        bottomX: (bottomX != null ? bottomX.value : this.bottomX),
        bottomY: (bottomY != null ? bottomY.value : this.bottomY));
  }
}

@JsonSerializable(explicitToJson: true)
class Attribute {
  const Attribute({
    required this.name,
    this.description,
    this.label,
    required this.attributeType,
    required this.$value,
    this.editable,
    this.validator,
    this.allowedValues,
    this.allowedNumbers,
    this.allowedDecimals,
    this.minNumber,
    this.maxNumber,
    this.minDecimal,
    this.maxDecimal,
  });

  factory Attribute.fromJson(Map<String, dynamic> json) =>
      _$AttributeFromJson(json);

  static const toJsonFactory = _$AttributeToJson;
  Map<String, dynamic> toJson() => _$AttributeToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'label', includeIfNull: false, defaultValue: '')
  final String? label;
  @JsonKey(
    name: 'attributeType',
    includeIfNull: false,
    toJson: attributeAttributeTypeToJson,
    fromJson: attributeAttributeTypeFromJson,
  )
  final enums.AttributeAttributeType attributeType;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String $value;
  @JsonKey(name: 'editable', includeIfNull: false, defaultValue: true)
  final bool? editable;
  @JsonKey(
    name: 'validator',
    includeIfNull: false,
    toJson: attributeValidatorNullableToJson,
    fromJson: attributeValidatorNullableFromJson,
  )
  final enums.AttributeValidator? validator;
  @JsonKey(
      name: 'allowedValues', includeIfNull: false, defaultValue: <String>[])
  final List<String>? allowedValues;
  @JsonKey(name: 'allowedNumbers', includeIfNull: false, defaultValue: <int>[])
  final List<int>? allowedNumbers;
  @JsonKey(
      name: 'allowedDecimals', includeIfNull: false, defaultValue: <double>[])
  final List<double>? allowedDecimals;
  @JsonKey(name: 'minNumber', includeIfNull: false)
  final int? minNumber;
  @JsonKey(name: 'maxNumber', includeIfNull: false)
  final int? maxNumber;
  @JsonKey(name: 'minDecimal', includeIfNull: false)
  final double? minDecimal;
  @JsonKey(name: 'maxDecimal', includeIfNull: false)
  final double? maxDecimal;
  static const fromJsonFactory = _$AttributeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Attribute &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.attributeType, attributeType) ||
                const DeepCollectionEquality()
                    .equals(other.attributeType, attributeType)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.editable, editable) ||
                const DeepCollectionEquality()
                    .equals(other.editable, editable)) &&
            (identical(other.validator, validator) ||
                const DeepCollectionEquality()
                    .equals(other.validator, validator)) &&
            (identical(other.allowedValues, allowedValues) ||
                const DeepCollectionEquality()
                    .equals(other.allowedValues, allowedValues)) &&
            (identical(other.allowedNumbers, allowedNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.allowedNumbers, allowedNumbers)) &&
            (identical(other.allowedDecimals, allowedDecimals) ||
                const DeepCollectionEquality()
                    .equals(other.allowedDecimals, allowedDecimals)) &&
            (identical(other.minNumber, minNumber) ||
                const DeepCollectionEquality()
                    .equals(other.minNumber, minNumber)) &&
            (identical(other.maxNumber, maxNumber) ||
                const DeepCollectionEquality()
                    .equals(other.maxNumber, maxNumber)) &&
            (identical(other.minDecimal, minDecimal) ||
                const DeepCollectionEquality()
                    .equals(other.minDecimal, minDecimal)) &&
            (identical(other.maxDecimal, maxDecimal) ||
                const DeepCollectionEquality()
                    .equals(other.maxDecimal, maxDecimal)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(attributeType) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(editable) ^
      const DeepCollectionEquality().hash(validator) ^
      const DeepCollectionEquality().hash(allowedValues) ^
      const DeepCollectionEquality().hash(allowedNumbers) ^
      const DeepCollectionEquality().hash(allowedDecimals) ^
      const DeepCollectionEquality().hash(minNumber) ^
      const DeepCollectionEquality().hash(maxNumber) ^
      const DeepCollectionEquality().hash(minDecimal) ^
      const DeepCollectionEquality().hash(maxDecimal) ^
      runtimeType.hashCode;
}

extension $AttributeExtension on Attribute {
  Attribute copyWith(
      {String? name,
      String? description,
      String? label,
      enums.AttributeAttributeType? attributeType,
      String? $value,
      bool? editable,
      enums.AttributeValidator? validator,
      List<String>? allowedValues,
      List<int>? allowedNumbers,
      List<double>? allowedDecimals,
      int? minNumber,
      int? maxNumber,
      double? minDecimal,
      double? maxDecimal}) {
    return Attribute(
        name: name ?? this.name,
        description: description ?? this.description,
        label: label ?? this.label,
        attributeType: attributeType ?? this.attributeType,
        $value: $value ?? this.$value,
        editable: editable ?? this.editable,
        validator: validator ?? this.validator,
        allowedValues: allowedValues ?? this.allowedValues,
        allowedNumbers: allowedNumbers ?? this.allowedNumbers,
        allowedDecimals: allowedDecimals ?? this.allowedDecimals,
        minNumber: minNumber ?? this.minNumber,
        maxNumber: maxNumber ?? this.maxNumber,
        minDecimal: minDecimal ?? this.minDecimal,
        maxDecimal: maxDecimal ?? this.maxDecimal);
  }

  Attribute copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? label,
      Wrapped<enums.AttributeAttributeType>? attributeType,
      Wrapped<String>? $value,
      Wrapped<bool?>? editable,
      Wrapped<enums.AttributeValidator?>? validator,
      Wrapped<List<String>?>? allowedValues,
      Wrapped<List<int>?>? allowedNumbers,
      Wrapped<List<double>?>? allowedDecimals,
      Wrapped<int?>? minNumber,
      Wrapped<int?>? maxNumber,
      Wrapped<double?>? minDecimal,
      Wrapped<double?>? maxDecimal}) {
    return Attribute(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        label: (label != null ? label.value : this.label),
        attributeType:
            (attributeType != null ? attributeType.value : this.attributeType),
        $value: ($value != null ? $value.value : this.$value),
        editable: (editable != null ? editable.value : this.editable),
        validator: (validator != null ? validator.value : this.validator),
        allowedValues:
            (allowedValues != null ? allowedValues.value : this.allowedValues),
        allowedNumbers: (allowedNumbers != null
            ? allowedNumbers.value
            : this.allowedNumbers),
        allowedDecimals: (allowedDecimals != null
            ? allowedDecimals.value
            : this.allowedDecimals),
        minNumber: (minNumber != null ? minNumber.value : this.minNumber),
        maxNumber: (maxNumber != null ? maxNumber.value : this.maxNumber),
        minDecimal: (minDecimal != null ? minDecimal.value : this.minDecimal),
        maxDecimal: (maxDecimal != null ? maxDecimal.value : this.maxDecimal));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableInfo {
  const ScrappingTableInfo({
    required this.name,
    this.description,
    this.tags,
    required this.attributes,
  });

  factory ScrappingTableInfo.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableInfoFromJson(json);

  static const toJsonFactory = _$ScrappingTableInfoToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
      name: 'attributes', includeIfNull: false, defaultValue: <Attribute>[])
  final List<Attribute> attributes;
  static const fromJsonFactory = _$ScrappingTableInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality()
                    .equals(other.attributes, attributes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $ScrappingTableInfoExtension on ScrappingTableInfo {
  ScrappingTableInfo copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      List<Attribute>? attributes}) {
    return ScrappingTableInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        attributes: attributes ?? this.attributes);
  }

  ScrappingTableInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<List<Attribute>>? attributes}) {
    return ScrappingTableInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        attributes: (attributes != null ? attributes.value : this.attributes));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTable {
  const ScrappingTable({
    required this.name,
    this.description,
    this.tags,
    required this.attributes,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory ScrappingTable.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableFromJson(json);

  static const toJsonFactory = _$ScrappingTableToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
      name: 'attributes', includeIfNull: false, defaultValue: <Attribute>[])
  final List<Attribute> attributes;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$ScrappingTableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTable &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality()
                    .equals(other.attributes, attributes)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(attributes) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $ScrappingTableExtension on ScrappingTable {
  ScrappingTable copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      List<Attribute>? attributes,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return ScrappingTable(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        attributes: attributes ?? this.attributes,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  ScrappingTable copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<List<Attribute>>? attributes,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return ScrappingTable(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        attributes: (attributes != null ? attributes.value : this.attributes),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableEntity {
  const ScrappingTableEntity({
    this.entity,
  });

  factory ScrappingTableEntity.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableEntityFromJson(json);

  static const toJsonFactory = _$ScrappingTableEntityToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ScrappingTable? entity;
  static const fromJsonFactory = _$ScrappingTableEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ScrappingTableEntityExtension on ScrappingTableEntity {
  ScrappingTableEntity copyWith({ScrappingTable? entity}) {
    return ScrappingTableEntity(entity: entity ?? this.entity);
  }

  ScrappingTableEntity copyWithWrapped({Wrapped<ScrappingTable?>? entity}) {
    return ScrappingTableEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableEntityRes {
  const ScrappingTableEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ScrappingTableEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableEntityResFromJson(json);

  static const toJsonFactory = _$ScrappingTableEntityResToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final ScrappingTable? entity;
  static const fromJsonFactory = _$ScrappingTableEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ScrappingTableEntityResExtension on ScrappingTableEntityRes {
  ScrappingTableEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      ScrappingTable? entity}) {
    return ScrappingTableEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  ScrappingTableEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<ScrappingTable?>? entity}) {
    return ScrappingTableEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableArray {
  const ScrappingTableArray({
    this.values,
  });

  factory ScrappingTableArray.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableArrayFromJson(json);

  static const toJsonFactory = _$ScrappingTableArrayToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableArrayToJson(this);

  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <ScrappingTable>[])
  final List<ScrappingTable>? values;
  static const fromJsonFactory = _$ScrappingTableArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ScrappingTableArrayExtension on ScrappingTableArray {
  ScrappingTableArray copyWith({List<ScrappingTable>? values}) {
    return ScrappingTableArray(values: values ?? this.values);
  }

  ScrappingTableArray copyWithWrapped(
      {Wrapped<List<ScrappingTable>?>? values}) {
    return ScrappingTableArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrappingTableArrayRes {
  const ScrappingTableArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ScrappingTableArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ScrappingTableArrayResFromJson(json);

  static const toJsonFactory = _$ScrappingTableArrayResToJson;
  Map<String, dynamic> toJson() => _$ScrappingTableArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(
      name: 'values', includeIfNull: false, defaultValue: <ScrappingTable>[])
  final List<ScrappingTable>? values;
  static const fromJsonFactory = _$ScrappingTableArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrappingTableArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ScrappingTableArrayResExtension on ScrappingTableArrayRes {
  ScrappingTableArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<ScrappingTable>? values}) {
    return ScrappingTableArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  ScrappingTableArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<ScrappingTable>?>? values}) {
    return ScrappingTableArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class Tags {
  const Tags({
    this.values,
  });

  factory Tags.fromJson(Map<String, dynamic> json) => _$TagsFromJson(json);

  static const toJsonFactory = _$TagsToJson;
  Map<String, dynamic> toJson() => _$TagsToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  static const fromJsonFactory = _$TagsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Tags &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $TagsExtension on Tags {
  Tags copyWith({List<String>? values}) {
    return Tags(values: values ?? this.values);
  }

  Tags copyWithWrapped({Wrapped<List<String>?>? values}) {
    return Tags(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorStats {
  const FloorStats({
    this.assets,
    this.devices,
  });

  factory FloorStats.fromJson(Map<String, dynamic> json) =>
      _$FloorStatsFromJson(json);

  static const toJsonFactory = _$FloorStatsToJson;
  Map<String, dynamic> toJson() => _$FloorStatsToJson(this);

  @JsonKey(name: 'assets', includeIfNull: false)
  final int? assets;
  @JsonKey(name: 'devices', includeIfNull: false)
  final int? devices;
  static const fromJsonFactory = _$FloorStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorStats &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality().equals(other.devices, devices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(devices) ^
      runtimeType.hashCode;
}

extension $FloorStatsExtension on FloorStats {
  FloorStats copyWith({int? assets, int? devices}) {
    return FloorStats(
        assets: assets ?? this.assets, devices: devices ?? this.devices);
  }

  FloorStats copyWithWrapped({Wrapped<int?>? assets, Wrapped<int?>? devices}) {
    return FloorStats(
        assets: (assets != null ? assets.value : this.assets),
        devices: (devices != null ? devices.value : this.devices));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorStatsEntity {
  const FloorStatsEntity({
    this.entity,
  });

  factory FloorStatsEntity.fromJson(Map<String, dynamic> json) =>
      _$FloorStatsEntityFromJson(json);

  static const toJsonFactory = _$FloorStatsEntityToJson;
  Map<String, dynamic> toJson() => _$FloorStatsEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final FloorStats? entity;
  static const fromJsonFactory = _$FloorStatsEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorStatsEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FloorStatsEntityExtension on FloorStatsEntity {
  FloorStatsEntity copyWith({FloorStats? entity}) {
    return FloorStatsEntity(entity: entity ?? this.entity);
  }

  FloorStatsEntity copyWithWrapped({Wrapped<FloorStats?>? entity}) {
    return FloorStatsEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FloorStatsEntityRes {
  const FloorStatsEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory FloorStatsEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FloorStatsEntityResFromJson(json);

  static const toJsonFactory = _$FloorStatsEntityResToJson;
  Map<String, dynamic> toJson() => _$FloorStatsEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final FloorStats? entity;
  static const fromJsonFactory = _$FloorStatsEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FloorStatsEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $FloorStatsEntityResExtension on FloorStatsEntityRes {
  FloorStatsEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      FloorStats? entity}) {
    return FloorStatsEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  FloorStatsEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<FloorStats?>? entity}) {
    return FloorStatsEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityStats {
  const FacilityStats({
    this.floors,
    this.assets,
    this.devices,
  });

  factory FacilityStats.fromJson(Map<String, dynamic> json) =>
      _$FacilityStatsFromJson(json);

  static const toJsonFactory = _$FacilityStatsToJson;
  Map<String, dynamic> toJson() => _$FacilityStatsToJson(this);

  @JsonKey(name: 'floors', includeIfNull: false)
  final int? floors;
  @JsonKey(name: 'assets', includeIfNull: false)
  final int? assets;
  @JsonKey(name: 'devices', includeIfNull: false)
  final int? devices;
  static const fromJsonFactory = _$FacilityStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityStats &&
            (identical(other.floors, floors) ||
                const DeepCollectionEquality().equals(other.floors, floors)) &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality().equals(other.devices, devices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(floors) ^
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(devices) ^
      runtimeType.hashCode;
}

extension $FacilityStatsExtension on FacilityStats {
  FacilityStats copyWith({int? floors, int? assets, int? devices}) {
    return FacilityStats(
        floors: floors ?? this.floors,
        assets: assets ?? this.assets,
        devices: devices ?? this.devices);
  }

  FacilityStats copyWithWrapped(
      {Wrapped<int?>? floors, Wrapped<int?>? assets, Wrapped<int?>? devices}) {
    return FacilityStats(
        floors: (floors != null ? floors.value : this.floors),
        assets: (assets != null ? assets.value : this.assets),
        devices: (devices != null ? devices.value : this.devices));
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityStatsEntity {
  const FacilityStatsEntity({
    this.entity,
  });

  factory FacilityStatsEntity.fromJson(Map<String, dynamic> json) =>
      _$FacilityStatsEntityFromJson(json);

  static const toJsonFactory = _$FacilityStatsEntityToJson;
  Map<String, dynamic> toJson() => _$FacilityStatsEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final FacilityStats? entity;
  static const fromJsonFactory = _$FacilityStatsEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityStatsEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FacilityStatsEntityExtension on FacilityStatsEntity {
  FacilityStatsEntity copyWith({FacilityStats? entity}) {
    return FacilityStatsEntity(entity: entity ?? this.entity);
  }

  FacilityStatsEntity copyWithWrapped({Wrapped<FacilityStats?>? entity}) {
    return FacilityStatsEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FacilityStatsEntityRes {
  const FacilityStatsEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory FacilityStatsEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FacilityStatsEntityResFromJson(json);

  static const toJsonFactory = _$FacilityStatsEntityResToJson;
  Map<String, dynamic> toJson() => _$FacilityStatsEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final FacilityStats? entity;
  static const fromJsonFactory = _$FacilityStatsEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FacilityStatsEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $FacilityStatsEntityResExtension on FacilityStatsEntityRes {
  FacilityStatsEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      FacilityStats? entity}) {
    return FacilityStatsEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  FacilityStatsEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<FacilityStats?>? entity}) {
    return FacilityStatsEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseStats {
  const PremiseStats({
    this.facilities,
    this.floors,
    this.assets,
    this.devices,
  });

  factory PremiseStats.fromJson(Map<String, dynamic> json) =>
      _$PremiseStatsFromJson(json);

  static const toJsonFactory = _$PremiseStatsToJson;
  Map<String, dynamic> toJson() => _$PremiseStatsToJson(this);

  @JsonKey(name: 'facilities', includeIfNull: false)
  final int? facilities;
  @JsonKey(name: 'floors', includeIfNull: false)
  final int? floors;
  @JsonKey(name: 'assets', includeIfNull: false)
  final int? assets;
  @JsonKey(name: 'devices', includeIfNull: false)
  final int? devices;
  static const fromJsonFactory = _$PremiseStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseStats &&
            (identical(other.facilities, facilities) ||
                const DeepCollectionEquality()
                    .equals(other.facilities, facilities)) &&
            (identical(other.floors, floors) ||
                const DeepCollectionEquality().equals(other.floors, floors)) &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)) &&
            (identical(other.devices, devices) ||
                const DeepCollectionEquality().equals(other.devices, devices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(facilities) ^
      const DeepCollectionEquality().hash(floors) ^
      const DeepCollectionEquality().hash(assets) ^
      const DeepCollectionEquality().hash(devices) ^
      runtimeType.hashCode;
}

extension $PremiseStatsExtension on PremiseStats {
  PremiseStats copyWith(
      {int? facilities, int? floors, int? assets, int? devices}) {
    return PremiseStats(
        facilities: facilities ?? this.facilities,
        floors: floors ?? this.floors,
        assets: assets ?? this.assets,
        devices: devices ?? this.devices);
  }

  PremiseStats copyWithWrapped(
      {Wrapped<int?>? facilities,
      Wrapped<int?>? floors,
      Wrapped<int?>? assets,
      Wrapped<int?>? devices}) {
    return PremiseStats(
        facilities: (facilities != null ? facilities.value : this.facilities),
        floors: (floors != null ? floors.value : this.floors),
        assets: (assets != null ? assets.value : this.assets),
        devices: (devices != null ? devices.value : this.devices));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseStatsEntity {
  const PremiseStatsEntity({
    this.entity,
  });

  factory PremiseStatsEntity.fromJson(Map<String, dynamic> json) =>
      _$PremiseStatsEntityFromJson(json);

  static const toJsonFactory = _$PremiseStatsEntityToJson;
  Map<String, dynamic> toJson() => _$PremiseStatsEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final PremiseStats? entity;
  static const fromJsonFactory = _$PremiseStatsEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseStatsEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $PremiseStatsEntityExtension on PremiseStatsEntity {
  PremiseStatsEntity copyWith({PremiseStats? entity}) {
    return PremiseStatsEntity(entity: entity ?? this.entity);
  }

  PremiseStatsEntity copyWithWrapped({Wrapped<PremiseStats?>? entity}) {
    return PremiseStatsEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class PremiseStatsEntityRes {
  const PremiseStatsEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory PremiseStatsEntityRes.fromJson(Map<String, dynamic> json) =>
      _$PremiseStatsEntityResFromJson(json);

  static const toJsonFactory = _$PremiseStatsEntityResToJson;
  Map<String, dynamic> toJson() => _$PremiseStatsEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final PremiseStats? entity;
  static const fromJsonFactory = _$PremiseStatsEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PremiseStatsEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $PremiseStatsEntityResExtension on PremiseStatsEntityRes {
  PremiseStatsEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      PremiseStats? entity}) {
    return PremiseStatsEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  PremiseStatsEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<PremiseStats?>? entity}) {
    return PremiseStatsEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class TagsRes {
  const TagsRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.values,
  });

  factory TagsRes.fromJson(Map<String, dynamic> json) =>
      _$TagsResFromJson(json);

  static const toJsonFactory = _$TagsResToJson;
  Map<String, dynamic> toJson() => _$TagsResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  static const fromJsonFactory = _$TagsResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TagsRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TagsResExtension on TagsRes {
  TagsRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      List<String>? values}) {
    return TagsRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        values: values ?? this.values);
  }

  TagsRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<List<String>?>? values}) {
    return TagsRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class CustomWidget {
  const CustomWidget({
    required this.id,
    required this.attributes,
  });

  factory CustomWidget.fromJson(Map<String, dynamic> json) =>
      _$CustomWidgetFromJson(json);

  static const toJsonFactory = _$CustomWidgetToJson;
  Map<String, dynamic> toJson() => _$CustomWidgetToJson(this);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  static const fromJsonFactory = _$CustomWidgetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomWidget &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality()
                    .equals(other.attributes, attributes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $CustomWidgetExtension on CustomWidget {
  CustomWidget copyWith({String? id, Object? attributes}) {
    return CustomWidget(
        id: id ?? this.id, attributes: attributes ?? this.attributes);
  }

  CustomWidget copyWithWrapped(
      {Wrapped<String>? id, Wrapped<Object>? attributes}) {
    return CustomWidget(
        id: (id != null ? id.value : this.id),
        attributes: (attributes != null ? attributes.value : this.attributes));
  }
}

@JsonSerializable(explicitToJson: true)
class SensorWidget {
  const SensorWidget({
    required this.widgetId,
    required this.attributes,
  });

  factory SensorWidget.fromJson(Map<String, dynamic> json) =>
      _$SensorWidgetFromJson(json);

  static const toJsonFactory = _$SensorWidgetToJson;
  Map<String, dynamic> toJson() => _$SensorWidgetToJson(this);

  @JsonKey(name: 'widgetId', includeIfNull: false, defaultValue: '')
  final String widgetId;
  @JsonKey(name: 'attributes', includeIfNull: false)
  final Object attributes;
  static const fromJsonFactory = _$SensorWidgetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SensorWidget &&
            (identical(other.widgetId, widgetId) ||
                const DeepCollectionEquality()
                    .equals(other.widgetId, widgetId)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality()
                    .equals(other.attributes, attributes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(widgetId) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $SensorWidgetExtension on SensorWidget {
  SensorWidget copyWith({String? widgetId, Object? attributes}) {
    return SensorWidget(
        widgetId: widgetId ?? this.widgetId,
        attributes: attributes ?? this.attributes);
  }

  SensorWidget copyWithWrapped(
      {Wrapped<String>? widgetId, Wrapped<Object>? attributes}) {
    return SensorWidget(
        widgetId: (widgetId != null ? widgetId.value : this.widgetId),
        attributes: (attributes != null ? attributes.value : this.attributes));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupInfo {
  const AssetGroupInfo({
    required this.name,
    this.description,
    this.tags,
    required this.target,
    required this.assetIds,
    this.icon,
  });

  factory AssetGroupInfo.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupInfoFromJson(json);

  static const toJsonFactory = _$AssetGroupInfoToJson;
  Map<String, dynamic> toJson() => _$AssetGroupInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: assetGroupInfoTargetToJson,
    fromJson: assetGroupInfoTargetFromJson,
  )
  final enums.AssetGroupInfoTarget target;
  @JsonKey(name: 'assetIds', includeIfNull: false, defaultValue: <String>[])
  final List<String> assetIds;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  static const fromJsonFactory = _$AssetGroupInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.assetIds, assetIds) ||
                const DeepCollectionEquality()
                    .equals(other.assetIds, assetIds)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(assetIds) ^
      const DeepCollectionEquality().hash(icon) ^
      runtimeType.hashCode;
}

extension $AssetGroupInfoExtension on AssetGroupInfo {
  AssetGroupInfo copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      enums.AssetGroupInfoTarget? target,
      List<String>? assetIds,
      String? icon}) {
    return AssetGroupInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        target: target ?? this.target,
        assetIds: assetIds ?? this.assetIds,
        icon: icon ?? this.icon);
  }

  AssetGroupInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<enums.AssetGroupInfoTarget>? target,
      Wrapped<List<String>>? assetIds,
      Wrapped<String?>? icon}) {
    return AssetGroupInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        target: (target != null ? target.value : this.target),
        assetIds: (assetIds != null ? assetIds.value : this.assetIds),
        icon: (icon != null ? icon.value : this.icon));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroup {
  const AssetGroup({
    required this.name,
    this.description,
    this.tags,
    required this.target,
    required this.assetIds,
    this.icon,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory AssetGroup.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupFromJson(json);

  static const toJsonFactory = _$AssetGroupToJson;
  Map<String, dynamic> toJson() => _$AssetGroupToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(
    name: 'target',
    includeIfNull: false,
    toJson: assetGroupTargetToJson,
    fromJson: assetGroupTargetFromJson,
  )
  final enums.AssetGroupTarget target;
  @JsonKey(name: 'assetIds', includeIfNull: false, defaultValue: <String>[])
  final List<String> assetIds;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$AssetGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroup &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.assetIds, assetIds) ||
                const DeepCollectionEquality()
                    .equals(other.assetIds, assetIds)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(assetIds) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $AssetGroupExtension on AssetGroup {
  AssetGroup copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      enums.AssetGroupTarget? target,
      List<String>? assetIds,
      String? icon,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return AssetGroup(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        target: target ?? this.target,
        assetIds: assetIds ?? this.assetIds,
        icon: icon ?? this.icon,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  AssetGroup copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<enums.AssetGroupTarget>? target,
      Wrapped<List<String>>? assetIds,
      Wrapped<String?>? icon,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return AssetGroup(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        target: (target != null ? target.value : this.target),
        assetIds: (assetIds != null ? assetIds.value : this.assetIds),
        icon: (icon != null ? icon.value : this.icon),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupEntity {
  const AssetGroupEntity({
    this.entity,
  });

  factory AssetGroupEntity.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupEntityFromJson(json);

  static const toJsonFactory = _$AssetGroupEntityToJson;
  Map<String, dynamic> toJson() => _$AssetGroupEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final AssetGroup? entity;
  static const fromJsonFactory = _$AssetGroupEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AssetGroupEntityExtension on AssetGroupEntity {
  AssetGroupEntity copyWith({AssetGroup? entity}) {
    return AssetGroupEntity(entity: entity ?? this.entity);
  }

  AssetGroupEntity copyWithWrapped({Wrapped<AssetGroup?>? entity}) {
    return AssetGroupEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupEntityRes {
  const AssetGroupEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AssetGroupEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupEntityResFromJson(json);

  static const toJsonFactory = _$AssetGroupEntityResToJson;
  Map<String, dynamic> toJson() => _$AssetGroupEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final AssetGroup? entity;
  static const fromJsonFactory = _$AssetGroupEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AssetGroupEntityResExtension on AssetGroupEntityRes {
  AssetGroupEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      AssetGroup? entity}) {
    return AssetGroupEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  AssetGroupEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<AssetGroup?>? entity}) {
    return AssetGroupEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupArray {
  const AssetGroupArray({
    this.values,
  });

  factory AssetGroupArray.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupArrayFromJson(json);

  static const toJsonFactory = _$AssetGroupArrayToJson;
  Map<String, dynamic> toJson() => _$AssetGroupArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <AssetGroup>[])
  final List<AssetGroup>? values;
  static const fromJsonFactory = _$AssetGroupArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AssetGroupArrayExtension on AssetGroupArray {
  AssetGroupArray copyWith({List<AssetGroup>? values}) {
    return AssetGroupArray(values: values ?? this.values);
  }

  AssetGroupArray copyWithWrapped({Wrapped<List<AssetGroup>?>? values}) {
    return AssetGroupArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetGroupArrayRes {
  const AssetGroupArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AssetGroupArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AssetGroupArrayResFromJson(json);

  static const toJsonFactory = _$AssetGroupArrayResToJson;
  Map<String, dynamic> toJson() => _$AssetGroupArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <AssetGroup>[])
  final List<AssetGroup>? values;
  static const fromJsonFactory = _$AssetGroupArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetGroupArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AssetGroupArrayResExtension on AssetGroupArrayRes {
  AssetGroupArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<AssetGroup>? values}) {
    return AssetGroupArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  AssetGroupArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<AssetGroup>?>? values}) {
    return AssetGroupArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportInfo {
  const ReportInfo({
    required this.modelId,
    required this.name,
    this.icon,
    this.description,
    this.tags,
    this.includePremise,
    this.includeFacility,
    this.includeFloor,
    this.includeAsset,
    this.includeDevice,
    this.humanDateFormat,
    this.dateFormat,
    this.tz,
    required this.fields,
  });

  factory ReportInfo.fromJson(Map<String, dynamic> json) =>
      _$ReportInfoFromJson(json);

  static const toJsonFactory = _$ReportInfoToJson;
  Map<String, dynamic> toJson() => _$ReportInfoToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'includePremise', includeIfNull: false)
  final bool? includePremise;
  @JsonKey(name: 'includeFacility', includeIfNull: false)
  final bool? includeFacility;
  @JsonKey(name: 'includeFloor', includeIfNull: false)
  final bool? includeFloor;
  @JsonKey(name: 'includeAsset', includeIfNull: false)
  final bool? includeAsset;
  @JsonKey(name: 'includeDevice', includeIfNull: false)
  final bool? includeDevice;
  @JsonKey(name: 'humanDateFormat', includeIfNull: false)
  final bool? humanDateFormat;
  @JsonKey(name: 'dateFormat', includeIfNull: false, defaultValue: '')
  final String? dateFormat;
  @JsonKey(name: 'tz', includeIfNull: false, defaultValue: '')
  final String? tz;
  @JsonKey(name: 'fields', includeIfNull: false, defaultValue: <String>[])
  final List<String> fields;
  static const fromJsonFactory = _$ReportInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportInfo &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.includePremise, includePremise) ||
                const DeepCollectionEquality()
                    .equals(other.includePremise, includePremise)) &&
            (identical(other.includeFacility, includeFacility) ||
                const DeepCollectionEquality()
                    .equals(other.includeFacility, includeFacility)) &&
            (identical(other.includeFloor, includeFloor) ||
                const DeepCollectionEquality()
                    .equals(other.includeFloor, includeFloor)) &&
            (identical(other.includeAsset, includeAsset) ||
                const DeepCollectionEquality()
                    .equals(other.includeAsset, includeAsset)) &&
            (identical(other.includeDevice, includeDevice) ||
                const DeepCollectionEquality()
                    .equals(other.includeDevice, includeDevice)) &&
            (identical(other.humanDateFormat, humanDateFormat) ||
                const DeepCollectionEquality()
                    .equals(other.humanDateFormat, humanDateFormat)) &&
            (identical(other.dateFormat, dateFormat) ||
                const DeepCollectionEquality()
                    .equals(other.dateFormat, dateFormat)) &&
            (identical(other.tz, tz) ||
                const DeepCollectionEquality().equals(other.tz, tz)) &&
            (identical(other.fields, fields) ||
                const DeepCollectionEquality().equals(other.fields, fields)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(includePremise) ^
      const DeepCollectionEquality().hash(includeFacility) ^
      const DeepCollectionEquality().hash(includeFloor) ^
      const DeepCollectionEquality().hash(includeAsset) ^
      const DeepCollectionEquality().hash(includeDevice) ^
      const DeepCollectionEquality().hash(humanDateFormat) ^
      const DeepCollectionEquality().hash(dateFormat) ^
      const DeepCollectionEquality().hash(tz) ^
      const DeepCollectionEquality().hash(fields) ^
      runtimeType.hashCode;
}

extension $ReportInfoExtension on ReportInfo {
  ReportInfo copyWith(
      {String? modelId,
      String? name,
      String? icon,
      String? description,
      List<String>? tags,
      bool? includePremise,
      bool? includeFacility,
      bool? includeFloor,
      bool? includeAsset,
      bool? includeDevice,
      bool? humanDateFormat,
      String? dateFormat,
      String? tz,
      List<String>? fields}) {
    return ReportInfo(
        modelId: modelId ?? this.modelId,
        name: name ?? this.name,
        icon: icon ?? this.icon,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        includePremise: includePremise ?? this.includePremise,
        includeFacility: includeFacility ?? this.includeFacility,
        includeFloor: includeFloor ?? this.includeFloor,
        includeAsset: includeAsset ?? this.includeAsset,
        includeDevice: includeDevice ?? this.includeDevice,
        humanDateFormat: humanDateFormat ?? this.humanDateFormat,
        dateFormat: dateFormat ?? this.dateFormat,
        tz: tz ?? this.tz,
        fields: fields ?? this.fields);
  }

  ReportInfo copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<String>? name,
      Wrapped<String?>? icon,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<bool?>? includePremise,
      Wrapped<bool?>? includeFacility,
      Wrapped<bool?>? includeFloor,
      Wrapped<bool?>? includeAsset,
      Wrapped<bool?>? includeDevice,
      Wrapped<bool?>? humanDateFormat,
      Wrapped<String?>? dateFormat,
      Wrapped<String?>? tz,
      Wrapped<List<String>>? fields}) {
    return ReportInfo(
        modelId: (modelId != null ? modelId.value : this.modelId),
        name: (name != null ? name.value : this.name),
        icon: (icon != null ? icon.value : this.icon),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        includePremise: (includePremise != null
            ? includePremise.value
            : this.includePremise),
        includeFacility: (includeFacility != null
            ? includeFacility.value
            : this.includeFacility),
        includeFloor:
            (includeFloor != null ? includeFloor.value : this.includeFloor),
        includeAsset:
            (includeAsset != null ? includeAsset.value : this.includeAsset),
        includeDevice:
            (includeDevice != null ? includeDevice.value : this.includeDevice),
        humanDateFormat: (humanDateFormat != null
            ? humanDateFormat.value
            : this.humanDateFormat),
        dateFormat: (dateFormat != null ? dateFormat.value : this.dateFormat),
        tz: (tz != null ? tz.value : this.tz),
        fields: (fields != null ? fields.value : this.fields));
  }
}

@JsonSerializable(explicitToJson: true)
class Report {
  const Report({
    required this.modelId,
    required this.name,
    this.icon,
    this.description,
    this.tags,
    this.includePremise,
    this.includeFacility,
    this.includeFloor,
    this.includeAsset,
    this.includeDevice,
    this.humanDateFormat,
    this.dateFormat,
    this.tz,
    required this.fields,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Report.fromJson(Map<String, dynamic> json) => _$ReportFromJson(json);

  static const toJsonFactory = _$ReportToJson;
  Map<String, dynamic> toJson() => _$ReportToJson(this);

  @JsonKey(name: 'modelId', includeIfNull: false, defaultValue: '')
  final String modelId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'includePremise', includeIfNull: false)
  final bool? includePremise;
  @JsonKey(name: 'includeFacility', includeIfNull: false)
  final bool? includeFacility;
  @JsonKey(name: 'includeFloor', includeIfNull: false)
  final bool? includeFloor;
  @JsonKey(name: 'includeAsset', includeIfNull: false)
  final bool? includeAsset;
  @JsonKey(name: 'includeDevice', includeIfNull: false)
  final bool? includeDevice;
  @JsonKey(name: 'humanDateFormat', includeIfNull: false)
  final bool? humanDateFormat;
  @JsonKey(name: 'dateFormat', includeIfNull: false, defaultValue: '')
  final String? dateFormat;
  @JsonKey(name: 'tz', includeIfNull: false, defaultValue: '')
  final String? tz;
  @JsonKey(name: 'fields', includeIfNull: false, defaultValue: <String>[])
  final List<String> fields;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$ReportFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Report &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.includePremise, includePremise) ||
                const DeepCollectionEquality()
                    .equals(other.includePremise, includePremise)) &&
            (identical(other.includeFacility, includeFacility) ||
                const DeepCollectionEquality()
                    .equals(other.includeFacility, includeFacility)) &&
            (identical(other.includeFloor, includeFloor) ||
                const DeepCollectionEquality()
                    .equals(other.includeFloor, includeFloor)) &&
            (identical(other.includeAsset, includeAsset) ||
                const DeepCollectionEquality()
                    .equals(other.includeAsset, includeAsset)) &&
            (identical(other.includeDevice, includeDevice) ||
                const DeepCollectionEquality()
                    .equals(other.includeDevice, includeDevice)) &&
            (identical(other.humanDateFormat, humanDateFormat) ||
                const DeepCollectionEquality()
                    .equals(other.humanDateFormat, humanDateFormat)) &&
            (identical(other.dateFormat, dateFormat) ||
                const DeepCollectionEquality()
                    .equals(other.dateFormat, dateFormat)) &&
            (identical(other.tz, tz) ||
                const DeepCollectionEquality().equals(other.tz, tz)) &&
            (identical(other.fields, fields) ||
                const DeepCollectionEquality().equals(other.fields, fields)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(includePremise) ^
      const DeepCollectionEquality().hash(includeFacility) ^
      const DeepCollectionEquality().hash(includeFloor) ^
      const DeepCollectionEquality().hash(includeAsset) ^
      const DeepCollectionEquality().hash(includeDevice) ^
      const DeepCollectionEquality().hash(humanDateFormat) ^
      const DeepCollectionEquality().hash(dateFormat) ^
      const DeepCollectionEquality().hash(tz) ^
      const DeepCollectionEquality().hash(fields) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $ReportExtension on Report {
  Report copyWith(
      {String? modelId,
      String? name,
      String? icon,
      String? description,
      List<String>? tags,
      bool? includePremise,
      bool? includeFacility,
      bool? includeFloor,
      bool? includeAsset,
      bool? includeDevice,
      bool? humanDateFormat,
      String? dateFormat,
      String? tz,
      List<String>? fields,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Report(
        modelId: modelId ?? this.modelId,
        name: name ?? this.name,
        icon: icon ?? this.icon,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        includePremise: includePremise ?? this.includePremise,
        includeFacility: includeFacility ?? this.includeFacility,
        includeFloor: includeFloor ?? this.includeFloor,
        includeAsset: includeAsset ?? this.includeAsset,
        includeDevice: includeDevice ?? this.includeDevice,
        humanDateFormat: humanDateFormat ?? this.humanDateFormat,
        dateFormat: dateFormat ?? this.dateFormat,
        tz: tz ?? this.tz,
        fields: fields ?? this.fields,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Report copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<String>? name,
      Wrapped<String?>? icon,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<bool?>? includePremise,
      Wrapped<bool?>? includeFacility,
      Wrapped<bool?>? includeFloor,
      Wrapped<bool?>? includeAsset,
      Wrapped<bool?>? includeDevice,
      Wrapped<bool?>? humanDateFormat,
      Wrapped<String?>? dateFormat,
      Wrapped<String?>? tz,
      Wrapped<List<String>>? fields,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Report(
        modelId: (modelId != null ? modelId.value : this.modelId),
        name: (name != null ? name.value : this.name),
        icon: (icon != null ? icon.value : this.icon),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        includePremise: (includePremise != null
            ? includePremise.value
            : this.includePremise),
        includeFacility: (includeFacility != null
            ? includeFacility.value
            : this.includeFacility),
        includeFloor:
            (includeFloor != null ? includeFloor.value : this.includeFloor),
        includeAsset:
            (includeAsset != null ? includeAsset.value : this.includeAsset),
        includeDevice:
            (includeDevice != null ? includeDevice.value : this.includeDevice),
        humanDateFormat: (humanDateFormat != null
            ? humanDateFormat.value
            : this.humanDateFormat),
        dateFormat: (dateFormat != null ? dateFormat.value : this.dateFormat),
        tz: (tz != null ? tz.value : this.tz),
        fields: (fields != null ? fields.value : this.fields),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportEntity {
  const ReportEntity({
    this.entity,
  });

  factory ReportEntity.fromJson(Map<String, dynamic> json) =>
      _$ReportEntityFromJson(json);

  static const toJsonFactory = _$ReportEntityToJson;
  Map<String, dynamic> toJson() => _$ReportEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Report? entity;
  static const fromJsonFactory = _$ReportEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ReportEntityExtension on ReportEntity {
  ReportEntity copyWith({Report? entity}) {
    return ReportEntity(entity: entity ?? this.entity);
  }

  ReportEntity copyWithWrapped({Wrapped<Report?>? entity}) {
    return ReportEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportEntityRes {
  const ReportEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ReportEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ReportEntityResFromJson(json);

  static const toJsonFactory = _$ReportEntityResToJson;
  Map<String, dynamic> toJson() => _$ReportEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Report? entity;
  static const fromJsonFactory = _$ReportEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ReportEntityResExtension on ReportEntityRes {
  ReportEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Report? entity}) {
    return ReportEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  ReportEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Report?>? entity}) {
    return ReportEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportArray {
  const ReportArray({
    this.values,
  });

  factory ReportArray.fromJson(Map<String, dynamic> json) =>
      _$ReportArrayFromJson(json);

  static const toJsonFactory = _$ReportArrayToJson;
  Map<String, dynamic> toJson() => _$ReportArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Report>[])
  final List<Report>? values;
  static const fromJsonFactory = _$ReportArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ReportArrayExtension on ReportArray {
  ReportArray copyWith({List<Report>? values}) {
    return ReportArray(values: values ?? this.values);
  }

  ReportArray copyWithWrapped({Wrapped<List<Report>?>? values}) {
    return ReportArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportArrayRes {
  const ReportArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ReportArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ReportArrayResFromJson(json);

  static const toJsonFactory = _$ReportArrayResToJson;
  Map<String, dynamic> toJson() => _$ReportArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Report>[])
  final List<Report>? values;
  static const fromJsonFactory = _$ReportArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ReportArrayResExtension on ReportArrayRes {
  ReportArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Report>? values}) {
    return ReportArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  ReportArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Report>?>? values}) {
    return ReportArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetScrappingTable {
  const AssetScrappingTable({
    required this.lookupName,
    required this.scrappingTableId,
    required this.scrappingTableName,
    required this.attributes,
  });

  factory AssetScrappingTable.fromJson(Map<String, dynamic> json) =>
      _$AssetScrappingTableFromJson(json);

  static const toJsonFactory = _$AssetScrappingTableToJson;
  Map<String, dynamic> toJson() => _$AssetScrappingTableToJson(this);

  @JsonKey(name: 'lookupName', includeIfNull: false, defaultValue: '')
  final String lookupName;
  @JsonKey(name: 'scrappingTableId', includeIfNull: false, defaultValue: '')
  final String scrappingTableId;
  @JsonKey(name: 'scrappingTableName', includeIfNull: false, defaultValue: '')
  final String scrappingTableName;
  @JsonKey(
      name: 'attributes', includeIfNull: false, defaultValue: <Attribute>[])
  final List<Attribute> attributes;
  static const fromJsonFactory = _$AssetScrappingTableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetScrappingTable &&
            (identical(other.lookupName, lookupName) ||
                const DeepCollectionEquality()
                    .equals(other.lookupName, lookupName)) &&
            (identical(other.scrappingTableId, scrappingTableId) ||
                const DeepCollectionEquality()
                    .equals(other.scrappingTableId, scrappingTableId)) &&
            (identical(other.scrappingTableName, scrappingTableName) ||
                const DeepCollectionEquality()
                    .equals(other.scrappingTableName, scrappingTableName)) &&
            (identical(other.attributes, attributes) ||
                const DeepCollectionEquality()
                    .equals(other.attributes, attributes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(lookupName) ^
      const DeepCollectionEquality().hash(scrappingTableId) ^
      const DeepCollectionEquality().hash(scrappingTableName) ^
      const DeepCollectionEquality().hash(attributes) ^
      runtimeType.hashCode;
}

extension $AssetScrappingTableExtension on AssetScrappingTable {
  AssetScrappingTable copyWith(
      {String? lookupName,
      String? scrappingTableId,
      String? scrappingTableName,
      List<Attribute>? attributes}) {
    return AssetScrappingTable(
        lookupName: lookupName ?? this.lookupName,
        scrappingTableId: scrappingTableId ?? this.scrappingTableId,
        scrappingTableName: scrappingTableName ?? this.scrappingTableName,
        attributes: attributes ?? this.attributes);
  }

  AssetScrappingTable copyWithWrapped(
      {Wrapped<String>? lookupName,
      Wrapped<String>? scrappingTableId,
      Wrapped<String>? scrappingTableName,
      Wrapped<List<Attribute>>? attributes}) {
    return AssetScrappingTable(
        lookupName: (lookupName != null ? lookupName.value : this.lookupName),
        scrappingTableId: (scrappingTableId != null
            ? scrappingTableId.value
            : this.scrappingTableId),
        scrappingTableName: (scrappingTableName != null
            ? scrappingTableName.value
            : this.scrappingTableName),
        attributes: (attributes != null ? attributes.value : this.attributes));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetDeviceModel {
  const AssetDeviceModel({
    required this.deviceModelId,
    this.scrappingTables,
  });

  factory AssetDeviceModel.fromJson(Map<String, dynamic> json) =>
      _$AssetDeviceModelFromJson(json);

  static const toJsonFactory = _$AssetDeviceModelToJson;
  Map<String, dynamic> toJson() => _$AssetDeviceModelToJson(this);

  @JsonKey(name: 'deviceModelId', includeIfNull: false, defaultValue: '')
  final String deviceModelId;
  @JsonKey(
      name: 'scrappingTables',
      includeIfNull: false,
      defaultValue: <AssetScrappingTable>[])
  final List<AssetScrappingTable>? scrappingTables;
  static const fromJsonFactory = _$AssetDeviceModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetDeviceModel &&
            (identical(other.deviceModelId, deviceModelId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceModelId, deviceModelId)) &&
            (identical(other.scrappingTables, scrappingTables) ||
                const DeepCollectionEquality()
                    .equals(other.scrappingTables, scrappingTables)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deviceModelId) ^
      const DeepCollectionEquality().hash(scrappingTables) ^
      runtimeType.hashCode;
}

extension $AssetDeviceModelExtension on AssetDeviceModel {
  AssetDeviceModel copyWith(
      {String? deviceModelId, List<AssetScrappingTable>? scrappingTables}) {
    return AssetDeviceModel(
        deviceModelId: deviceModelId ?? this.deviceModelId,
        scrappingTables: scrappingTables ?? this.scrappingTables);
  }

  AssetDeviceModel copyWithWrapped(
      {Wrapped<String>? deviceModelId,
      Wrapped<List<AssetScrappingTable>?>? scrappingTables}) {
    return AssetDeviceModel(
        deviceModelId:
            (deviceModelId != null ? deviceModelId.value : this.deviceModelId),
        scrappingTables: (scrappingTables != null
            ? scrappingTables.value
            : this.scrappingTables));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelInfo {
  const AssetModelInfo({
    required this.name,
    this.description,
    this.tags,
    this.icon,
    this.selectedImage,
    this.selectedBanner,
    this.images,
    this.banners,
    this.metadata,
    this.movable,
    this.allowedDeviceModels,
  });

  factory AssetModelInfo.fromJson(Map<String, dynamic> json) =>
      _$AssetModelInfoFromJson(json);

  static const toJsonFactory = _$AssetModelInfoToJson;
  Map<String, dynamic> toJson() => _$AssetModelInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'selectedBanner', includeIfNull: false)
  final int? selectedBanner;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'banners', includeIfNull: false, defaultValue: <String>[])
  final List<String>? banners;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(
      name: 'allowedDeviceModels',
      includeIfNull: false,
      defaultValue: <AssetDeviceModel>[])
  final List<AssetDeviceModel>? allowedDeviceModels;
  static const fromJsonFactory = _$AssetModelInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.selectedBanner, selectedBanner) ||
                const DeepCollectionEquality()
                    .equals(other.selectedBanner, selectedBanner)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.banners, banners) ||
                const DeepCollectionEquality()
                    .equals(other.banners, banners)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality()
                    .equals(other.movable, movable)) &&
            (identical(other.allowedDeviceModels, allowedDeviceModels) ||
                const DeepCollectionEquality()
                    .equals(other.allowedDeviceModels, allowedDeviceModels)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(selectedBanner) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(banners) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(allowedDeviceModels) ^
      runtimeType.hashCode;
}

extension $AssetModelInfoExtension on AssetModelInfo {
  AssetModelInfo copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      String? icon,
      int? selectedImage,
      int? selectedBanner,
      List<String>? images,
      List<String>? banners,
      Object? metadata,
      bool? movable,
      List<AssetDeviceModel>? allowedDeviceModels}) {
    return AssetModelInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        icon: icon ?? this.icon,
        selectedImage: selectedImage ?? this.selectedImage,
        selectedBanner: selectedBanner ?? this.selectedBanner,
        images: images ?? this.images,
        banners: banners ?? this.banners,
        metadata: metadata ?? this.metadata,
        movable: movable ?? this.movable,
        allowedDeviceModels: allowedDeviceModels ?? this.allowedDeviceModels);
  }

  AssetModelInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? icon,
      Wrapped<int?>? selectedImage,
      Wrapped<int?>? selectedBanner,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? banners,
      Wrapped<Object?>? metadata,
      Wrapped<bool?>? movable,
      Wrapped<List<AssetDeviceModel>?>? allowedDeviceModels}) {
    return AssetModelInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        icon: (icon != null ? icon.value : this.icon),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        selectedBanner: (selectedBanner != null
            ? selectedBanner.value
            : this.selectedBanner),
        images: (images != null ? images.value : this.images),
        banners: (banners != null ? banners.value : this.banners),
        metadata: (metadata != null ? metadata.value : this.metadata),
        movable: (movable != null ? movable.value : this.movable),
        allowedDeviceModels: (allowedDeviceModels != null
            ? allowedDeviceModels.value
            : this.allowedDeviceModels));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModel {
  const AssetModel({
    required this.name,
    this.description,
    this.tags,
    this.icon,
    this.selectedImage,
    this.selectedBanner,
    this.images,
    this.banners,
    this.metadata,
    this.movable,
    this.allowedDeviceModels,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory AssetModel.fromJson(Map<String, dynamic> json) =>
      _$AssetModelFromJson(json);

  static const toJsonFactory = _$AssetModelToJson;
  Map<String, dynamic> toJson() => _$AssetModelToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'selectedImage', includeIfNull: false)
  final int? selectedImage;
  @JsonKey(name: 'selectedBanner', includeIfNull: false)
  final int? selectedBanner;
  @JsonKey(name: 'images', includeIfNull: false, defaultValue: <String>[])
  final List<String>? images;
  @JsonKey(name: 'banners', includeIfNull: false, defaultValue: <String>[])
  final List<String>? banners;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final Object? metadata;
  @JsonKey(name: 'movable', includeIfNull: false)
  final bool? movable;
  @JsonKey(
      name: 'allowedDeviceModels',
      includeIfNull: false,
      defaultValue: <AssetDeviceModel>[])
  final List<AssetDeviceModel>? allowedDeviceModels;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$AssetModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.selectedImage, selectedImage) ||
                const DeepCollectionEquality()
                    .equals(other.selectedImage, selectedImage)) &&
            (identical(other.selectedBanner, selectedBanner) ||
                const DeepCollectionEquality()
                    .equals(other.selectedBanner, selectedBanner)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.banners, banners) ||
                const DeepCollectionEquality()
                    .equals(other.banners, banners)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.movable, movable) ||
                const DeepCollectionEquality()
                    .equals(other.movable, movable)) &&
            (identical(other.allowedDeviceModels, allowedDeviceModels) ||
                const DeepCollectionEquality()
                    .equals(other.allowedDeviceModels, allowedDeviceModels)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(selectedImage) ^
      const DeepCollectionEquality().hash(selectedBanner) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(banners) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(movable) ^
      const DeepCollectionEquality().hash(allowedDeviceModels) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $AssetModelExtension on AssetModel {
  AssetModel copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      String? icon,
      int? selectedImage,
      int? selectedBanner,
      List<String>? images,
      List<String>? banners,
      Object? metadata,
      bool? movable,
      List<AssetDeviceModel>? allowedDeviceModels,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return AssetModel(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        icon: icon ?? this.icon,
        selectedImage: selectedImage ?? this.selectedImage,
        selectedBanner: selectedBanner ?? this.selectedBanner,
        images: images ?? this.images,
        banners: banners ?? this.banners,
        metadata: metadata ?? this.metadata,
        movable: movable ?? this.movable,
        allowedDeviceModels: allowedDeviceModels ?? this.allowedDeviceModels,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  AssetModel copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? icon,
      Wrapped<int?>? selectedImage,
      Wrapped<int?>? selectedBanner,
      Wrapped<List<String>?>? images,
      Wrapped<List<String>?>? banners,
      Wrapped<Object?>? metadata,
      Wrapped<bool?>? movable,
      Wrapped<List<AssetDeviceModel>?>? allowedDeviceModels,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return AssetModel(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        icon: (icon != null ? icon.value : this.icon),
        selectedImage:
            (selectedImage != null ? selectedImage.value : this.selectedImage),
        selectedBanner: (selectedBanner != null
            ? selectedBanner.value
            : this.selectedBanner),
        images: (images != null ? images.value : this.images),
        banners: (banners != null ? banners.value : this.banners),
        metadata: (metadata != null ? metadata.value : this.metadata),
        movable: (movable != null ? movable.value : this.movable),
        allowedDeviceModels: (allowedDeviceModels != null
            ? allowedDeviceModels.value
            : this.allowedDeviceModels),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelEntity {
  const AssetModelEntity({
    this.entity,
  });

  factory AssetModelEntity.fromJson(Map<String, dynamic> json) =>
      _$AssetModelEntityFromJson(json);

  static const toJsonFactory = _$AssetModelEntityToJson;
  Map<String, dynamic> toJson() => _$AssetModelEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final AssetModel? entity;
  static const fromJsonFactory = _$AssetModelEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $AssetModelEntityExtension on AssetModelEntity {
  AssetModelEntity copyWith({AssetModel? entity}) {
    return AssetModelEntity(entity: entity ?? this.entity);
  }

  AssetModelEntity copyWithWrapped({Wrapped<AssetModel?>? entity}) {
    return AssetModelEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelEntityRes {
  const AssetModelEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory AssetModelEntityRes.fromJson(Map<String, dynamic> json) =>
      _$AssetModelEntityResFromJson(json);

  static const toJsonFactory = _$AssetModelEntityResToJson;
  Map<String, dynamic> toJson() => _$AssetModelEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final AssetModel? entity;
  static const fromJsonFactory = _$AssetModelEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $AssetModelEntityResExtension on AssetModelEntityRes {
  AssetModelEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      AssetModel? entity}) {
    return AssetModelEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  AssetModelEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<AssetModel?>? entity}) {
    return AssetModelEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelArray {
  const AssetModelArray({
    this.values,
  });

  factory AssetModelArray.fromJson(Map<String, dynamic> json) =>
      _$AssetModelArrayFromJson(json);

  static const toJsonFactory = _$AssetModelArrayToJson;
  Map<String, dynamic> toJson() => _$AssetModelArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <AssetModel>[])
  final List<AssetModel>? values;
  static const fromJsonFactory = _$AssetModelArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $AssetModelArrayExtension on AssetModelArray {
  AssetModelArray copyWith({List<AssetModel>? values}) {
    return AssetModelArray(values: values ?? this.values);
  }

  AssetModelArray copyWithWrapped({Wrapped<List<AssetModel>?>? values}) {
    return AssetModelArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetModelArrayRes {
  const AssetModelArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory AssetModelArrayRes.fromJson(Map<String, dynamic> json) =>
      _$AssetModelArrayResFromJson(json);

  static const toJsonFactory = _$AssetModelArrayResToJson;
  Map<String, dynamic> toJson() => _$AssetModelArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <AssetModel>[])
  final List<AssetModel>? values;
  static const fromJsonFactory = _$AssetModelArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetModelArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $AssetModelArrayResExtension on AssetModelArrayRes {
  AssetModelArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<AssetModel>? values}) {
    return AssetModelArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  AssetModelArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<AssetModel>?>? values}) {
    return AssetModelArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class IDList {
  const IDList({
    required this.total,
    required this.values,
  });

  factory IDList.fromJson(Map<String, dynamic> json) => _$IDListFromJson(json);

  static const toJsonFactory = _$IDListToJson;
  Map<String, dynamic> toJson() => _$IDListToJson(this);

  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String> values;
  static const fromJsonFactory = _$IDListFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is IDList &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $IDListExtension on IDList {
  IDList copyWith({int? total, List<String>? values}) {
    return IDList(total: total ?? this.total, values: values ?? this.values);
  }

  IDList copyWithWrapped({Wrapped<int>? total, Wrapped<List<String>>? values}) {
    return IDList(
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class IDListEntityRes {
  const IDListEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.total,
    required this.values,
  });

  factory IDListEntityRes.fromJson(Map<String, dynamic> json) =>
      _$IDListEntityResFromJson(json);

  static const toJsonFactory = _$IDListEntityResToJson;
  Map<String, dynamic> toJson() => _$IDListEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String> values;
  static const fromJsonFactory = _$IDListEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is IDListEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $IDListEntityResExtension on IDListEntityRes {
  IDListEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? total,
      List<String>? values}) {
    return IDListEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  IDListEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? total,
      Wrapped<List<String>>? values}) {
    return IDListEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterInfo {
  const FieldFilterInfo({
    required this.name,
    this.description,
    this.icon,
    required this.field,
    required this.fieldType,
    required this.condition,
    this.$value,
    this.leftValue,
    this.rightValue,
    this.values,
    this.tags,
  });

  factory FieldFilterInfo.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterInfoFromJson(json);

  static const toJsonFactory = _$FieldFilterInfoToJson;
  Map<String, dynamic> toJson() => _$FieldFilterInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String field;
  @JsonKey(
    name: 'fieldType',
    includeIfNull: false,
    toJson: fieldFilterInfoFieldTypeToJson,
    fromJson: fieldFilterInfoFieldTypeFromJson,
  )
  final enums.FieldFilterInfoFieldType fieldType;
  @JsonKey(
    name: 'condition',
    includeIfNull: false,
    toJson: fieldFilterInfoConditionToJson,
    fromJson: fieldFilterInfoConditionFromJson,
  )
  final enums.FieldFilterInfoCondition condition;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'leftValue', includeIfNull: false, defaultValue: '')
  final String? leftValue;
  @JsonKey(name: 'rightValue', includeIfNull: false, defaultValue: '')
  final String? rightValue;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$FieldFilterInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.fieldType, fieldType) ||
                const DeepCollectionEquality()
                    .equals(other.fieldType, fieldType)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.leftValue, leftValue) ||
                const DeepCollectionEquality()
                    .equals(other.leftValue, leftValue)) &&
            (identical(other.rightValue, rightValue) ||
                const DeepCollectionEquality()
                    .equals(other.rightValue, rightValue)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(fieldType) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(leftValue) ^
      const DeepCollectionEquality().hash(rightValue) ^
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $FieldFilterInfoExtension on FieldFilterInfo {
  FieldFilterInfo copyWith(
      {String? name,
      String? description,
      String? icon,
      String? field,
      enums.FieldFilterInfoFieldType? fieldType,
      enums.FieldFilterInfoCondition? condition,
      String? $value,
      String? leftValue,
      String? rightValue,
      List<String>? values,
      List<String>? tags}) {
    return FieldFilterInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        icon: icon ?? this.icon,
        field: field ?? this.field,
        fieldType: fieldType ?? this.fieldType,
        condition: condition ?? this.condition,
        $value: $value ?? this.$value,
        leftValue: leftValue ?? this.leftValue,
        rightValue: rightValue ?? this.rightValue,
        values: values ?? this.values,
        tags: tags ?? this.tags);
  }

  FieldFilterInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? icon,
      Wrapped<String>? field,
      Wrapped<enums.FieldFilterInfoFieldType>? fieldType,
      Wrapped<enums.FieldFilterInfoCondition>? condition,
      Wrapped<String?>? $value,
      Wrapped<String?>? leftValue,
      Wrapped<String?>? rightValue,
      Wrapped<List<String>?>? values,
      Wrapped<List<String>?>? tags}) {
    return FieldFilterInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        icon: (icon != null ? icon.value : this.icon),
        field: (field != null ? field.value : this.field),
        fieldType: (fieldType != null ? fieldType.value : this.fieldType),
        condition: (condition != null ? condition.value : this.condition),
        $value: ($value != null ? $value.value : this.$value),
        leftValue: (leftValue != null ? leftValue.value : this.leftValue),
        rightValue: (rightValue != null ? rightValue.value : this.rightValue),
        values: (values != null ? values.value : this.values),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilter {
  const FieldFilter({
    required this.name,
    this.description,
    this.icon,
    required this.field,
    required this.fieldType,
    required this.condition,
    this.$value,
    this.leftValue,
    this.rightValue,
    this.values,
    this.tags,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory FieldFilter.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterFromJson(json);

  static const toJsonFactory = _$FieldFilterToJson;
  Map<String, dynamic> toJson() => _$FieldFilterToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'field', includeIfNull: false, defaultValue: '')
  final String field;
  @JsonKey(
    name: 'fieldType',
    includeIfNull: false,
    toJson: fieldFilterFieldTypeToJson,
    fromJson: fieldFilterFieldTypeFromJson,
  )
  final enums.FieldFilterFieldType fieldType;
  @JsonKey(
    name: 'condition',
    includeIfNull: false,
    toJson: fieldFilterConditionToJson,
    fromJson: fieldFilterConditionFromJson,
  )
  final enums.FieldFilterCondition condition;
  @JsonKey(name: 'value', includeIfNull: false, defaultValue: '')
  final String? $value;
  @JsonKey(name: 'leftValue', includeIfNull: false, defaultValue: '')
  final String? leftValue;
  @JsonKey(name: 'rightValue', includeIfNull: false, defaultValue: '')
  final String? rightValue;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <String>[])
  final List<String>? values;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$FieldFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilter &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.fieldType, fieldType) ||
                const DeepCollectionEquality()
                    .equals(other.fieldType, fieldType)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.leftValue, leftValue) ||
                const DeepCollectionEquality()
                    .equals(other.leftValue, leftValue)) &&
            (identical(other.rightValue, rightValue) ||
                const DeepCollectionEquality()
                    .equals(other.rightValue, rightValue)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(fieldType) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(leftValue) ^
      const DeepCollectionEquality().hash(rightValue) ^
      const DeepCollectionEquality().hash(values) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $FieldFilterExtension on FieldFilter {
  FieldFilter copyWith(
      {String? name,
      String? description,
      String? icon,
      String? field,
      enums.FieldFilterFieldType? fieldType,
      enums.FieldFilterCondition? condition,
      String? $value,
      String? leftValue,
      String? rightValue,
      List<String>? values,
      List<String>? tags,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return FieldFilter(
        name: name ?? this.name,
        description: description ?? this.description,
        icon: icon ?? this.icon,
        field: field ?? this.field,
        fieldType: fieldType ?? this.fieldType,
        condition: condition ?? this.condition,
        $value: $value ?? this.$value,
        leftValue: leftValue ?? this.leftValue,
        rightValue: rightValue ?? this.rightValue,
        values: values ?? this.values,
        tags: tags ?? this.tags,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  FieldFilter copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? icon,
      Wrapped<String>? field,
      Wrapped<enums.FieldFilterFieldType>? fieldType,
      Wrapped<enums.FieldFilterCondition>? condition,
      Wrapped<String?>? $value,
      Wrapped<String?>? leftValue,
      Wrapped<String?>? rightValue,
      Wrapped<List<String>?>? values,
      Wrapped<List<String>?>? tags,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return FieldFilter(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        icon: (icon != null ? icon.value : this.icon),
        field: (field != null ? field.value : this.field),
        fieldType: (fieldType != null ? fieldType.value : this.fieldType),
        condition: (condition != null ? condition.value : this.condition),
        $value: ($value != null ? $value.value : this.$value),
        leftValue: (leftValue != null ? leftValue.value : this.leftValue),
        rightValue: (rightValue != null ? rightValue.value : this.rightValue),
        values: (values != null ? values.value : this.values),
        tags: (tags != null ? tags.value : this.tags),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterEntity {
  const FieldFilterEntity({
    this.entity,
  });

  factory FieldFilterEntity.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterEntityFromJson(json);

  static const toJsonFactory = _$FieldFilterEntityToJson;
  Map<String, dynamic> toJson() => _$FieldFilterEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final FieldFilter? entity;
  static const fromJsonFactory = _$FieldFilterEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $FieldFilterEntityExtension on FieldFilterEntity {
  FieldFilterEntity copyWith({FieldFilter? entity}) {
    return FieldFilterEntity(entity: entity ?? this.entity);
  }

  FieldFilterEntity copyWithWrapped({Wrapped<FieldFilter?>? entity}) {
    return FieldFilterEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterEntityRes {
  const FieldFilterEntityRes({
    this.entity,
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory FieldFilterEntityRes.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterEntityResFromJson(json);

  static const toJsonFactory = _$FieldFilterEntityResToJson;
  Map<String, dynamic> toJson() => _$FieldFilterEntityResToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final FieldFilter? entity;
  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$FieldFilterEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterEntityRes &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)) &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $FieldFilterEntityResExtension on FieldFilterEntityRes {
  FieldFilterEntityRes copyWith(
      {FieldFilter? entity,
      bool? ok,
      String? msg,
      String? trace,
      String? errorCode}) {
    return FieldFilterEntityRes(
        entity: entity ?? this.entity,
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode);
  }

  FieldFilterEntityRes copyWithWrapped(
      {Wrapped<FieldFilter?>? entity,
      Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode}) {
    return FieldFilterEntityRes(
        entity: (entity != null ? entity.value : this.entity),
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode));
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterArray {
  const FieldFilterArray({
    this.values,
  });

  factory FieldFilterArray.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterArrayFromJson(json);

  static const toJsonFactory = _$FieldFilterArrayToJson;
  Map<String, dynamic> toJson() => _$FieldFilterArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <FieldFilter>[])
  final List<FieldFilter>? values;
  static const fromJsonFactory = _$FieldFilterArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $FieldFilterArrayExtension on FieldFilterArray {
  FieldFilterArray copyWith({List<FieldFilter>? values}) {
    return FieldFilterArray(values: values ?? this.values);
  }

  FieldFilterArray copyWithWrapped({Wrapped<List<FieldFilter>?>? values}) {
    return FieldFilterArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class FieldFilterArrayRes {
  const FieldFilterArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory FieldFilterArrayRes.fromJson(Map<String, dynamic> json) =>
      _$FieldFilterArrayResFromJson(json);

  static const toJsonFactory = _$FieldFilterArrayResToJson;
  Map<String, dynamic> toJson() => _$FieldFilterArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <FieldFilter>[])
  final List<FieldFilter>? values;
  static const fromJsonFactory = _$FieldFilterArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FieldFilterArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $FieldFilterArrayResExtension on FieldFilterArrayRes {
  FieldFilterArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<FieldFilter>? values}) {
    return FieldFilterArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  FieldFilterArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<FieldFilter>?>? values}) {
    return FieldFilterArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterArray {
  const ParameterArray({
    this.values,
  });

  factory ParameterArray.fromJson(Map<String, dynamic> json) =>
      _$ParameterArrayFromJson(json);

  static const toJsonFactory = _$ParameterArrayToJson;
  Map<String, dynamic> toJson() => _$ParameterArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Parameter>[])
  final List<Parameter>? values;
  static const fromJsonFactory = _$ParameterArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ParameterArrayExtension on ParameterArray {
  ParameterArray copyWith({List<Parameter>? values}) {
    return ParameterArray(values: values ?? this.values);
  }

  ParameterArray copyWithWrapped({Wrapped<List<Parameter>?>? values}) {
    return ParameterArray(
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterArrayRes {
  const ParameterArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ParameterArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ParameterArrayResFromJson(json);

  static const toJsonFactory = _$ParameterArrayResToJson;
  Map<String, dynamic> toJson() => _$ParameterArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Parameter>[])
  final List<Parameter>? values;
  static const fromJsonFactory = _$ParameterArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ParameterArrayResExtension on ParameterArrayRes {
  ParameterArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Parameter>? values}) {
    return ParameterArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  ParameterArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Parameter>?>? values}) {
    return ParameterArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientInfo {
  const ClientInfo({
    required this.name,
    this.description,
    this.tags,
    this.icon,
    this.email,
    this.phone,
    this.address,
  });

  factory ClientInfo.fromJson(Map<String, dynamic> json) =>
      _$ClientInfoFromJson(json);

  static const toJsonFactory = _$ClientInfoToJson;
  Map<String, dynamic> toJson() => _$ClientInfoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  static const fromJsonFactory = _$ClientInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $ClientInfoExtension on ClientInfo {
  ClientInfo copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      String? icon,
      String? email,
      String? phone,
      String? address}) {
    return ClientInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        icon: icon ?? this.icon,
        email: email ?? this.email,
        phone: phone ?? this.phone,
        address: address ?? this.address);
  }

  ClientInfo copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? icon,
      Wrapped<String?>? email,
      Wrapped<String?>? phone,
      Wrapped<String?>? address}) {
    return ClientInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        icon: (icon != null ? icon.value : this.icon),
        email: (email != null ? email.value : this.email),
        phone: (phone != null ? phone.value : this.phone),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class Client {
  const Client({
    required this.name,
    this.description,
    this.tags,
    this.icon,
    this.email,
    this.phone,
    this.address,
    required this.domainKey,
    required this.id,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
  });

  factory Client.fromJson(Map<String, dynamic> json) => _$ClientFromJson(json);

  static const toJsonFactory = _$ClientToJson;
  Map<String, dynamic> toJson() => _$ClientToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'description', includeIfNull: false, defaultValue: '')
  final String? description;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'icon', includeIfNull: false, defaultValue: '')
  final String? icon;
  @JsonKey(name: 'email', includeIfNull: false, defaultValue: '')
  final String? email;
  @JsonKey(name: 'phone', includeIfNull: false, defaultValue: '')
  final String? phone;
  @JsonKey(name: 'address', includeIfNull: false, defaultValue: '')
  final String? address;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  static const fromJsonFactory = _$ClientFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Client &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.domainKey, domainKey) ||
                const DeepCollectionEquality()
                    .equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rtype, rtype) ||
                const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) ||
                const DeepCollectionEquality()
                    .equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) ||
                const DeepCollectionEquality()
                    .equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) ||
                const DeepCollectionEquality()
                    .equals(other.updatedStamp, updatedStamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      runtimeType.hashCode;
}

extension $ClientExtension on Client {
  Client copyWith(
      {String? name,
      String? description,
      List<String>? tags,
      String? icon,
      String? email,
      String? phone,
      String? address,
      String? domainKey,
      String? id,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp}) {
    return Client(
        name: name ?? this.name,
        description: description ?? this.description,
        tags: tags ?? this.tags,
        icon: icon ?? this.icon,
        email: email ?? this.email,
        phone: phone ?? this.phone,
        address: address ?? this.address,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp);
  }

  Client copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? description,
      Wrapped<List<String>?>? tags,
      Wrapped<String?>? icon,
      Wrapped<String?>? email,
      Wrapped<String?>? phone,
      Wrapped<String?>? address,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp}) {
    return Client(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        tags: (tags != null ? tags.value : this.tags),
        icon: (icon != null ? icon.value : this.icon),
        email: (email != null ? email.value : this.email),
        phone: (phone != null ? phone.value : this.phone),
        address: (address != null ? address.value : this.address),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientEntity {
  const ClientEntity({
    this.entity,
  });

  factory ClientEntity.fromJson(Map<String, dynamic> json) =>
      _$ClientEntityFromJson(json);

  static const toJsonFactory = _$ClientEntityToJson;
  Map<String, dynamic> toJson() => _$ClientEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Client? entity;
  static const fromJsonFactory = _$ClientEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ClientEntityExtension on ClientEntity {
  ClientEntity copyWith({Client? entity}) {
    return ClientEntity(entity: entity ?? this.entity);
  }

  ClientEntity copyWithWrapped({Wrapped<Client?>? entity}) {
    return ClientEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientEntityRes {
  const ClientEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory ClientEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ClientEntityResFromJson(json);

  static const toJsonFactory = _$ClientEntityResToJson;
  Map<String, dynamic> toJson() => _$ClientEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Client? entity;
  static const fromJsonFactory = _$ClientEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $ClientEntityResExtension on ClientEntityRes {
  ClientEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Client? entity}) {
    return ClientEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  ClientEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Client?>? entity}) {
    return ClientEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientArray {
  const ClientArray({
    this.values,
  });

  factory ClientArray.fromJson(Map<String, dynamic> json) =>
      _$ClientArrayFromJson(json);

  static const toJsonFactory = _$ClientArrayToJson;
  Map<String, dynamic> toJson() => _$ClientArrayToJson(this);

  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Client>[])
  final List<Client>? values;
  static const fromJsonFactory = _$ClientArrayFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientArray &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(values) ^ runtimeType.hashCode;
}

extension $ClientArrayExtension on ClientArray {
  ClientArray copyWith({List<Client>? values}) {
    return ClientArray(values: values ?? this.values);
  }

  ClientArray copyWithWrapped({Wrapped<List<Client>?>? values}) {
    return ClientArray(values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientArrayRes {
  const ClientArrayRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.page,
    required this.size,
    required this.total,
    this.values,
  });

  factory ClientArrayRes.fromJson(Map<String, dynamic> json) =>
      _$ClientArrayResFromJson(json);

  static const toJsonFactory = _$ClientArrayResToJson;
  Map<String, dynamic> toJson() => _$ClientArrayResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int size;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'values', includeIfNull: false, defaultValue: <Client>[])
  final List<Client>? values;
  static const fromJsonFactory = _$ClientArrayResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientArrayRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.values, values) ||
                const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $ClientArrayResExtension on ClientArrayRes {
  ClientArrayRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? page,
      int? size,
      int? total,
      List<Client>? values}) {
    return ClientArrayRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        page: page ?? this.page,
        size: size ?? this.size,
        total: total ?? this.total,
        values: values ?? this.values);
  }

  ClientArrayRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? page,
      Wrapped<int>? size,
      Wrapped<int>? total,
      Wrapped<List<Client>?>? values}) {
    return ClientArrayRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size),
        total: (total != null ? total.value : this.total),
        values: (values != null ? values.value : this.values));
  }
}

@JsonSerializable(explicitToJson: true)
class EqlCondition {
  const EqlCondition({
    required this.name,
    required this.condition,
  });

  factory EqlCondition.fromJson(Map<String, dynamic> json) =>
      _$EqlConditionFromJson(json);

  static const toJsonFactory = _$EqlConditionToJson;
  Map<String, dynamic> toJson() => _$EqlConditionToJson(this);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'condition', includeIfNull: false)
  final Object condition;
  static const fromJsonFactory = _$EqlConditionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EqlCondition &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(condition) ^
      runtimeType.hashCode;
}

extension $EqlConditionExtension on EqlCondition {
  EqlCondition copyWith({String? name, Object? condition}) {
    return EqlCondition(
        name: name ?? this.name, condition: condition ?? this.condition);
  }

  EqlCondition copyWithWrapped(
      {Wrapped<String>? name, Wrapped<Object>? condition}) {
    return EqlCondition(
        name: (name != null ? name.value : this.name),
        condition: (condition != null ? condition.value : this.condition));
  }
}

@JsonSerializable(explicitToJson: true)
class EqlSearch {
  const EqlSearch({
    required this.source,
    this.conditions,
    this.queryConditions,
    this.boolConditions,
    this.mustConditions,
    this.sort,
    this.page,
    this.size,
  });

  factory EqlSearch.fromJson(Map<String, dynamic> json) =>
      _$EqlSearchFromJson(json);

  static const toJsonFactory = _$EqlSearchToJson;
  Map<String, dynamic> toJson() => _$EqlSearchToJson(this);

  @JsonKey(name: 'source', includeIfNull: false, defaultValue: <String>[])
  final List<String> source;
  @JsonKey(
      name: 'conditions', includeIfNull: false, defaultValue: <EqlCondition>[])
  final List<EqlCondition>? conditions;
  @JsonKey(
      name: 'queryConditions',
      includeIfNull: false,
      defaultValue: <EqlCondition>[])
  final List<EqlCondition>? queryConditions;
  @JsonKey(
      name: 'boolConditions',
      includeIfNull: false,
      defaultValue: <EqlCondition>[])
  final List<EqlCondition>? boolConditions;
  @JsonKey(
      name: 'mustConditions', includeIfNull: false, defaultValue: <Object>[])
  final List<Object>? mustConditions;
  @JsonKey(name: 'sort', includeIfNull: false)
  final Object? sort;
  @JsonKey(name: 'page', includeIfNull: false)
  final int? page;
  @JsonKey(name: 'size', includeIfNull: false)
  final int? size;
  static const fromJsonFactory = _$EqlSearchFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EqlSearch &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.queryConditions, queryConditions) ||
                const DeepCollectionEquality()
                    .equals(other.queryConditions, queryConditions)) &&
            (identical(other.boolConditions, boolConditions) ||
                const DeepCollectionEquality()
                    .equals(other.boolConditions, boolConditions)) &&
            (identical(other.mustConditions, mustConditions) ||
                const DeepCollectionEquality()
                    .equals(other.mustConditions, mustConditions)) &&
            (identical(other.sort, sort) ||
                const DeepCollectionEquality().equals(other.sort, sort)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(queryConditions) ^
      const DeepCollectionEquality().hash(boolConditions) ^
      const DeepCollectionEquality().hash(mustConditions) ^
      const DeepCollectionEquality().hash(sort) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $EqlSearchExtension on EqlSearch {
  EqlSearch copyWith(
      {List<String>? source,
      List<EqlCondition>? conditions,
      List<EqlCondition>? queryConditions,
      List<EqlCondition>? boolConditions,
      List<Object>? mustConditions,
      Object? sort,
      int? page,
      int? size}) {
    return EqlSearch(
        source: source ?? this.source,
        conditions: conditions ?? this.conditions,
        queryConditions: queryConditions ?? this.queryConditions,
        boolConditions: boolConditions ?? this.boolConditions,
        mustConditions: mustConditions ?? this.mustConditions,
        sort: sort ?? this.sort,
        page: page ?? this.page,
        size: size ?? this.size);
  }

  EqlSearch copyWithWrapped(
      {Wrapped<List<String>>? source,
      Wrapped<List<EqlCondition>?>? conditions,
      Wrapped<List<EqlCondition>?>? queryConditions,
      Wrapped<List<EqlCondition>?>? boolConditions,
      Wrapped<List<Object>?>? mustConditions,
      Wrapped<Object?>? sort,
      Wrapped<int?>? page,
      Wrapped<int?>? size}) {
    return EqlSearch(
        source: (source != null ? source.value : this.source),
        conditions: (conditions != null ? conditions.value : this.conditions),
        queryConditions: (queryConditions != null
            ? queryConditions.value
            : this.queryConditions),
        boolConditions: (boolConditions != null
            ? boolConditions.value
            : this.boolConditions),
        mustConditions: (mustConditions != null
            ? mustConditions.value
            : this.mustConditions),
        sort: (sort != null ? sort.value : this.sort),
        page: (page != null ? page.value : this.page),
        size: (size != null ? size.value : this.size));
  }
}

@JsonSerializable(explicitToJson: true)
class BaseQueryRes {
  const BaseQueryRes({
    this.result,
  });

  factory BaseQueryRes.fromJson(Map<String, dynamic> json) =>
      _$BaseQueryResFromJson(json);

  static const toJsonFactory = _$BaseQueryResToJson;
  Map<String, dynamic> toJson() => _$BaseQueryResToJson(this);

  @JsonKey(name: 'result', includeIfNull: false)
  final Object? result;
  static const fromJsonFactory = _$BaseQueryResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseQueryRes &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(result) ^ runtimeType.hashCode;
}

extension $BaseQueryResExtension on BaseQueryRes {
  BaseQueryRes copyWith({Object? result}) {
    return BaseQueryRes(result: result ?? this.result);
  }

  BaseQueryRes copyWithWrapped({Wrapped<Object?>? result}) {
    return BaseQueryRes(result: (result != null ? result.value : this.result));
  }
}

@JsonSerializable(explicitToJson: true)
class QueryRes {
  const QueryRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.result,
  });

  factory QueryRes.fromJson(Map<String, dynamic> json) =>
      _$QueryResFromJson(json);

  static const toJsonFactory = _$QueryResToJson;
  Map<String, dynamic> toJson() => _$QueryResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'result', includeIfNull: false)
  final Object? result;
  static const fromJsonFactory = _$QueryResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QueryRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(result) ^
      runtimeType.hashCode;
}

extension $QueryResExtension on QueryRes {
  QueryRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Object? result}) {
    return QueryRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        result: result ?? this.result);
  }

  QueryRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Object?>? result}) {
    return QueryRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        result: (result != null ? result.value : this.result));
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCountRes {
  const BaseCountRes({
    required this.total,
  });

  factory BaseCountRes.fromJson(Map<String, dynamic> json) =>
      _$BaseCountResFromJson(json);

  static const toJsonFactory = _$BaseCountResToJson;
  Map<String, dynamic> toJson() => _$BaseCountResToJson(this);

  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  static const fromJsonFactory = _$BaseCountResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseCountRes &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^ runtimeType.hashCode;
}

extension $BaseCountResExtension on BaseCountRes {
  BaseCountRes copyWith({int? total}) {
    return BaseCountRes(total: total ?? this.total);
  }

  BaseCountRes copyWithWrapped({Wrapped<int>? total}) {
    return BaseCountRes(total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class CountRes {
  const CountRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.total,
  });

  factory CountRes.fromJson(Map<String, dynamic> json) =>
      _$CountResFromJson(json);

  static const toJsonFactory = _$CountResToJson;
  Map<String, dynamic> toJson() => _$CountResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  static const fromJsonFactory = _$CountResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CountRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $CountResExtension on CountRes {
  CountRes copyWith(
      {bool? ok, String? msg, String? trace, String? errorCode, int? total}) {
    return CountRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        total: total ?? this.total);
  }

  CountRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? total}) {
    return CountRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class FailedAssetUpload {
  const FailedAssetUpload({
    required this.line,
    required this.assetName,
    required this.hardwareDeviceId,
  });

  factory FailedAssetUpload.fromJson(Map<String, dynamic> json) =>
      _$FailedAssetUploadFromJson(json);

  static const toJsonFactory = _$FailedAssetUploadToJson;
  Map<String, dynamic> toJson() => _$FailedAssetUploadToJson(this);

  @JsonKey(name: 'line', includeIfNull: false)
  final int line;
  @JsonKey(name: 'assetName', includeIfNull: false, defaultValue: '')
  final String assetName;
  @JsonKey(name: 'hardwareDeviceId', includeIfNull: false, defaultValue: '')
  final String hardwareDeviceId;
  static const fromJsonFactory = _$FailedAssetUploadFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FailedAssetUpload &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)) &&
            (identical(other.assetName, assetName) ||
                const DeepCollectionEquality()
                    .equals(other.assetName, assetName)) &&
            (identical(other.hardwareDeviceId, hardwareDeviceId) ||
                const DeepCollectionEquality()
                    .equals(other.hardwareDeviceId, hardwareDeviceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(line) ^
      const DeepCollectionEquality().hash(assetName) ^
      const DeepCollectionEquality().hash(hardwareDeviceId) ^
      runtimeType.hashCode;
}

extension $FailedAssetUploadExtension on FailedAssetUpload {
  FailedAssetUpload copyWith(
      {int? line, String? assetName, String? hardwareDeviceId}) {
    return FailedAssetUpload(
        line: line ?? this.line,
        assetName: assetName ?? this.assetName,
        hardwareDeviceId: hardwareDeviceId ?? this.hardwareDeviceId);
  }

  FailedAssetUpload copyWithWrapped(
      {Wrapped<int>? line,
      Wrapped<String>? assetName,
      Wrapped<String>? hardwareDeviceId}) {
    return FailedAssetUpload(
        line: (line != null ? line.value : this.line),
        assetName: (assetName != null ? assetName.value : this.assetName),
        hardwareDeviceId: (hardwareDeviceId != null
            ? hardwareDeviceId.value
            : this.hardwareDeviceId));
  }
}

@JsonSerializable(explicitToJson: true)
class BaseAssetUploadRes {
  const BaseAssetUploadRes({
    required this.total,
    required this.failed,
    required this.failures,
  });

  factory BaseAssetUploadRes.fromJson(Map<String, dynamic> json) =>
      _$BaseAssetUploadResFromJson(json);

  static const toJsonFactory = _$BaseAssetUploadResToJson;
  Map<String, dynamic> toJson() => _$BaseAssetUploadResToJson(this);

  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'failed', includeIfNull: false)
  final int failed;
  @JsonKey(
      name: 'failures',
      includeIfNull: false,
      defaultValue: <FailedAssetUpload>[])
  final List<FailedAssetUpload> failures;
  static const fromJsonFactory = _$BaseAssetUploadResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseAssetUploadRes &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.failed, failed) ||
                const DeepCollectionEquality().equals(other.failed, failed)) &&
            (identical(other.failures, failures) ||
                const DeepCollectionEquality()
                    .equals(other.failures, failures)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(failed) ^
      const DeepCollectionEquality().hash(failures) ^
      runtimeType.hashCode;
}

extension $BaseAssetUploadResExtension on BaseAssetUploadRes {
  BaseAssetUploadRes copyWith(
      {int? total, int? failed, List<FailedAssetUpload>? failures}) {
    return BaseAssetUploadRes(
        total: total ?? this.total,
        failed: failed ?? this.failed,
        failures: failures ?? this.failures);
  }

  BaseAssetUploadRes copyWithWrapped(
      {Wrapped<int>? total,
      Wrapped<int>? failed,
      Wrapped<List<FailedAssetUpload>>? failures}) {
    return BaseAssetUploadRes(
        total: (total != null ? total.value : this.total),
        failed: (failed != null ? failed.value : this.failed),
        failures: (failures != null ? failures.value : this.failures));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetBulkUploadRes {
  const AssetBulkUploadRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    required this.total,
    required this.failed,
    required this.failures,
  });

  factory AssetBulkUploadRes.fromJson(Map<String, dynamic> json) =>
      _$AssetBulkUploadResFromJson(json);

  static const toJsonFactory = _$AssetBulkUploadResToJson;
  Map<String, dynamic> toJson() => _$AssetBulkUploadResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'total', includeIfNull: false)
  final int total;
  @JsonKey(name: 'failed', includeIfNull: false)
  final int failed;
  @JsonKey(
      name: 'failures',
      includeIfNull: false,
      defaultValue: <FailedAssetUpload>[])
  final List<FailedAssetUpload> failures;
  static const fromJsonFactory = _$AssetBulkUploadResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AssetBulkUploadRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.failed, failed) ||
                const DeepCollectionEquality().equals(other.failed, failed)) &&
            (identical(other.failures, failures) ||
                const DeepCollectionEquality()
                    .equals(other.failures, failures)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(failed) ^
      const DeepCollectionEquality().hash(failures) ^
      runtimeType.hashCode;
}

extension $AssetBulkUploadResExtension on AssetBulkUploadRes {
  AssetBulkUploadRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      int? total,
      int? failed,
      List<FailedAssetUpload>? failures}) {
    return AssetBulkUploadRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        total: total ?? this.total,
        failed: failed ?? this.failed,
        failures: failures ?? this.failures);
  }

  AssetBulkUploadRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<int>? total,
      Wrapped<int>? failed,
      Wrapped<List<FailedAssetUpload>>? failures}) {
    return AssetBulkUploadRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        total: (total != null ? total.value : this.total),
        failed: (failed != null ? failed.value : this.failed),
        failures: (failures != null ? failures.value : this.failures));
  }
}

@JsonSerializable(explicitToJson: true)
class Usage {
  const Usage({
    required this.usedPooledDataPoints,
    required this.usedDataPoints,
    required this.usedDeviceModels,
    required this.usedDevices,
    required this.usedUsers,
    required this.usedClients,
    required this.usedDashboards,
    required this.availablePooledDataPoints,
    required this.availableDataPoints,
    this.availableDeviceModels,
    required this.availableDevices,
    required this.availableUsers,
    required this.availableClients,
    required this.availableDashboards,
  });

  factory Usage.fromJson(Map<String, dynamic> json) => _$UsageFromJson(json);

  static const toJsonFactory = _$UsageToJson;
  Map<String, dynamic> toJson() => _$UsageToJson(this);

  @JsonKey(name: 'usedPooledDataPoints', includeIfNull: false)
  final int usedPooledDataPoints;
  @JsonKey(name: 'usedDataPoints', includeIfNull: false)
  final int usedDataPoints;
  @JsonKey(name: 'usedDeviceModels', includeIfNull: false)
  final int usedDeviceModels;
  @JsonKey(name: 'usedDevices', includeIfNull: false)
  final int usedDevices;
  @JsonKey(name: 'usedUsers', includeIfNull: false)
  final int usedUsers;
  @JsonKey(name: 'usedClients', includeIfNull: false)
  final int usedClients;
  @JsonKey(name: 'usedDashboards', includeIfNull: false)
  final int usedDashboards;
  @JsonKey(name: 'availablePooledDataPoints', includeIfNull: false)
  final int availablePooledDataPoints;
  @JsonKey(name: 'availableDataPoints', includeIfNull: false)
  final int availableDataPoints;
  @JsonKey(name: 'availableDeviceModels', includeIfNull: false)
  final int? availableDeviceModels;
  @JsonKey(name: 'availableDevices', includeIfNull: false)
  final int availableDevices;
  @JsonKey(name: 'availableUsers', includeIfNull: false)
  final int availableUsers;
  @JsonKey(name: 'availableClients', includeIfNull: false)
  final int availableClients;
  @JsonKey(name: 'availableDashboards', includeIfNull: false)
  final int availableDashboards;
  static const fromJsonFactory = _$UsageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Usage &&
            (identical(other.usedPooledDataPoints, usedPooledDataPoints) ||
                const DeepCollectionEquality().equals(
                    other.usedPooledDataPoints, usedPooledDataPoints)) &&
            (identical(other.usedDataPoints, usedDataPoints) ||
                const DeepCollectionEquality()
                    .equals(other.usedDataPoints, usedDataPoints)) &&
            (identical(other.usedDeviceModels, usedDeviceModels) ||
                const DeepCollectionEquality()
                    .equals(other.usedDeviceModels, usedDeviceModels)) &&
            (identical(other.usedDevices, usedDevices) ||
                const DeepCollectionEquality()
                    .equals(other.usedDevices, usedDevices)) &&
            (identical(other.usedUsers, usedUsers) ||
                const DeepCollectionEquality()
                    .equals(other.usedUsers, usedUsers)) &&
            (identical(other.usedClients, usedClients) ||
                const DeepCollectionEquality()
                    .equals(other.usedClients, usedClients)) &&
            (identical(other.usedDashboards, usedDashboards) ||
                const DeepCollectionEquality()
                    .equals(other.usedDashboards, usedDashboards)) &&
            (identical(other.availablePooledDataPoints,
                    availablePooledDataPoints) ||
                const DeepCollectionEquality().equals(
                    other.availablePooledDataPoints,
                    availablePooledDataPoints)) &&
            (identical(other.availableDataPoints, availableDataPoints) ||
                const DeepCollectionEquality()
                    .equals(other.availableDataPoints, availableDataPoints)) &&
            (identical(other.availableDeviceModels, availableDeviceModels) ||
                const DeepCollectionEquality().equals(
                    other.availableDeviceModels, availableDeviceModels)) &&
            (identical(other.availableDevices, availableDevices) ||
                const DeepCollectionEquality()
                    .equals(other.availableDevices, availableDevices)) &&
            (identical(other.availableUsers, availableUsers) ||
                const DeepCollectionEquality()
                    .equals(other.availableUsers, availableUsers)) &&
            (identical(other.availableClients, availableClients) ||
                const DeepCollectionEquality()
                    .equals(other.availableClients, availableClients)) &&
            (identical(other.availableDashboards, availableDashboards) ||
                const DeepCollectionEquality()
                    .equals(other.availableDashboards, availableDashboards)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usedPooledDataPoints) ^
      const DeepCollectionEquality().hash(usedDataPoints) ^
      const DeepCollectionEquality().hash(usedDeviceModels) ^
      const DeepCollectionEquality().hash(usedDevices) ^
      const DeepCollectionEquality().hash(usedUsers) ^
      const DeepCollectionEquality().hash(usedClients) ^
      const DeepCollectionEquality().hash(usedDashboards) ^
      const DeepCollectionEquality().hash(availablePooledDataPoints) ^
      const DeepCollectionEquality().hash(availableDataPoints) ^
      const DeepCollectionEquality().hash(availableDeviceModels) ^
      const DeepCollectionEquality().hash(availableDevices) ^
      const DeepCollectionEquality().hash(availableUsers) ^
      const DeepCollectionEquality().hash(availableClients) ^
      const DeepCollectionEquality().hash(availableDashboards) ^
      runtimeType.hashCode;
}

extension $UsageExtension on Usage {
  Usage copyWith(
      {int? usedPooledDataPoints,
      int? usedDataPoints,
      int? usedDeviceModels,
      int? usedDevices,
      int? usedUsers,
      int? usedClients,
      int? usedDashboards,
      int? availablePooledDataPoints,
      int? availableDataPoints,
      int? availableDeviceModels,
      int? availableDevices,
      int? availableUsers,
      int? availableClients,
      int? availableDashboards}) {
    return Usage(
        usedPooledDataPoints: usedPooledDataPoints ?? this.usedPooledDataPoints,
        usedDataPoints: usedDataPoints ?? this.usedDataPoints,
        usedDeviceModels: usedDeviceModels ?? this.usedDeviceModels,
        usedDevices: usedDevices ?? this.usedDevices,
        usedUsers: usedUsers ?? this.usedUsers,
        usedClients: usedClients ?? this.usedClients,
        usedDashboards: usedDashboards ?? this.usedDashboards,
        availablePooledDataPoints:
            availablePooledDataPoints ?? this.availablePooledDataPoints,
        availableDataPoints: availableDataPoints ?? this.availableDataPoints,
        availableDeviceModels:
            availableDeviceModels ?? this.availableDeviceModels,
        availableDevices: availableDevices ?? this.availableDevices,
        availableUsers: availableUsers ?? this.availableUsers,
        availableClients: availableClients ?? this.availableClients,
        availableDashboards: availableDashboards ?? this.availableDashboards);
  }

  Usage copyWithWrapped(
      {Wrapped<int>? usedPooledDataPoints,
      Wrapped<int>? usedDataPoints,
      Wrapped<int>? usedDeviceModels,
      Wrapped<int>? usedDevices,
      Wrapped<int>? usedUsers,
      Wrapped<int>? usedClients,
      Wrapped<int>? usedDashboards,
      Wrapped<int>? availablePooledDataPoints,
      Wrapped<int>? availableDataPoints,
      Wrapped<int?>? availableDeviceModels,
      Wrapped<int>? availableDevices,
      Wrapped<int>? availableUsers,
      Wrapped<int>? availableClients,
      Wrapped<int>? availableDashboards}) {
    return Usage(
        usedPooledDataPoints: (usedPooledDataPoints != null
            ? usedPooledDataPoints.value
            : this.usedPooledDataPoints),
        usedDataPoints: (usedDataPoints != null
            ? usedDataPoints.value
            : this.usedDataPoints),
        usedDeviceModels: (usedDeviceModels != null
            ? usedDeviceModels.value
            : this.usedDeviceModels),
        usedDevices:
            (usedDevices != null ? usedDevices.value : this.usedDevices),
        usedUsers: (usedUsers != null ? usedUsers.value : this.usedUsers),
        usedClients:
            (usedClients != null ? usedClients.value : this.usedClients),
        usedDashboards: (usedDashboards != null
            ? usedDashboards.value
            : this.usedDashboards),
        availablePooledDataPoints: (availablePooledDataPoints != null
            ? availablePooledDataPoints.value
            : this.availablePooledDataPoints),
        availableDataPoints: (availableDataPoints != null
            ? availableDataPoints.value
            : this.availableDataPoints),
        availableDeviceModels: (availableDeviceModels != null
            ? availableDeviceModels.value
            : this.availableDeviceModels),
        availableDevices: (availableDevices != null
            ? availableDevices.value
            : this.availableDevices),
        availableUsers: (availableUsers != null
            ? availableUsers.value
            : this.availableUsers),
        availableClients: (availableClients != null
            ? availableClients.value
            : this.availableClients),
        availableDashboards: (availableDashboards != null
            ? availableDashboards.value
            : this.availableDashboards));
  }
}

@JsonSerializable(explicitToJson: true)
class UsageEntity {
  const UsageEntity({
    this.entity,
  });

  factory UsageEntity.fromJson(Map<String, dynamic> json) =>
      _$UsageEntityFromJson(json);

  static const toJsonFactory = _$UsageEntityToJson;
  Map<String, dynamic> toJson() => _$UsageEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final Usage? entity;
  static const fromJsonFactory = _$UsageEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UsageEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $UsageEntityExtension on UsageEntity {
  UsageEntity copyWith({Usage? entity}) {
    return UsageEntity(entity: entity ?? this.entity);
  }

  UsageEntity copyWithWrapped({Wrapped<Usage?>? entity}) {
    return UsageEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class UsageEntityRes {
  const UsageEntityRes({
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
    this.entity,
  });

  factory UsageEntityRes.fromJson(Map<String, dynamic> json) =>
      _$UsageEntityResFromJson(json);

  static const toJsonFactory = _$UsageEntityResToJson;
  Map<String, dynamic> toJson() => _$UsageEntityResToJson(this);

  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  @JsonKey(name: 'entity', includeIfNull: false)
  final Usage? entity;
  static const fromJsonFactory = _$UsageEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UsageEntityRes &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(entity) ^
      runtimeType.hashCode;
}

extension $UsageEntityResExtension on UsageEntityRes {
  UsageEntityRes copyWith(
      {bool? ok,
      String? msg,
      String? trace,
      String? errorCode,
      Usage? entity}) {
    return UsageEntityRes(
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode,
        entity: entity ?? this.entity);
  }

  UsageEntityRes copyWithWrapped(
      {Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode,
      Wrapped<Usage?>? entity}) {
    return UsageEntityRes(
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class OrgPlanInfo {
  const OrgPlanInfo({
    required this.planId,
    required this.planType,
    required this.planFrequency,
    required this.deviceModelCount,
    required this.modelParametersCount,
    required this.devicesCount,
    required this.clientCount,
    required this.userCount,
    required this.dashboardCount,
    required this.dataPointsCount,
    required this.archivalYearsCount,
    required this.purchasedModels,
    required this.purchasedParameters,
    required this.purchasedDevices,
    required this.purchasedClients,
    required this.purchasedUsers,
    required this.purchasedDashboards,
    required this.purchasedDataPoints,
    required this.purchasedArchivals,
    this.totalDeviceModelCount,
    this.totalModelParametersCount,
    required this.totalDevicesCount,
    required this.totalClientCount,
    required this.totalUserCount,
    required this.totalDashboardCount,
    required this.totalArchivalYearsCount,
    required this.pooledDataPointsCount,
    this.canBuyDataPlan,
    this.canBuyArchivalPlan,
    this.canBuyClientPlan,
    this.canBrand,
    this.canWhiteLabel,
  });

  factory OrgPlanInfo.fromJson(Map<String, dynamic> json) =>
      _$OrgPlanInfoFromJson(json);

  static const toJsonFactory = _$OrgPlanInfoToJson;
  Map<String, dynamic> toJson() => _$OrgPlanInfoToJson(this);

  @JsonKey(name: 'planId', includeIfNull: false, defaultValue: '')
  final String planId;
  @JsonKey(name: 'planType', includeIfNull: false, defaultValue: '')
  final String planType;
  @JsonKey(name: 'planFrequency', includeIfNull: false, defaultValue: '')
  final String planFrequency;
  @JsonKey(name: 'deviceModelCount', includeIfNull: false)
  final int deviceModelCount;
  @JsonKey(name: 'modelParametersCount', includeIfNull: false)
  final int modelParametersCount;
  @JsonKey(name: 'devicesCount', includeIfNull: false)
  final int devicesCount;
  @JsonKey(name: 'clientCount', includeIfNull: false)
  final int clientCount;
  @JsonKey(name: 'userCount', includeIfNull: false)
  final int userCount;
  @JsonKey(name: 'dashboardCount', includeIfNull: false)
  final int dashboardCount;
  @JsonKey(name: 'dataPointsCount', includeIfNull: false)
  final int dataPointsCount;
  @JsonKey(name: 'archivalYearsCount', includeIfNull: false)
  final int archivalYearsCount;
  @JsonKey(name: 'purchasedModels', includeIfNull: false)
  final int purchasedModels;
  @JsonKey(name: 'purchasedParameters', includeIfNull: false)
  final int purchasedParameters;
  @JsonKey(name: 'purchasedDevices', includeIfNull: false)
  final int purchasedDevices;
  @JsonKey(name: 'purchasedClients', includeIfNull: false)
  final int purchasedClients;
  @JsonKey(name: 'purchasedUsers', includeIfNull: false)
  final int purchasedUsers;
  @JsonKey(name: 'purchasedDashboards', includeIfNull: false)
  final int purchasedDashboards;
  @JsonKey(name: 'purchasedDataPoints', includeIfNull: false)
  final int purchasedDataPoints;
  @JsonKey(name: 'purchasedArchivals', includeIfNull: false)
  final int purchasedArchivals;
  @JsonKey(name: 'totalDeviceModelCount', includeIfNull: false)
  final int? totalDeviceModelCount;
  @JsonKey(name: 'totalModelParametersCount', includeIfNull: false)
  final int? totalModelParametersCount;
  @JsonKey(name: 'totalDevicesCount', includeIfNull: false)
  final int totalDevicesCount;
  @JsonKey(name: 'totalClientCount', includeIfNull: false)
  final int totalClientCount;
  @JsonKey(name: 'totalUserCount', includeIfNull: false)
  final int totalUserCount;
  @JsonKey(name: 'totalDashboardCount', includeIfNull: false)
  final int totalDashboardCount;
  @JsonKey(name: 'totalArchivalYearsCount', includeIfNull: false)
  final int totalArchivalYearsCount;
  @JsonKey(name: 'pooledDataPointsCount', includeIfNull: false)
  final int pooledDataPointsCount;
  @JsonKey(name: 'canBuyDataPlan', includeIfNull: false)
  final bool? canBuyDataPlan;
  @JsonKey(name: 'canBuyArchivalPlan', includeIfNull: false)
  final bool? canBuyArchivalPlan;
  @JsonKey(name: 'canBuyClientPlan', includeIfNull: false)
  final bool? canBuyClientPlan;
  @JsonKey(name: 'canBrand', includeIfNull: false)
  final bool? canBrand;
  @JsonKey(name: 'canWhiteLabel', includeIfNull: false)
  final bool? canWhiteLabel;
  static const fromJsonFactory = _$OrgPlanInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OrgPlanInfo &&
            (identical(other.planId, planId) ||
                const DeepCollectionEquality().equals(other.planId, planId)) &&
            (identical(other.planType, planType) ||
                const DeepCollectionEquality()
                    .equals(other.planType, planType)) &&
            (identical(other.planFrequency, planFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.planFrequency, planFrequency)) &&
            (identical(other.deviceModelCount, deviceModelCount) ||
                const DeepCollectionEquality()
                    .equals(other.deviceModelCount, deviceModelCount)) &&
            (identical(other.modelParametersCount, modelParametersCount) ||
                const DeepCollectionEquality().equals(
                    other.modelParametersCount, modelParametersCount)) &&
            (identical(other.devicesCount, devicesCount) ||
                const DeepCollectionEquality()
                    .equals(other.devicesCount, devicesCount)) &&
            (identical(other.clientCount, clientCount) ||
                const DeepCollectionEquality()
                    .equals(other.clientCount, clientCount)) &&
            (identical(other.userCount, userCount) ||
                const DeepCollectionEquality()
                    .equals(other.userCount, userCount)) &&
            (identical(other.dashboardCount, dashboardCount) ||
                const DeepCollectionEquality()
                    .equals(other.dashboardCount, dashboardCount)) &&
            (identical(other.dataPointsCount, dataPointsCount) ||
                const DeepCollectionEquality()
                    .equals(other.dataPointsCount, dataPointsCount)) &&
            (identical(other.archivalYearsCount, archivalYearsCount) ||
                const DeepCollectionEquality()
                    .equals(other.archivalYearsCount, archivalYearsCount)) &&
            (identical(other.purchasedModels, purchasedModels) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedModels, purchasedModels)) &&
            (identical(other.purchasedParameters, purchasedParameters) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedParameters, purchasedParameters)) &&
            (identical(other.purchasedDevices, purchasedDevices) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedDevices, purchasedDevices)) &&
            (identical(other.purchasedClients, purchasedClients) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedClients, purchasedClients)) &&
            (identical(other.purchasedUsers, purchasedUsers) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedUsers, purchasedUsers)) &&
            (identical(other.purchasedDashboards, purchasedDashboards) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedDashboards, purchasedDashboards)) &&
            (identical(other.purchasedDataPoints, purchasedDataPoints) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedDataPoints, purchasedDataPoints)) &&
            (identical(other.purchasedArchivals, purchasedArchivals) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedArchivals, purchasedArchivals)) &&
            (identical(other.totalDeviceModelCount, totalDeviceModelCount) ||
                const DeepCollectionEquality().equals(
                    other.totalDeviceModelCount, totalDeviceModelCount)) &&
            (identical(other.totalModelParametersCount, totalModelParametersCount) ||
                const DeepCollectionEquality().equals(
                    other.totalModelParametersCount,
                    totalModelParametersCount)) &&
            (identical(other.totalDevicesCount, totalDevicesCount) || const DeepCollectionEquality().equals(other.totalDevicesCount, totalDevicesCount)) &&
            (identical(other.totalClientCount, totalClientCount) || const DeepCollectionEquality().equals(other.totalClientCount, totalClientCount)) &&
            (identical(other.totalUserCount, totalUserCount) || const DeepCollectionEquality().equals(other.totalUserCount, totalUserCount)) &&
            (identical(other.totalDashboardCount, totalDashboardCount) || const DeepCollectionEquality().equals(other.totalDashboardCount, totalDashboardCount)) &&
            (identical(other.totalArchivalYearsCount, totalArchivalYearsCount) || const DeepCollectionEquality().equals(other.totalArchivalYearsCount, totalArchivalYearsCount)) &&
            (identical(other.pooledDataPointsCount, pooledDataPointsCount) || const DeepCollectionEquality().equals(other.pooledDataPointsCount, pooledDataPointsCount)) &&
            (identical(other.canBuyDataPlan, canBuyDataPlan) || const DeepCollectionEquality().equals(other.canBuyDataPlan, canBuyDataPlan)) &&
            (identical(other.canBuyArchivalPlan, canBuyArchivalPlan) || const DeepCollectionEquality().equals(other.canBuyArchivalPlan, canBuyArchivalPlan)) &&
            (identical(other.canBuyClientPlan, canBuyClientPlan) || const DeepCollectionEquality().equals(other.canBuyClientPlan, canBuyClientPlan)) &&
            (identical(other.canBrand, canBrand) || const DeepCollectionEquality().equals(other.canBrand, canBrand)) &&
            (identical(other.canWhiteLabel, canWhiteLabel) || const DeepCollectionEquality().equals(other.canWhiteLabel, canWhiteLabel)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(planId) ^
      const DeepCollectionEquality().hash(planType) ^
      const DeepCollectionEquality().hash(planFrequency) ^
      const DeepCollectionEquality().hash(deviceModelCount) ^
      const DeepCollectionEquality().hash(modelParametersCount) ^
      const DeepCollectionEquality().hash(devicesCount) ^
      const DeepCollectionEquality().hash(clientCount) ^
      const DeepCollectionEquality().hash(userCount) ^
      const DeepCollectionEquality().hash(dashboardCount) ^
      const DeepCollectionEquality().hash(dataPointsCount) ^
      const DeepCollectionEquality().hash(archivalYearsCount) ^
      const DeepCollectionEquality().hash(purchasedModels) ^
      const DeepCollectionEquality().hash(purchasedParameters) ^
      const DeepCollectionEquality().hash(purchasedDevices) ^
      const DeepCollectionEquality().hash(purchasedClients) ^
      const DeepCollectionEquality().hash(purchasedUsers) ^
      const DeepCollectionEquality().hash(purchasedDashboards) ^
      const DeepCollectionEquality().hash(purchasedDataPoints) ^
      const DeepCollectionEquality().hash(purchasedArchivals) ^
      const DeepCollectionEquality().hash(totalDeviceModelCount) ^
      const DeepCollectionEquality().hash(totalModelParametersCount) ^
      const DeepCollectionEquality().hash(totalDevicesCount) ^
      const DeepCollectionEquality().hash(totalClientCount) ^
      const DeepCollectionEquality().hash(totalUserCount) ^
      const DeepCollectionEquality().hash(totalDashboardCount) ^
      const DeepCollectionEquality().hash(totalArchivalYearsCount) ^
      const DeepCollectionEquality().hash(pooledDataPointsCount) ^
      const DeepCollectionEquality().hash(canBuyDataPlan) ^
      const DeepCollectionEquality().hash(canBuyArchivalPlan) ^
      const DeepCollectionEquality().hash(canBuyClientPlan) ^
      const DeepCollectionEquality().hash(canBrand) ^
      const DeepCollectionEquality().hash(canWhiteLabel) ^
      runtimeType.hashCode;
}

extension $OrgPlanInfoExtension on OrgPlanInfo {
  OrgPlanInfo copyWith(
      {String? planId,
      String? planType,
      String? planFrequency,
      int? deviceModelCount,
      int? modelParametersCount,
      int? devicesCount,
      int? clientCount,
      int? userCount,
      int? dashboardCount,
      int? dataPointsCount,
      int? archivalYearsCount,
      int? purchasedModels,
      int? purchasedParameters,
      int? purchasedDevices,
      int? purchasedClients,
      int? purchasedUsers,
      int? purchasedDashboards,
      int? purchasedDataPoints,
      int? purchasedArchivals,
      int? totalDeviceModelCount,
      int? totalModelParametersCount,
      int? totalDevicesCount,
      int? totalClientCount,
      int? totalUserCount,
      int? totalDashboardCount,
      int? totalArchivalYearsCount,
      int? pooledDataPointsCount,
      bool? canBuyDataPlan,
      bool? canBuyArchivalPlan,
      bool? canBuyClientPlan,
      bool? canBrand,
      bool? canWhiteLabel}) {
    return OrgPlanInfo(
        planId: planId ?? this.planId,
        planType: planType ?? this.planType,
        planFrequency: planFrequency ?? this.planFrequency,
        deviceModelCount: deviceModelCount ?? this.deviceModelCount,
        modelParametersCount: modelParametersCount ?? this.modelParametersCount,
        devicesCount: devicesCount ?? this.devicesCount,
        clientCount: clientCount ?? this.clientCount,
        userCount: userCount ?? this.userCount,
        dashboardCount: dashboardCount ?? this.dashboardCount,
        dataPointsCount: dataPointsCount ?? this.dataPointsCount,
        archivalYearsCount: archivalYearsCount ?? this.archivalYearsCount,
        purchasedModels: purchasedModels ?? this.purchasedModels,
        purchasedParameters: purchasedParameters ?? this.purchasedParameters,
        purchasedDevices: purchasedDevices ?? this.purchasedDevices,
        purchasedClients: purchasedClients ?? this.purchasedClients,
        purchasedUsers: purchasedUsers ?? this.purchasedUsers,
        purchasedDashboards: purchasedDashboards ?? this.purchasedDashboards,
        purchasedDataPoints: purchasedDataPoints ?? this.purchasedDataPoints,
        purchasedArchivals: purchasedArchivals ?? this.purchasedArchivals,
        totalDeviceModelCount:
            totalDeviceModelCount ?? this.totalDeviceModelCount,
        totalModelParametersCount:
            totalModelParametersCount ?? this.totalModelParametersCount,
        totalDevicesCount: totalDevicesCount ?? this.totalDevicesCount,
        totalClientCount: totalClientCount ?? this.totalClientCount,
        totalUserCount: totalUserCount ?? this.totalUserCount,
        totalDashboardCount: totalDashboardCount ?? this.totalDashboardCount,
        totalArchivalYearsCount:
            totalArchivalYearsCount ?? this.totalArchivalYearsCount,
        pooledDataPointsCount:
            pooledDataPointsCount ?? this.pooledDataPointsCount,
        canBuyDataPlan: canBuyDataPlan ?? this.canBuyDataPlan,
        canBuyArchivalPlan: canBuyArchivalPlan ?? this.canBuyArchivalPlan,
        canBuyClientPlan: canBuyClientPlan ?? this.canBuyClientPlan,
        canBrand: canBrand ?? this.canBrand,
        canWhiteLabel: canWhiteLabel ?? this.canWhiteLabel);
  }

  OrgPlanInfo copyWithWrapped(
      {Wrapped<String>? planId,
      Wrapped<String>? planType,
      Wrapped<String>? planFrequency,
      Wrapped<int>? deviceModelCount,
      Wrapped<int>? modelParametersCount,
      Wrapped<int>? devicesCount,
      Wrapped<int>? clientCount,
      Wrapped<int>? userCount,
      Wrapped<int>? dashboardCount,
      Wrapped<int>? dataPointsCount,
      Wrapped<int>? archivalYearsCount,
      Wrapped<int>? purchasedModels,
      Wrapped<int>? purchasedParameters,
      Wrapped<int>? purchasedDevices,
      Wrapped<int>? purchasedClients,
      Wrapped<int>? purchasedUsers,
      Wrapped<int>? purchasedDashboards,
      Wrapped<int>? purchasedDataPoints,
      Wrapped<int>? purchasedArchivals,
      Wrapped<int?>? totalDeviceModelCount,
      Wrapped<int?>? totalModelParametersCount,
      Wrapped<int>? totalDevicesCount,
      Wrapped<int>? totalClientCount,
      Wrapped<int>? totalUserCount,
      Wrapped<int>? totalDashboardCount,
      Wrapped<int>? totalArchivalYearsCount,
      Wrapped<int>? pooledDataPointsCount,
      Wrapped<bool?>? canBuyDataPlan,
      Wrapped<bool?>? canBuyArchivalPlan,
      Wrapped<bool?>? canBuyClientPlan,
      Wrapped<bool?>? canBrand,
      Wrapped<bool?>? canWhiteLabel}) {
    return OrgPlanInfo(
        planId: (planId != null ? planId.value : this.planId),
        planType: (planType != null ? planType.value : this.planType),
        planFrequency:
            (planFrequency != null ? planFrequency.value : this.planFrequency),
        deviceModelCount: (deviceModelCount != null
            ? deviceModelCount.value
            : this.deviceModelCount),
        modelParametersCount: (modelParametersCount != null
            ? modelParametersCount.value
            : this.modelParametersCount),
        devicesCount:
            (devicesCount != null ? devicesCount.value : this.devicesCount),
        clientCount:
            (clientCount != null ? clientCount.value : this.clientCount),
        userCount: (userCount != null ? userCount.value : this.userCount),
        dashboardCount: (dashboardCount != null
            ? dashboardCount.value
            : this.dashboardCount),
        dataPointsCount: (dataPointsCount != null
            ? dataPointsCount.value
            : this.dataPointsCount),
        archivalYearsCount: (archivalYearsCount != null
            ? archivalYearsCount.value
            : this.archivalYearsCount),
        purchasedModels: (purchasedModels != null
            ? purchasedModels.value
            : this.purchasedModels),
        purchasedParameters: (purchasedParameters != null
            ? purchasedParameters.value
            : this.purchasedParameters),
        purchasedDevices: (purchasedDevices != null
            ? purchasedDevices.value
            : this.purchasedDevices),
        purchasedClients: (purchasedClients != null
            ? purchasedClients.value
            : this.purchasedClients),
        purchasedUsers: (purchasedUsers != null
            ? purchasedUsers.value
            : this.purchasedUsers),
        purchasedDashboards: (purchasedDashboards != null
            ? purchasedDashboards.value
            : this.purchasedDashboards),
        purchasedDataPoints: (purchasedDataPoints != null
            ? purchasedDataPoints.value
            : this.purchasedDataPoints),
        purchasedArchivals: (purchasedArchivals != null
            ? purchasedArchivals.value
            : this.purchasedArchivals),
        totalDeviceModelCount: (totalDeviceModelCount != null
            ? totalDeviceModelCount.value
            : this.totalDeviceModelCount),
        totalModelParametersCount: (totalModelParametersCount != null
            ? totalModelParametersCount.value
            : this.totalModelParametersCount),
        totalDevicesCount: (totalDevicesCount != null
            ? totalDevicesCount.value
            : this.totalDevicesCount),
        totalClientCount: (totalClientCount != null
            ? totalClientCount.value
            : this.totalClientCount),
        totalUserCount: (totalUserCount != null
            ? totalUserCount.value
            : this.totalUserCount),
        totalDashboardCount: (totalDashboardCount != null
            ? totalDashboardCount.value
            : this.totalDashboardCount),
        totalArchivalYearsCount: (totalArchivalYearsCount != null
            ? totalArchivalYearsCount.value
            : this.totalArchivalYearsCount),
        pooledDataPointsCount: (pooledDataPointsCount != null
            ? pooledDataPointsCount.value
            : this.pooledDataPointsCount),
        canBuyDataPlan: (canBuyDataPlan != null
            ? canBuyDataPlan.value
            : this.canBuyDataPlan),
        canBuyArchivalPlan: (canBuyArchivalPlan != null
            ? canBuyArchivalPlan.value
            : this.canBuyArchivalPlan),
        canBuyClientPlan: (canBuyClientPlan != null
            ? canBuyClientPlan.value
            : this.canBuyClientPlan),
        canBrand: (canBrand != null ? canBrand.value : this.canBrand),
        canWhiteLabel:
            (canWhiteLabel != null ? canWhiteLabel.value : this.canWhiteLabel));
  }
}

@JsonSerializable(explicitToJson: true)
class OrgPlanBase {
  const OrgPlanBase({
    required this.orgId,
    required this.currency,
    this.currencySumbol,
  });

  factory OrgPlanBase.fromJson(Map<String, dynamic> json) =>
      _$OrgPlanBaseFromJson(json);

  static const toJsonFactory = _$OrgPlanBaseToJson;
  Map<String, dynamic> toJson() => _$OrgPlanBaseToJson(this);

  @JsonKey(name: 'orgId', includeIfNull: false, defaultValue: '')
  final String orgId;
  @JsonKey(name: 'currency', includeIfNull: false, defaultValue: '')
  final String currency;
  @JsonKey(name: 'currencySumbol', includeIfNull: false, defaultValue: '')
  final String? currencySumbol;
  static const fromJsonFactory = _$OrgPlanBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OrgPlanBase &&
            (identical(other.orgId, orgId) ||
                const DeepCollectionEquality().equals(other.orgId, orgId)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.currencySumbol, currencySumbol) ||
                const DeepCollectionEquality()
                    .equals(other.currencySumbol, currencySumbol)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(orgId) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(currencySumbol) ^
      runtimeType.hashCode;
}

extension $OrgPlanBaseExtension on OrgPlanBase {
  OrgPlanBase copyWith(
      {String? orgId, String? currency, String? currencySumbol}) {
    return OrgPlanBase(
        orgId: orgId ?? this.orgId,
        currency: currency ?? this.currency,
        currencySumbol: currencySumbol ?? this.currencySumbol);
  }

  OrgPlanBase copyWithWrapped(
      {Wrapped<String>? orgId,
      Wrapped<String>? currency,
      Wrapped<String?>? currencySumbol}) {
    return OrgPlanBase(
        orgId: (orgId != null ? orgId.value : this.orgId),
        currency: (currency != null ? currency.value : this.currency),
        currencySumbol: (currencySumbol != null
            ? currencySumbol.value
            : this.currencySumbol));
  }
}

@JsonSerializable(explicitToJson: true)
class OrgPlan {
  const OrgPlan({
    required this.orgId,
    required this.planId,
    required this.planType,
    required this.planFrequency,
    required this.deviceModelCount,
    required this.modelParametersCount,
    required this.devicesCount,
    required this.clientCount,
    required this.userCount,
    required this.dashboardCount,
    required this.dataPointsCount,
    required this.archivalYearsCount,
    required this.purchasedModels,
    required this.purchasedParameters,
    required this.purchasedDevices,
    required this.purchasedClients,
    required this.purchasedUsers,
    required this.purchasedDashboards,
    required this.purchasedDataPoints,
    required this.purchasedArchivals,
    this.totalDeviceModelCount,
    this.totalModelParametersCount,
    required this.totalDevicesCount,
    required this.totalClientCount,
    required this.totalUserCount,
    required this.totalDashboardCount,
    required this.totalArchivalYearsCount,
    required this.pooledDataPointsCount,
    this.canBuyDataPlan,
    this.canBuyArchivalPlan,
    this.canBuyClientPlan,
    this.canBrand,
    this.canWhiteLabel,
    required this.currency,
    this.currencySumbol,
    required this.domainKey,
    required this.id,
    required this.name,
    required this.rtype,
    required this.createdStamp,
    required this.createdBy,
    required this.updatedBy,
    required this.updatedStamp,
    this.tags,
  });

  factory OrgPlan.fromJson(Map<String, dynamic> json) =>
      _$OrgPlanFromJson(json);

  static const toJsonFactory = _$OrgPlanToJson;
  Map<String, dynamic> toJson() => _$OrgPlanToJson(this);

  @JsonKey(name: 'orgId', includeIfNull: false, defaultValue: '')
  final String orgId;
  @JsonKey(name: 'planId', includeIfNull: false, defaultValue: '')
  final String planId;
  @JsonKey(name: 'planType', includeIfNull: false, defaultValue: '')
  final String planType;
  @JsonKey(name: 'planFrequency', includeIfNull: false, defaultValue: '')
  final String planFrequency;
  @JsonKey(name: 'deviceModelCount', includeIfNull: false)
  final int deviceModelCount;
  @JsonKey(name: 'modelParametersCount', includeIfNull: false)
  final int modelParametersCount;
  @JsonKey(name: 'devicesCount', includeIfNull: false)
  final int devicesCount;
  @JsonKey(name: 'clientCount', includeIfNull: false)
  final int clientCount;
  @JsonKey(name: 'userCount', includeIfNull: false)
  final int userCount;
  @JsonKey(name: 'dashboardCount', includeIfNull: false)
  final int dashboardCount;
  @JsonKey(name: 'dataPointsCount', includeIfNull: false)
  final int dataPointsCount;
  @JsonKey(name: 'archivalYearsCount', includeIfNull: false)
  final int archivalYearsCount;
  @JsonKey(name: 'purchasedModels', includeIfNull: false)
  final int purchasedModels;
  @JsonKey(name: 'purchasedParameters', includeIfNull: false)
  final int purchasedParameters;
  @JsonKey(name: 'purchasedDevices', includeIfNull: false)
  final int purchasedDevices;
  @JsonKey(name: 'purchasedClients', includeIfNull: false)
  final int purchasedClients;
  @JsonKey(name: 'purchasedUsers', includeIfNull: false)
  final int purchasedUsers;
  @JsonKey(name: 'purchasedDashboards', includeIfNull: false)
  final int purchasedDashboards;
  @JsonKey(name: 'purchasedDataPoints', includeIfNull: false)
  final int purchasedDataPoints;
  @JsonKey(name: 'purchasedArchivals', includeIfNull: false)
  final int purchasedArchivals;
  @JsonKey(name: 'totalDeviceModelCount', includeIfNull: false)
  final int? totalDeviceModelCount;
  @JsonKey(name: 'totalModelParametersCount', includeIfNull: false)
  final int? totalModelParametersCount;
  @JsonKey(name: 'totalDevicesCount', includeIfNull: false)
  final int totalDevicesCount;
  @JsonKey(name: 'totalClientCount', includeIfNull: false)
  final int totalClientCount;
  @JsonKey(name: 'totalUserCount', includeIfNull: false)
  final int totalUserCount;
  @JsonKey(name: 'totalDashboardCount', includeIfNull: false)
  final int totalDashboardCount;
  @JsonKey(name: 'totalArchivalYearsCount', includeIfNull: false)
  final int totalArchivalYearsCount;
  @JsonKey(name: 'pooledDataPointsCount', includeIfNull: false)
  final int pooledDataPointsCount;
  @JsonKey(name: 'canBuyDataPlan', includeIfNull: false)
  final bool? canBuyDataPlan;
  @JsonKey(name: 'canBuyArchivalPlan', includeIfNull: false)
  final bool? canBuyArchivalPlan;
  @JsonKey(name: 'canBuyClientPlan', includeIfNull: false)
  final bool? canBuyClientPlan;
  @JsonKey(name: 'canBrand', includeIfNull: false)
  final bool? canBrand;
  @JsonKey(name: 'canWhiteLabel', includeIfNull: false)
  final bool? canWhiteLabel;
  @JsonKey(name: 'currency', includeIfNull: false, defaultValue: '')
  final String currency;
  @JsonKey(name: 'currencySumbol', includeIfNull: false, defaultValue: '')
  final String? currencySumbol;
  @JsonKey(name: 'domainKey', includeIfNull: false, defaultValue: '')
  final String domainKey;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String name;
  @JsonKey(name: 'rtype', includeIfNull: false, defaultValue: '')
  final String rtype;
  @JsonKey(name: 'createdStamp', includeIfNull: false)
  final int createdStamp;
  @JsonKey(name: 'createdBy', includeIfNull: false, defaultValue: '')
  final String createdBy;
  @JsonKey(name: 'updatedBy', includeIfNull: false, defaultValue: '')
  final String updatedBy;
  @JsonKey(name: 'updatedStamp', includeIfNull: false)
  final int updatedStamp;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$OrgPlanFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OrgPlan &&
            (identical(other.orgId, orgId) ||
                const DeepCollectionEquality().equals(other.orgId, orgId)) &&
            (identical(other.planId, planId) ||
                const DeepCollectionEquality().equals(other.planId, planId)) &&
            (identical(other.planType, planType) ||
                const DeepCollectionEquality()
                    .equals(other.planType, planType)) &&
            (identical(other.planFrequency, planFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.planFrequency, planFrequency)) &&
            (identical(other.deviceModelCount, deviceModelCount) ||
                const DeepCollectionEquality()
                    .equals(other.deviceModelCount, deviceModelCount)) &&
            (identical(other.modelParametersCount, modelParametersCount) ||
                const DeepCollectionEquality().equals(
                    other.modelParametersCount, modelParametersCount)) &&
            (identical(other.devicesCount, devicesCount) ||
                const DeepCollectionEquality()
                    .equals(other.devicesCount, devicesCount)) &&
            (identical(other.clientCount, clientCount) ||
                const DeepCollectionEquality()
                    .equals(other.clientCount, clientCount)) &&
            (identical(other.userCount, userCount) ||
                const DeepCollectionEquality()
                    .equals(other.userCount, userCount)) &&
            (identical(other.dashboardCount, dashboardCount) ||
                const DeepCollectionEquality()
                    .equals(other.dashboardCount, dashboardCount)) &&
            (identical(other.dataPointsCount, dataPointsCount) ||
                const DeepCollectionEquality()
                    .equals(other.dataPointsCount, dataPointsCount)) &&
            (identical(other.archivalYearsCount, archivalYearsCount) ||
                const DeepCollectionEquality()
                    .equals(other.archivalYearsCount, archivalYearsCount)) &&
            (identical(other.purchasedModels, purchasedModels) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedModels, purchasedModels)) &&
            (identical(other.purchasedParameters, purchasedParameters) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedParameters, purchasedParameters)) &&
            (identical(other.purchasedDevices, purchasedDevices) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedDevices, purchasedDevices)) &&
            (identical(other.purchasedClients, purchasedClients) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedClients, purchasedClients)) &&
            (identical(other.purchasedUsers, purchasedUsers) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedUsers, purchasedUsers)) &&
            (identical(other.purchasedDashboards, purchasedDashboards) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedDashboards, purchasedDashboards)) &&
            (identical(other.purchasedDataPoints, purchasedDataPoints) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedDataPoints, purchasedDataPoints)) &&
            (identical(other.purchasedArchivals, purchasedArchivals) ||
                const DeepCollectionEquality()
                    .equals(other.purchasedArchivals, purchasedArchivals)) &&
            (identical(other.totalDeviceModelCount, totalDeviceModelCount) ||
                const DeepCollectionEquality().equals(
                    other.totalDeviceModelCount, totalDeviceModelCount)) &&
            (identical(other.totalModelParametersCount, totalModelParametersCount) ||
                const DeepCollectionEquality().equals(
                    other.totalModelParametersCount, totalModelParametersCount)) &&
            (identical(other.totalDevicesCount, totalDevicesCount) || const DeepCollectionEquality().equals(other.totalDevicesCount, totalDevicesCount)) &&
            (identical(other.totalClientCount, totalClientCount) || const DeepCollectionEquality().equals(other.totalClientCount, totalClientCount)) &&
            (identical(other.totalUserCount, totalUserCount) || const DeepCollectionEquality().equals(other.totalUserCount, totalUserCount)) &&
            (identical(other.totalDashboardCount, totalDashboardCount) || const DeepCollectionEquality().equals(other.totalDashboardCount, totalDashboardCount)) &&
            (identical(other.totalArchivalYearsCount, totalArchivalYearsCount) || const DeepCollectionEquality().equals(other.totalArchivalYearsCount, totalArchivalYearsCount)) &&
            (identical(other.pooledDataPointsCount, pooledDataPointsCount) || const DeepCollectionEquality().equals(other.pooledDataPointsCount, pooledDataPointsCount)) &&
            (identical(other.canBuyDataPlan, canBuyDataPlan) || const DeepCollectionEquality().equals(other.canBuyDataPlan, canBuyDataPlan)) &&
            (identical(other.canBuyArchivalPlan, canBuyArchivalPlan) || const DeepCollectionEquality().equals(other.canBuyArchivalPlan, canBuyArchivalPlan)) &&
            (identical(other.canBuyClientPlan, canBuyClientPlan) || const DeepCollectionEquality().equals(other.canBuyClientPlan, canBuyClientPlan)) &&
            (identical(other.canBrand, canBrand) || const DeepCollectionEquality().equals(other.canBrand, canBrand)) &&
            (identical(other.canWhiteLabel, canWhiteLabel) || const DeepCollectionEquality().equals(other.canWhiteLabel, canWhiteLabel)) &&
            (identical(other.currency, currency) || const DeepCollectionEquality().equals(other.currency, currency)) &&
            (identical(other.currencySumbol, currencySumbol) || const DeepCollectionEquality().equals(other.currencySumbol, currencySumbol)) &&
            (identical(other.domainKey, domainKey) || const DeepCollectionEquality().equals(other.domainKey, domainKey)) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.rtype, rtype) || const DeepCollectionEquality().equals(other.rtype, rtype)) &&
            (identical(other.createdStamp, createdStamp) || const DeepCollectionEquality().equals(other.createdStamp, createdStamp)) &&
            (identical(other.createdBy, createdBy) || const DeepCollectionEquality().equals(other.createdBy, createdBy)) &&
            (identical(other.updatedBy, updatedBy) || const DeepCollectionEquality().equals(other.updatedBy, updatedBy)) &&
            (identical(other.updatedStamp, updatedStamp) || const DeepCollectionEquality().equals(other.updatedStamp, updatedStamp)) &&
            (identical(other.tags, tags) || const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(orgId) ^
      const DeepCollectionEquality().hash(planId) ^
      const DeepCollectionEquality().hash(planType) ^
      const DeepCollectionEquality().hash(planFrequency) ^
      const DeepCollectionEquality().hash(deviceModelCount) ^
      const DeepCollectionEquality().hash(modelParametersCount) ^
      const DeepCollectionEquality().hash(devicesCount) ^
      const DeepCollectionEquality().hash(clientCount) ^
      const DeepCollectionEquality().hash(userCount) ^
      const DeepCollectionEquality().hash(dashboardCount) ^
      const DeepCollectionEquality().hash(dataPointsCount) ^
      const DeepCollectionEquality().hash(archivalYearsCount) ^
      const DeepCollectionEquality().hash(purchasedModels) ^
      const DeepCollectionEquality().hash(purchasedParameters) ^
      const DeepCollectionEquality().hash(purchasedDevices) ^
      const DeepCollectionEquality().hash(purchasedClients) ^
      const DeepCollectionEquality().hash(purchasedUsers) ^
      const DeepCollectionEquality().hash(purchasedDashboards) ^
      const DeepCollectionEquality().hash(purchasedDataPoints) ^
      const DeepCollectionEquality().hash(purchasedArchivals) ^
      const DeepCollectionEquality().hash(totalDeviceModelCount) ^
      const DeepCollectionEquality().hash(totalModelParametersCount) ^
      const DeepCollectionEquality().hash(totalDevicesCount) ^
      const DeepCollectionEquality().hash(totalClientCount) ^
      const DeepCollectionEquality().hash(totalUserCount) ^
      const DeepCollectionEquality().hash(totalDashboardCount) ^
      const DeepCollectionEquality().hash(totalArchivalYearsCount) ^
      const DeepCollectionEquality().hash(pooledDataPointsCount) ^
      const DeepCollectionEquality().hash(canBuyDataPlan) ^
      const DeepCollectionEquality().hash(canBuyArchivalPlan) ^
      const DeepCollectionEquality().hash(canBuyClientPlan) ^
      const DeepCollectionEquality().hash(canBrand) ^
      const DeepCollectionEquality().hash(canWhiteLabel) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(currencySumbol) ^
      const DeepCollectionEquality().hash(domainKey) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(rtype) ^
      const DeepCollectionEquality().hash(createdStamp) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(updatedBy) ^
      const DeepCollectionEquality().hash(updatedStamp) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $OrgPlanExtension on OrgPlan {
  OrgPlan copyWith(
      {String? orgId,
      String? planId,
      String? planType,
      String? planFrequency,
      int? deviceModelCount,
      int? modelParametersCount,
      int? devicesCount,
      int? clientCount,
      int? userCount,
      int? dashboardCount,
      int? dataPointsCount,
      int? archivalYearsCount,
      int? purchasedModels,
      int? purchasedParameters,
      int? purchasedDevices,
      int? purchasedClients,
      int? purchasedUsers,
      int? purchasedDashboards,
      int? purchasedDataPoints,
      int? purchasedArchivals,
      int? totalDeviceModelCount,
      int? totalModelParametersCount,
      int? totalDevicesCount,
      int? totalClientCount,
      int? totalUserCount,
      int? totalDashboardCount,
      int? totalArchivalYearsCount,
      int? pooledDataPointsCount,
      bool? canBuyDataPlan,
      bool? canBuyArchivalPlan,
      bool? canBuyClientPlan,
      bool? canBrand,
      bool? canWhiteLabel,
      String? currency,
      String? currencySumbol,
      String? domainKey,
      String? id,
      String? name,
      String? rtype,
      int? createdStamp,
      String? createdBy,
      String? updatedBy,
      int? updatedStamp,
      List<String>? tags}) {
    return OrgPlan(
        orgId: orgId ?? this.orgId,
        planId: planId ?? this.planId,
        planType: planType ?? this.planType,
        planFrequency: planFrequency ?? this.planFrequency,
        deviceModelCount: deviceModelCount ?? this.deviceModelCount,
        modelParametersCount: modelParametersCount ?? this.modelParametersCount,
        devicesCount: devicesCount ?? this.devicesCount,
        clientCount: clientCount ?? this.clientCount,
        userCount: userCount ?? this.userCount,
        dashboardCount: dashboardCount ?? this.dashboardCount,
        dataPointsCount: dataPointsCount ?? this.dataPointsCount,
        archivalYearsCount: archivalYearsCount ?? this.archivalYearsCount,
        purchasedModels: purchasedModels ?? this.purchasedModels,
        purchasedParameters: purchasedParameters ?? this.purchasedParameters,
        purchasedDevices: purchasedDevices ?? this.purchasedDevices,
        purchasedClients: purchasedClients ?? this.purchasedClients,
        purchasedUsers: purchasedUsers ?? this.purchasedUsers,
        purchasedDashboards: purchasedDashboards ?? this.purchasedDashboards,
        purchasedDataPoints: purchasedDataPoints ?? this.purchasedDataPoints,
        purchasedArchivals: purchasedArchivals ?? this.purchasedArchivals,
        totalDeviceModelCount:
            totalDeviceModelCount ?? this.totalDeviceModelCount,
        totalModelParametersCount:
            totalModelParametersCount ?? this.totalModelParametersCount,
        totalDevicesCount: totalDevicesCount ?? this.totalDevicesCount,
        totalClientCount: totalClientCount ?? this.totalClientCount,
        totalUserCount: totalUserCount ?? this.totalUserCount,
        totalDashboardCount: totalDashboardCount ?? this.totalDashboardCount,
        totalArchivalYearsCount:
            totalArchivalYearsCount ?? this.totalArchivalYearsCount,
        pooledDataPointsCount:
            pooledDataPointsCount ?? this.pooledDataPointsCount,
        canBuyDataPlan: canBuyDataPlan ?? this.canBuyDataPlan,
        canBuyArchivalPlan: canBuyArchivalPlan ?? this.canBuyArchivalPlan,
        canBuyClientPlan: canBuyClientPlan ?? this.canBuyClientPlan,
        canBrand: canBrand ?? this.canBrand,
        canWhiteLabel: canWhiteLabel ?? this.canWhiteLabel,
        currency: currency ?? this.currency,
        currencySumbol: currencySumbol ?? this.currencySumbol,
        domainKey: domainKey ?? this.domainKey,
        id: id ?? this.id,
        name: name ?? this.name,
        rtype: rtype ?? this.rtype,
        createdStamp: createdStamp ?? this.createdStamp,
        createdBy: createdBy ?? this.createdBy,
        updatedBy: updatedBy ?? this.updatedBy,
        updatedStamp: updatedStamp ?? this.updatedStamp,
        tags: tags ?? this.tags);
  }

  OrgPlan copyWithWrapped(
      {Wrapped<String>? orgId,
      Wrapped<String>? planId,
      Wrapped<String>? planType,
      Wrapped<String>? planFrequency,
      Wrapped<int>? deviceModelCount,
      Wrapped<int>? modelParametersCount,
      Wrapped<int>? devicesCount,
      Wrapped<int>? clientCount,
      Wrapped<int>? userCount,
      Wrapped<int>? dashboardCount,
      Wrapped<int>? dataPointsCount,
      Wrapped<int>? archivalYearsCount,
      Wrapped<int>? purchasedModels,
      Wrapped<int>? purchasedParameters,
      Wrapped<int>? purchasedDevices,
      Wrapped<int>? purchasedClients,
      Wrapped<int>? purchasedUsers,
      Wrapped<int>? purchasedDashboards,
      Wrapped<int>? purchasedDataPoints,
      Wrapped<int>? purchasedArchivals,
      Wrapped<int?>? totalDeviceModelCount,
      Wrapped<int?>? totalModelParametersCount,
      Wrapped<int>? totalDevicesCount,
      Wrapped<int>? totalClientCount,
      Wrapped<int>? totalUserCount,
      Wrapped<int>? totalDashboardCount,
      Wrapped<int>? totalArchivalYearsCount,
      Wrapped<int>? pooledDataPointsCount,
      Wrapped<bool?>? canBuyDataPlan,
      Wrapped<bool?>? canBuyArchivalPlan,
      Wrapped<bool?>? canBuyClientPlan,
      Wrapped<bool?>? canBrand,
      Wrapped<bool?>? canWhiteLabel,
      Wrapped<String>? currency,
      Wrapped<String?>? currencySumbol,
      Wrapped<String>? domainKey,
      Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String>? rtype,
      Wrapped<int>? createdStamp,
      Wrapped<String>? createdBy,
      Wrapped<String>? updatedBy,
      Wrapped<int>? updatedStamp,
      Wrapped<List<String>?>? tags}) {
    return OrgPlan(
        orgId: (orgId != null ? orgId.value : this.orgId),
        planId: (planId != null ? planId.value : this.planId),
        planType: (planType != null ? planType.value : this.planType),
        planFrequency:
            (planFrequency != null ? planFrequency.value : this.planFrequency),
        deviceModelCount: (deviceModelCount != null
            ? deviceModelCount.value
            : this.deviceModelCount),
        modelParametersCount: (modelParametersCount != null
            ? modelParametersCount.value
            : this.modelParametersCount),
        devicesCount:
            (devicesCount != null ? devicesCount.value : this.devicesCount),
        clientCount:
            (clientCount != null ? clientCount.value : this.clientCount),
        userCount: (userCount != null ? userCount.value : this.userCount),
        dashboardCount: (dashboardCount != null
            ? dashboardCount.value
            : this.dashboardCount),
        dataPointsCount: (dataPointsCount != null
            ? dataPointsCount.value
            : this.dataPointsCount),
        archivalYearsCount: (archivalYearsCount != null
            ? archivalYearsCount.value
            : this.archivalYearsCount),
        purchasedModels: (purchasedModels != null
            ? purchasedModels.value
            : this.purchasedModels),
        purchasedParameters: (purchasedParameters != null
            ? purchasedParameters.value
            : this.purchasedParameters),
        purchasedDevices: (purchasedDevices != null
            ? purchasedDevices.value
            : this.purchasedDevices),
        purchasedClients: (purchasedClients != null
            ? purchasedClients.value
            : this.purchasedClients),
        purchasedUsers: (purchasedUsers != null
            ? purchasedUsers.value
            : this.purchasedUsers),
        purchasedDashboards: (purchasedDashboards != null
            ? purchasedDashboards.value
            : this.purchasedDashboards),
        purchasedDataPoints: (purchasedDataPoints != null
            ? purchasedDataPoints.value
            : this.purchasedDataPoints),
        purchasedArchivals: (purchasedArchivals != null
            ? purchasedArchivals.value
            : this.purchasedArchivals),
        totalDeviceModelCount: (totalDeviceModelCount != null
            ? totalDeviceModelCount.value
            : this.totalDeviceModelCount),
        totalModelParametersCount: (totalModelParametersCount != null
            ? totalModelParametersCount.value
            : this.totalModelParametersCount),
        totalDevicesCount: (totalDevicesCount != null
            ? totalDevicesCount.value
            : this.totalDevicesCount),
        totalClientCount: (totalClientCount != null
            ? totalClientCount.value
            : this.totalClientCount),
        totalUserCount: (totalUserCount != null
            ? totalUserCount.value
            : this.totalUserCount),
        totalDashboardCount: (totalDashboardCount != null
            ? totalDashboardCount.value
            : this.totalDashboardCount),
        totalArchivalYearsCount: (totalArchivalYearsCount != null
            ? totalArchivalYearsCount.value
            : this.totalArchivalYearsCount),
        pooledDataPointsCount: (pooledDataPointsCount != null
            ? pooledDataPointsCount.value
            : this.pooledDataPointsCount),
        canBuyDataPlan: (canBuyDataPlan != null
            ? canBuyDataPlan.value
            : this.canBuyDataPlan),
        canBuyArchivalPlan: (canBuyArchivalPlan != null
            ? canBuyArchivalPlan.value
            : this.canBuyArchivalPlan),
        canBuyClientPlan: (canBuyClientPlan != null
            ? canBuyClientPlan.value
            : this.canBuyClientPlan),
        canBrand: (canBrand != null ? canBrand.value : this.canBrand),
        canWhiteLabel:
            (canWhiteLabel != null ? canWhiteLabel.value : this.canWhiteLabel),
        currency: (currency != null ? currency.value : this.currency),
        currencySumbol: (currencySumbol != null
            ? currencySumbol.value
            : this.currencySumbol),
        domainKey: (domainKey != null ? domainKey.value : this.domainKey),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        rtype: (rtype != null ? rtype.value : this.rtype),
        createdStamp:
            (createdStamp != null ? createdStamp.value : this.createdStamp),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        updatedBy: (updatedBy != null ? updatedBy.value : this.updatedBy),
        updatedStamp:
            (updatedStamp != null ? updatedStamp.value : this.updatedStamp),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class OrgPlanEntity {
  const OrgPlanEntity({
    this.entity,
  });

  factory OrgPlanEntity.fromJson(Map<String, dynamic> json) =>
      _$OrgPlanEntityFromJson(json);

  static const toJsonFactory = _$OrgPlanEntityToJson;
  Map<String, dynamic> toJson() => _$OrgPlanEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final OrgPlan? entity;
  static const fromJsonFactory = _$OrgPlanEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OrgPlanEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $OrgPlanEntityExtension on OrgPlanEntity {
  OrgPlanEntity copyWith({OrgPlan? entity}) {
    return OrgPlanEntity(entity: entity ?? this.entity);
  }

  OrgPlanEntity copyWithWrapped({Wrapped<OrgPlan?>? entity}) {
    return OrgPlanEntity(entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class OrgPlanEntityRes {
  const OrgPlanEntityRes({
    this.entity,
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory OrgPlanEntityRes.fromJson(Map<String, dynamic> json) =>
      _$OrgPlanEntityResFromJson(json);

  static const toJsonFactory = _$OrgPlanEntityResToJson;
  Map<String, dynamic> toJson() => _$OrgPlanEntityResToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final OrgPlan? entity;
  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$OrgPlanEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OrgPlanEntityRes &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)) &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $OrgPlanEntityResExtension on OrgPlanEntityRes {
  OrgPlanEntityRes copyWith(
      {OrgPlan? entity,
      bool? ok,
      String? msg,
      String? trace,
      String? errorCode}) {
    return OrgPlanEntityRes(
        entity: entity ?? this.entity,
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode);
  }

  OrgPlanEntityRes copyWithWrapped(
      {Wrapped<OrgPlan?>? entity,
      Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode}) {
    return OrgPlanEntityRes(
        entity: (entity != null ? entity.value : this.entity),
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode));
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterUnits {
  const ParameterUnits({
    required this.units,
  });

  factory ParameterUnits.fromJson(Map<String, dynamic> json) =>
      _$ParameterUnitsFromJson(json);

  static const toJsonFactory = _$ParameterUnitsToJson;
  Map<String, dynamic> toJson() => _$ParameterUnitsToJson(this);

  @JsonKey(name: 'units', includeIfNull: false, defaultValue: <String>[])
  final List<String> units;
  static const fromJsonFactory = _$ParameterUnitsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterUnits &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(units) ^ runtimeType.hashCode;
}

extension $ParameterUnitsExtension on ParameterUnits {
  ParameterUnits copyWith({List<String>? units}) {
    return ParameterUnits(units: units ?? this.units);
  }

  ParameterUnits copyWithWrapped({Wrapped<List<String>>? units}) {
    return ParameterUnits(units: (units != null ? units.value : this.units));
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterUnitsEntity {
  const ParameterUnitsEntity({
    this.entity,
  });

  factory ParameterUnitsEntity.fromJson(Map<String, dynamic> json) =>
      _$ParameterUnitsEntityFromJson(json);

  static const toJsonFactory = _$ParameterUnitsEntityToJson;
  Map<String, dynamic> toJson() => _$ParameterUnitsEntityToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ParameterUnits? entity;
  static const fromJsonFactory = _$ParameterUnitsEntityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterUnitsEntity &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^ runtimeType.hashCode;
}

extension $ParameterUnitsEntityExtension on ParameterUnitsEntity {
  ParameterUnitsEntity copyWith({ParameterUnits? entity}) {
    return ParameterUnitsEntity(entity: entity ?? this.entity);
  }

  ParameterUnitsEntity copyWithWrapped({Wrapped<ParameterUnits?>? entity}) {
    return ParameterUnitsEntity(
        entity: (entity != null ? entity.value : this.entity));
  }
}

@JsonSerializable(explicitToJson: true)
class ParameterUnitsEntityRes {
  const ParameterUnitsEntityRes({
    this.entity,
    required this.ok,
    this.msg,
    this.trace,
    this.errorCode,
  });

  factory ParameterUnitsEntityRes.fromJson(Map<String, dynamic> json) =>
      _$ParameterUnitsEntityResFromJson(json);

  static const toJsonFactory = _$ParameterUnitsEntityResToJson;
  Map<String, dynamic> toJson() => _$ParameterUnitsEntityResToJson(this);

  @JsonKey(name: 'entity', includeIfNull: false)
  final ParameterUnits? entity;
  @JsonKey(name: 'ok', includeIfNull: false)
  final bool ok;
  @JsonKey(name: 'msg', includeIfNull: false, defaultValue: '')
  final String? msg;
  @JsonKey(name: 'trace', includeIfNull: false, defaultValue: '')
  final String? trace;
  @JsonKey(name: 'errorCode', includeIfNull: false, defaultValue: '')
  final String? errorCode;
  static const fromJsonFactory = _$ParameterUnitsEntityResFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParameterUnitsEntityRes &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)) &&
            (identical(other.ok, ok) ||
                const DeepCollectionEquality().equals(other.ok, ok)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.trace, trace) ||
                const DeepCollectionEquality().equals(other.trace, trace)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entity) ^
      const DeepCollectionEquality().hash(ok) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(trace) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $ParameterUnitsEntityResExtension on ParameterUnitsEntityRes {
  ParameterUnitsEntityRes copyWith(
      {ParameterUnits? entity,
      bool? ok,
      String? msg,
      String? trace,
      String? errorCode}) {
    return ParameterUnitsEntityRes(
        entity: entity ?? this.entity,
        ok: ok ?? this.ok,
        msg: msg ?? this.msg,
        trace: trace ?? this.trace,
        errorCode: errorCode ?? this.errorCode);
  }

  ParameterUnitsEntityRes copyWithWrapped(
      {Wrapped<ParameterUnits?>? entity,
      Wrapped<bool>? ok,
      Wrapped<String?>? msg,
      Wrapped<String?>? trace,
      Wrapped<String?>? errorCode}) {
    return ParameterUnitsEntityRes(
        entity: (entity != null ? entity.value : this.entity),
        ok: (ok != null ? ok.value : this.ok),
        msg: (msg != null ? msg.value : this.msg),
        trace: (trace != null ? trace.value : this.trace),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode));
  }
}

@JsonSerializable(explicitToJson: true)
class ChangePassReq {
  const ChangePassReq({
    required this.oldPassword,
    required this.newPassword,
    this.twinUserId,
  });

  factory ChangePassReq.fromJson(Map<String, dynamic> json) =>
      _$ChangePassReqFromJson(json);

  static const toJsonFactory = _$ChangePassReqToJson;
  Map<String, dynamic> toJson() => _$ChangePassReqToJson(this);

  @JsonKey(name: 'oldPassword', includeIfNull: false, defaultValue: '')
  final String oldPassword;
  @JsonKey(name: 'newPassword', includeIfNull: false, defaultValue: '')
  final String newPassword;
  @JsonKey(name: 'twinUserId', includeIfNull: false, defaultValue: '')
  final String? twinUserId;
  static const fromJsonFactory = _$ChangePassReqFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChangePassReq &&
            (identical(other.oldPassword, oldPassword) ||
                const DeepCollectionEquality()
                    .equals(other.oldPassword, oldPassword)) &&
            (identical(other.newPassword, newPassword) ||
                const DeepCollectionEquality()
                    .equals(other.newPassword, newPassword)) &&
            (identical(other.twinUserId, twinUserId) ||
                const DeepCollectionEquality()
                    .equals(other.twinUserId, twinUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oldPassword) ^
      const DeepCollectionEquality().hash(newPassword) ^
      const DeepCollectionEquality().hash(twinUserId) ^
      runtimeType.hashCode;
}

extension $ChangePassReqExtension on ChangePassReq {
  ChangePassReq copyWith(
      {String? oldPassword, String? newPassword, String? twinUserId}) {
    return ChangePassReq(
        oldPassword: oldPassword ?? this.oldPassword,
        newPassword: newPassword ?? this.newPassword,
        twinUserId: twinUserId ?? this.twinUserId);
  }

  ChangePassReq copyWithWrapped(
      {Wrapped<String>? oldPassword,
      Wrapped<String>? newPassword,
      Wrapped<String?>? twinUserId}) {
    return ChangePassReq(
        oldPassword:
            (oldPassword != null ? oldPassword.value : this.oldPassword),
        newPassword:
            (newPassword != null ? newPassword.value : this.newPassword),
        twinUserId: (twinUserId != null ? twinUserId.value : this.twinUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportData {
  const ExportData({
    required this.model,
    this.conditions,
    this.alarms,
    this.displays,
    this.controls,
    this.events,
    this.triggers,
    this.displayWidgets,
    this.preprocessors,
  });

  factory ExportData.fromJson(Map<String, dynamic> json) =>
      _$ExportDataFromJson(json);

  static const toJsonFactory = _$ExportDataToJson;
  Map<String, dynamic> toJson() => _$ExportDataToJson(this);

  @JsonKey(name: 'model', includeIfNull: false)
  final DeviceModelInfo model;
  @JsonKey(
      name: 'conditions', includeIfNull: false, defaultValue: <ConditionInfo>[])
  final List<ConditionInfo>? conditions;
  @JsonKey(name: 'alarms', includeIfNull: false, defaultValue: <AlarmInfo>[])
  final List<AlarmInfo>? alarms;
  @JsonKey(
      name: 'displays', includeIfNull: false, defaultValue: <DisplayInfo>[])
  final List<DisplayInfo>? displays;
  @JsonKey(
      name: 'controls', includeIfNull: false, defaultValue: <ControlInfo>[])
  final List<ControlInfo>? controls;
  @JsonKey(name: 'events', includeIfNull: false, defaultValue: <EventInfo>[])
  final List<EventInfo>? events;
  @JsonKey(
      name: 'triggers', includeIfNull: false, defaultValue: <TriggerInfo>[])
  final List<TriggerInfo>? triggers;
  @JsonKey(
      name: 'displayWidgets',
      includeIfNull: false,
      defaultValue: <DisplayWidgetInfo>[])
  final List<DisplayWidgetInfo>? displayWidgets;
  @JsonKey(
      name: 'preprocessors',
      includeIfNull: false,
      defaultValue: <PreprocessorInfo>[])
  final List<PreprocessorInfo>? preprocessors;
  static const fromJsonFactory = _$ExportDataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExportData &&
            (identical(other.model, model) ||
                const DeepCollectionEquality().equals(other.model, model)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.alarms, alarms) ||
                const DeepCollectionEquality().equals(other.alarms, alarms)) &&
            (identical(other.displays, displays) ||
                const DeepCollectionEquality()
                    .equals(other.displays, displays)) &&
            (identical(other.controls, controls) ||
                const DeepCollectionEquality()
                    .equals(other.controls, controls)) &&
            (identical(other.events, events) ||
                const DeepCollectionEquality().equals(other.events, events)) &&
            (identical(other.triggers, triggers) ||
                const DeepCollectionEquality()
                    .equals(other.triggers, triggers)) &&
            (identical(other.displayWidgets, displayWidgets) ||
                const DeepCollectionEquality()
                    .equals(other.displayWidgets, displayWidgets)) &&
            (identical(other.preprocessors, preprocessors) ||
                const DeepCollectionEquality()
                    .equals(other.preprocessors, preprocessors)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(model) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(alarms) ^
      const DeepCollectionEquality().hash(displays) ^
      const DeepCollectionEquality().hash(controls) ^
      const DeepCollectionEquality().hash(events) ^
      const DeepCollectionEquality().hash(triggers) ^
      const DeepCollectionEquality().hash(displayWidgets) ^
      const DeepCollectionEquality().hash(preprocessors) ^
      runtimeType.hashCode;
}

extension $ExportDataExtension on ExportData {
  ExportData copyWith(
      {DeviceModelInfo? model,
      List<ConditionInfo>? conditions,
      List<AlarmInfo>? alarms,
      List<DisplayInfo>? displays,
      List<ControlInfo>? controls,
      List<EventInfo>? events,
      List<TriggerInfo>? triggers,
      List<DisplayWidgetInfo>? displayWidgets,
      List<PreprocessorInfo>? preprocessors}) {
    return ExportData(
        model: model ?? this.model,
        conditions: conditions ?? this.conditions,
        alarms: alarms ?? this.alarms,
        displays: displays ?? this.displays,
        controls: controls ?? this.controls,
        events: events ?? this.events,
        triggers: triggers ?? this.triggers,
        displayWidgets: displayWidgets ?? this.displayWidgets,
        preprocessors: preprocessors ?? this.preprocessors);
  }

  ExportData copyWithWrapped(
      {Wrapped<DeviceModelInfo>? model,
      Wrapped<List<ConditionInfo>?>? conditions,
      Wrapped<List<AlarmInfo>?>? alarms,
      Wrapped<List<DisplayInfo>?>? displays,
      Wrapped<List<ControlInfo>?>? controls,
      Wrapped<List<EventInfo>?>? events,
      Wrapped<List<TriggerInfo>?>? triggers,
      Wrapped<List<DisplayWidgetInfo>?>? displayWidgets,
      Wrapped<List<PreprocessorInfo>?>? preprocessors}) {
    return ExportData(
        model: (model != null ? model.value : this.model),
        conditions: (conditions != null ? conditions.value : this.conditions),
        alarms: (alarms != null ? alarms.value : this.alarms),
        displays: (displays != null ? displays.value : this.displays),
        controls: (controls != null ? controls.value : this.controls),
        events: (events != null ? events.value : this.events),
        triggers: (triggers != null ? triggers.value : this.triggers),
        displayWidgets: (displayWidgets != null
            ? displayWidgets.value
            : this.displayWidgets),
        preprocessors:
            (preprocessors != null ? preprocessors.value : this.preprocessors));
  }
}

String? rangeFilterFilterNullableToJson(
    enums.RangeFilterFilter? rangeFilterFilter) {
  return rangeFilterFilter?.value;
}

String? rangeFilterFilterToJson(enums.RangeFilterFilter rangeFilterFilter) {
  return rangeFilterFilter.value;
}

enums.RangeFilterFilter rangeFilterFilterFromJson(
  Object? rangeFilterFilter, [
  enums.RangeFilterFilter? defaultValue,
]) {
  return enums.RangeFilterFilter.values
          .firstWhereOrNull((e) => e.value == rangeFilterFilter) ??
      defaultValue ??
      enums.RangeFilterFilter.swaggerGeneratedUnknown;
}

enums.RangeFilterFilter? rangeFilterFilterNullableFromJson(
  Object? rangeFilterFilter, [
  enums.RangeFilterFilter? defaultValue,
]) {
  if (rangeFilterFilter == null) {
    return null;
  }
  return enums.RangeFilterFilter.values
          .firstWhereOrNull((e) => e.value == rangeFilterFilter) ??
      defaultValue;
}

String rangeFilterFilterExplodedListToJson(
    List<enums.RangeFilterFilter>? rangeFilterFilter) {
  return rangeFilterFilter?.map((e) => e.value!).join(',') ?? '';
}

List<String> rangeFilterFilterListToJson(
    List<enums.RangeFilterFilter>? rangeFilterFilter) {
  if (rangeFilterFilter == null) {
    return [];
  }

  return rangeFilterFilter.map((e) => e.value!).toList();
}

List<enums.RangeFilterFilter> rangeFilterFilterListFromJson(
  List? rangeFilterFilter, [
  List<enums.RangeFilterFilter>? defaultValue,
]) {
  if (rangeFilterFilter == null) {
    return defaultValue ?? [];
  }

  return rangeFilterFilter
      .map((e) => rangeFilterFilterFromJson(e.toString()))
      .toList();
}

List<enums.RangeFilterFilter>? rangeFilterFilterNullableListFromJson(
  List? rangeFilterFilter, [
  List<enums.RangeFilterFilter>? defaultValue,
]) {
  if (rangeFilterFilter == null) {
    return defaultValue;
  }

  return rangeFilterFilter
      .map((e) => rangeFilterFilterFromJson(e.toString()))
      .toList();
}

String? cleanReqTypeNullableToJson(enums.CleanReqType? cleanReqType) {
  return cleanReqType?.value;
}

String? cleanReqTypeToJson(enums.CleanReqType cleanReqType) {
  return cleanReqType.value;
}

enums.CleanReqType cleanReqTypeFromJson(
  Object? cleanReqType, [
  enums.CleanReqType? defaultValue,
]) {
  return enums.CleanReqType.values
          .firstWhereOrNull((e) => e.value == cleanReqType) ??
      defaultValue ??
      enums.CleanReqType.swaggerGeneratedUnknown;
}

enums.CleanReqType? cleanReqTypeNullableFromJson(
  Object? cleanReqType, [
  enums.CleanReqType? defaultValue,
]) {
  if (cleanReqType == null) {
    return null;
  }
  return enums.CleanReqType.values
          .firstWhereOrNull((e) => e.value == cleanReqType) ??
      defaultValue;
}

String cleanReqTypeExplodedListToJson(List<enums.CleanReqType>? cleanReqType) {
  return cleanReqType?.map((e) => e.value!).join(',') ?? '';
}

List<String> cleanReqTypeListToJson(List<enums.CleanReqType>? cleanReqType) {
  if (cleanReqType == null) {
    return [];
  }

  return cleanReqType.map((e) => e.value!).toList();
}

List<enums.CleanReqType> cleanReqTypeListFromJson(
  List? cleanReqType, [
  List<enums.CleanReqType>? defaultValue,
]) {
  if (cleanReqType == null) {
    return defaultValue ?? [];
  }

  return cleanReqType.map((e) => cleanReqTypeFromJson(e.toString())).toList();
}

List<enums.CleanReqType>? cleanReqTypeNullableListFromJson(
  List? cleanReqType, [
  List<enums.CleanReqType>? defaultValue,
]) {
  if (cleanReqType == null) {
    return defaultValue;
  }

  return cleanReqType.map((e) => cleanReqTypeFromJson(e.toString())).toList();
}

String? parameterParameterTypeNullableToJson(
    enums.ParameterParameterType? parameterParameterType) {
  return parameterParameterType?.value;
}

String? parameterParameterTypeToJson(
    enums.ParameterParameterType parameterParameterType) {
  return parameterParameterType.value;
}

enums.ParameterParameterType parameterParameterTypeFromJson(
  Object? parameterParameterType, [
  enums.ParameterParameterType? defaultValue,
]) {
  return enums.ParameterParameterType.values
          .firstWhereOrNull((e) => e.value == parameterParameterType) ??
      defaultValue ??
      enums.ParameterParameterType.swaggerGeneratedUnknown;
}

enums.ParameterParameterType? parameterParameterTypeNullableFromJson(
  Object? parameterParameterType, [
  enums.ParameterParameterType? defaultValue,
]) {
  if (parameterParameterType == null) {
    return null;
  }
  return enums.ParameterParameterType.values
          .firstWhereOrNull((e) => e.value == parameterParameterType) ??
      defaultValue;
}

String parameterParameterTypeExplodedListToJson(
    List<enums.ParameterParameterType>? parameterParameterType) {
  return parameterParameterType?.map((e) => e.value!).join(',') ?? '';
}

List<String> parameterParameterTypeListToJson(
    List<enums.ParameterParameterType>? parameterParameterType) {
  if (parameterParameterType == null) {
    return [];
  }

  return parameterParameterType.map((e) => e.value!).toList();
}

List<enums.ParameterParameterType> parameterParameterTypeListFromJson(
  List? parameterParameterType, [
  List<enums.ParameterParameterType>? defaultValue,
]) {
  if (parameterParameterType == null) {
    return defaultValue ?? [];
  }

  return parameterParameterType
      .map((e) => parameterParameterTypeFromJson(e.toString()))
      .toList();
}

List<enums.ParameterParameterType>? parameterParameterTypeNullableListFromJson(
  List? parameterParameterType, [
  List<enums.ParameterParameterType>? defaultValue,
]) {
  if (parameterParameterType == null) {
    return defaultValue;
  }

  return parameterParameterType
      .map((e) => parameterParameterTypeFromJson(e.toString()))
      .toList();
}

String? conditionInfoConditionNullableToJson(
    enums.ConditionInfoCondition? conditionInfoCondition) {
  return conditionInfoCondition?.value;
}

String? conditionInfoConditionToJson(
    enums.ConditionInfoCondition conditionInfoCondition) {
  return conditionInfoCondition.value;
}

enums.ConditionInfoCondition conditionInfoConditionFromJson(
  Object? conditionInfoCondition, [
  enums.ConditionInfoCondition? defaultValue,
]) {
  return enums.ConditionInfoCondition.values
          .firstWhereOrNull((e) => e.value == conditionInfoCondition) ??
      defaultValue ??
      enums.ConditionInfoCondition.swaggerGeneratedUnknown;
}

enums.ConditionInfoCondition? conditionInfoConditionNullableFromJson(
  Object? conditionInfoCondition, [
  enums.ConditionInfoCondition? defaultValue,
]) {
  if (conditionInfoCondition == null) {
    return null;
  }
  return enums.ConditionInfoCondition.values
          .firstWhereOrNull((e) => e.value == conditionInfoCondition) ??
      defaultValue;
}

String conditionInfoConditionExplodedListToJson(
    List<enums.ConditionInfoCondition>? conditionInfoCondition) {
  return conditionInfoCondition?.map((e) => e.value!).join(',') ?? '';
}

List<String> conditionInfoConditionListToJson(
    List<enums.ConditionInfoCondition>? conditionInfoCondition) {
  if (conditionInfoCondition == null) {
    return [];
  }

  return conditionInfoCondition.map((e) => e.value!).toList();
}

List<enums.ConditionInfoCondition> conditionInfoConditionListFromJson(
  List? conditionInfoCondition, [
  List<enums.ConditionInfoCondition>? defaultValue,
]) {
  if (conditionInfoCondition == null) {
    return defaultValue ?? [];
  }

  return conditionInfoCondition
      .map((e) => conditionInfoConditionFromJson(e.toString()))
      .toList();
}

List<enums.ConditionInfoCondition>? conditionInfoConditionNullableListFromJson(
  List? conditionInfoCondition, [
  List<enums.ConditionInfoCondition>? defaultValue,
]) {
  if (conditionInfoCondition == null) {
    return defaultValue;
  }

  return conditionInfoCondition
      .map((e) => conditionInfoConditionFromJson(e.toString()))
      .toList();
}

String? conditionConditionNullableToJson(
    enums.ConditionCondition? conditionCondition) {
  return conditionCondition?.value;
}

String? conditionConditionToJson(enums.ConditionCondition conditionCondition) {
  return conditionCondition.value;
}

enums.ConditionCondition conditionConditionFromJson(
  Object? conditionCondition, [
  enums.ConditionCondition? defaultValue,
]) {
  return enums.ConditionCondition.values
          .firstWhereOrNull((e) => e.value == conditionCondition) ??
      defaultValue ??
      enums.ConditionCondition.swaggerGeneratedUnknown;
}

enums.ConditionCondition? conditionConditionNullableFromJson(
  Object? conditionCondition, [
  enums.ConditionCondition? defaultValue,
]) {
  if (conditionCondition == null) {
    return null;
  }
  return enums.ConditionCondition.values
          .firstWhereOrNull((e) => e.value == conditionCondition) ??
      defaultValue;
}

String conditionConditionExplodedListToJson(
    List<enums.ConditionCondition>? conditionCondition) {
  return conditionCondition?.map((e) => e.value!).join(',') ?? '';
}

List<String> conditionConditionListToJson(
    List<enums.ConditionCondition>? conditionCondition) {
  if (conditionCondition == null) {
    return [];
  }

  return conditionCondition.map((e) => e.value!).toList();
}

List<enums.ConditionCondition> conditionConditionListFromJson(
  List? conditionCondition, [
  List<enums.ConditionCondition>? defaultValue,
]) {
  if (conditionCondition == null) {
    return defaultValue ?? [];
  }

  return conditionCondition
      .map((e) => conditionConditionFromJson(e.toString()))
      .toList();
}

List<enums.ConditionCondition>? conditionConditionNullableListFromJson(
  List? conditionCondition, [
  List<enums.ConditionCondition>? defaultValue,
]) {
  if (conditionCondition == null) {
    return defaultValue;
  }

  return conditionCondition
      .map((e) => conditionConditionFromJson(e.toString()))
      .toList();
}

String? matchGroupMatchTypeNullableToJson(
    enums.MatchGroupMatchType? matchGroupMatchType) {
  return matchGroupMatchType?.value;
}

String? matchGroupMatchTypeToJson(
    enums.MatchGroupMatchType matchGroupMatchType) {
  return matchGroupMatchType.value;
}

enums.MatchGroupMatchType matchGroupMatchTypeFromJson(
  Object? matchGroupMatchType, [
  enums.MatchGroupMatchType? defaultValue,
]) {
  return enums.MatchGroupMatchType.values
          .firstWhereOrNull((e) => e.value == matchGroupMatchType) ??
      defaultValue ??
      enums.MatchGroupMatchType.swaggerGeneratedUnknown;
}

enums.MatchGroupMatchType? matchGroupMatchTypeNullableFromJson(
  Object? matchGroupMatchType, [
  enums.MatchGroupMatchType? defaultValue,
]) {
  if (matchGroupMatchType == null) {
    return null;
  }
  return enums.MatchGroupMatchType.values
          .firstWhereOrNull((e) => e.value == matchGroupMatchType) ??
      defaultValue;
}

String matchGroupMatchTypeExplodedListToJson(
    List<enums.MatchGroupMatchType>? matchGroupMatchType) {
  return matchGroupMatchType?.map((e) => e.value!).join(',') ?? '';
}

List<String> matchGroupMatchTypeListToJson(
    List<enums.MatchGroupMatchType>? matchGroupMatchType) {
  if (matchGroupMatchType == null) {
    return [];
  }

  return matchGroupMatchType.map((e) => e.value!).toList();
}

List<enums.MatchGroupMatchType> matchGroupMatchTypeListFromJson(
  List? matchGroupMatchType, [
  List<enums.MatchGroupMatchType>? defaultValue,
]) {
  if (matchGroupMatchType == null) {
    return defaultValue ?? [];
  }

  return matchGroupMatchType
      .map((e) => matchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

List<enums.MatchGroupMatchType>? matchGroupMatchTypeNullableListFromJson(
  List? matchGroupMatchType, [
  List<enums.MatchGroupMatchType>? defaultValue,
]) {
  if (matchGroupMatchType == null) {
    return defaultValue;
  }

  return matchGroupMatchType
      .map((e) => matchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

String? alarmMatchGroupMatchTypeNullableToJson(
    enums.AlarmMatchGroupMatchType? alarmMatchGroupMatchType) {
  return alarmMatchGroupMatchType?.value;
}

String? alarmMatchGroupMatchTypeToJson(
    enums.AlarmMatchGroupMatchType alarmMatchGroupMatchType) {
  return alarmMatchGroupMatchType.value;
}

enums.AlarmMatchGroupMatchType alarmMatchGroupMatchTypeFromJson(
  Object? alarmMatchGroupMatchType, [
  enums.AlarmMatchGroupMatchType? defaultValue,
]) {
  return enums.AlarmMatchGroupMatchType.values
          .firstWhereOrNull((e) => e.value == alarmMatchGroupMatchType) ??
      defaultValue ??
      enums.AlarmMatchGroupMatchType.swaggerGeneratedUnknown;
}

enums.AlarmMatchGroupMatchType? alarmMatchGroupMatchTypeNullableFromJson(
  Object? alarmMatchGroupMatchType, [
  enums.AlarmMatchGroupMatchType? defaultValue,
]) {
  if (alarmMatchGroupMatchType == null) {
    return null;
  }
  return enums.AlarmMatchGroupMatchType.values
          .firstWhereOrNull((e) => e.value == alarmMatchGroupMatchType) ??
      defaultValue;
}

String alarmMatchGroupMatchTypeExplodedListToJson(
    List<enums.AlarmMatchGroupMatchType>? alarmMatchGroupMatchType) {
  return alarmMatchGroupMatchType?.map((e) => e.value!).join(',') ?? '';
}

List<String> alarmMatchGroupMatchTypeListToJson(
    List<enums.AlarmMatchGroupMatchType>? alarmMatchGroupMatchType) {
  if (alarmMatchGroupMatchType == null) {
    return [];
  }

  return alarmMatchGroupMatchType.map((e) => e.value!).toList();
}

List<enums.AlarmMatchGroupMatchType> alarmMatchGroupMatchTypeListFromJson(
  List? alarmMatchGroupMatchType, [
  List<enums.AlarmMatchGroupMatchType>? defaultValue,
]) {
  if (alarmMatchGroupMatchType == null) {
    return defaultValue ?? [];
  }

  return alarmMatchGroupMatchType
      .map((e) => alarmMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

List<enums.AlarmMatchGroupMatchType>?
    alarmMatchGroupMatchTypeNullableListFromJson(
  List? alarmMatchGroupMatchType, [
  List<enums.AlarmMatchGroupMatchType>? defaultValue,
]) {
  if (alarmMatchGroupMatchType == null) {
    return defaultValue;
  }

  return alarmMatchGroupMatchType
      .map((e) => alarmMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

String? controlCommandTypeNullableToJson(
    enums.ControlCommandType? controlCommandType) {
  return controlCommandType?.value;
}

String? controlCommandTypeToJson(enums.ControlCommandType controlCommandType) {
  return controlCommandType.value;
}

enums.ControlCommandType controlCommandTypeFromJson(
  Object? controlCommandType, [
  enums.ControlCommandType? defaultValue,
]) {
  return enums.ControlCommandType.values
          .firstWhereOrNull((e) => e.value == controlCommandType) ??
      defaultValue ??
      enums.ControlCommandType.swaggerGeneratedUnknown;
}

enums.ControlCommandType? controlCommandTypeNullableFromJson(
  Object? controlCommandType, [
  enums.ControlCommandType? defaultValue,
]) {
  if (controlCommandType == null) {
    return null;
  }
  return enums.ControlCommandType.values
          .firstWhereOrNull((e) => e.value == controlCommandType) ??
      defaultValue;
}

String controlCommandTypeExplodedListToJson(
    List<enums.ControlCommandType>? controlCommandType) {
  return controlCommandType?.map((e) => e.value!).join(',') ?? '';
}

List<String> controlCommandTypeListToJson(
    List<enums.ControlCommandType>? controlCommandType) {
  if (controlCommandType == null) {
    return [];
  }

  return controlCommandType.map((e) => e.value!).toList();
}

List<enums.ControlCommandType> controlCommandTypeListFromJson(
  List? controlCommandType, [
  List<enums.ControlCommandType>? defaultValue,
]) {
  if (controlCommandType == null) {
    return defaultValue ?? [];
  }

  return controlCommandType
      .map((e) => controlCommandTypeFromJson(e.toString()))
      .toList();
}

List<enums.ControlCommandType>? controlCommandTypeNullableListFromJson(
  List? controlCommandType, [
  List<enums.ControlCommandType>? defaultValue,
]) {
  if (controlCommandType == null) {
    return defaultValue;
  }

  return controlCommandType
      .map((e) => controlCommandTypeFromJson(e.toString()))
      .toList();
}

String? controlCommandFixedTypeNullableToJson(
    enums.ControlCommandFixedType? controlCommandFixedType) {
  return controlCommandFixedType?.value;
}

String? controlCommandFixedTypeToJson(
    enums.ControlCommandFixedType controlCommandFixedType) {
  return controlCommandFixedType.value;
}

enums.ControlCommandFixedType controlCommandFixedTypeFromJson(
  Object? controlCommandFixedType, [
  enums.ControlCommandFixedType? defaultValue,
]) {
  return enums.ControlCommandFixedType.values
          .firstWhereOrNull((e) => e.value == controlCommandFixedType) ??
      defaultValue ??
      enums.ControlCommandFixedType.swaggerGeneratedUnknown;
}

enums.ControlCommandFixedType? controlCommandFixedTypeNullableFromJson(
  Object? controlCommandFixedType, [
  enums.ControlCommandFixedType? defaultValue,
]) {
  if (controlCommandFixedType == null) {
    return null;
  }
  return enums.ControlCommandFixedType.values
          .firstWhereOrNull((e) => e.value == controlCommandFixedType) ??
      defaultValue;
}

String controlCommandFixedTypeExplodedListToJson(
    List<enums.ControlCommandFixedType>? controlCommandFixedType) {
  return controlCommandFixedType?.map((e) => e.value!).join(',') ?? '';
}

List<String> controlCommandFixedTypeListToJson(
    List<enums.ControlCommandFixedType>? controlCommandFixedType) {
  if (controlCommandFixedType == null) {
    return [];
  }

  return controlCommandFixedType.map((e) => e.value!).toList();
}

List<enums.ControlCommandFixedType> controlCommandFixedTypeListFromJson(
  List? controlCommandFixedType, [
  List<enums.ControlCommandFixedType>? defaultValue,
]) {
  if (controlCommandFixedType == null) {
    return defaultValue ?? [];
  }

  return controlCommandFixedType
      .map((e) => controlCommandFixedTypeFromJson(e.toString()))
      .toList();
}

List<enums.ControlCommandFixedType>?
    controlCommandFixedTypeNullableListFromJson(
  List? controlCommandFixedType, [
  List<enums.ControlCommandFixedType>? defaultValue,
]) {
  if (controlCommandFixedType == null) {
    return defaultValue;
  }

  return controlCommandFixedType
      .map((e) => controlCommandFixedTypeFromJson(e.toString()))
      .toList();
}

String? httpConfigProtocolNullableToJson(
    enums.HttpConfigProtocol? httpConfigProtocol) {
  return httpConfigProtocol?.value;
}

String? httpConfigProtocolToJson(enums.HttpConfigProtocol httpConfigProtocol) {
  return httpConfigProtocol.value;
}

enums.HttpConfigProtocol httpConfigProtocolFromJson(
  Object? httpConfigProtocol, [
  enums.HttpConfigProtocol? defaultValue,
]) {
  return enums.HttpConfigProtocol.values
          .firstWhereOrNull((e) => e.value == httpConfigProtocol) ??
      defaultValue ??
      enums.HttpConfigProtocol.swaggerGeneratedUnknown;
}

enums.HttpConfigProtocol? httpConfigProtocolNullableFromJson(
  Object? httpConfigProtocol, [
  enums.HttpConfigProtocol? defaultValue,
]) {
  if (httpConfigProtocol == null) {
    return null;
  }
  return enums.HttpConfigProtocol.values
          .firstWhereOrNull((e) => e.value == httpConfigProtocol) ??
      defaultValue;
}

String httpConfigProtocolExplodedListToJson(
    List<enums.HttpConfigProtocol>? httpConfigProtocol) {
  return httpConfigProtocol?.map((e) => e.value!).join(',') ?? '';
}

List<String> httpConfigProtocolListToJson(
    List<enums.HttpConfigProtocol>? httpConfigProtocol) {
  if (httpConfigProtocol == null) {
    return [];
  }

  return httpConfigProtocol.map((e) => e.value!).toList();
}

List<enums.HttpConfigProtocol> httpConfigProtocolListFromJson(
  List? httpConfigProtocol, [
  List<enums.HttpConfigProtocol>? defaultValue,
]) {
  if (httpConfigProtocol == null) {
    return defaultValue ?? [];
  }

  return httpConfigProtocol
      .map((e) => httpConfigProtocolFromJson(e.toString()))
      .toList();
}

List<enums.HttpConfigProtocol>? httpConfigProtocolNullableListFromJson(
  List? httpConfigProtocol, [
  List<enums.HttpConfigProtocol>? defaultValue,
]) {
  if (httpConfigProtocol == null) {
    return defaultValue;
  }

  return httpConfigProtocol
      .map((e) => httpConfigProtocolFromJson(e.toString()))
      .toList();
}

String? triggerControlTriggerTargetNullableToJson(
    enums.TriggerControlTriggerTarget? triggerControlTriggerTarget) {
  return triggerControlTriggerTarget?.value;
}

String? triggerControlTriggerTargetToJson(
    enums.TriggerControlTriggerTarget triggerControlTriggerTarget) {
  return triggerControlTriggerTarget.value;
}

enums.TriggerControlTriggerTarget triggerControlTriggerTargetFromJson(
  Object? triggerControlTriggerTarget, [
  enums.TriggerControlTriggerTarget? defaultValue,
]) {
  return enums.TriggerControlTriggerTarget.values
          .firstWhereOrNull((e) => e.value == triggerControlTriggerTarget) ??
      defaultValue ??
      enums.TriggerControlTriggerTarget.swaggerGeneratedUnknown;
}

enums.TriggerControlTriggerTarget? triggerControlTriggerTargetNullableFromJson(
  Object? triggerControlTriggerTarget, [
  enums.TriggerControlTriggerTarget? defaultValue,
]) {
  if (triggerControlTriggerTarget == null) {
    return null;
  }
  return enums.TriggerControlTriggerTarget.values
          .firstWhereOrNull((e) => e.value == triggerControlTriggerTarget) ??
      defaultValue;
}

String triggerControlTriggerTargetExplodedListToJson(
    List<enums.TriggerControlTriggerTarget>? triggerControlTriggerTarget) {
  return triggerControlTriggerTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggerControlTriggerTargetListToJson(
    List<enums.TriggerControlTriggerTarget>? triggerControlTriggerTarget) {
  if (triggerControlTriggerTarget == null) {
    return [];
  }

  return triggerControlTriggerTarget.map((e) => e.value!).toList();
}

List<enums.TriggerControlTriggerTarget> triggerControlTriggerTargetListFromJson(
  List? triggerControlTriggerTarget, [
  List<enums.TriggerControlTriggerTarget>? defaultValue,
]) {
  if (triggerControlTriggerTarget == null) {
    return defaultValue ?? [];
  }

  return triggerControlTriggerTarget
      .map((e) => triggerControlTriggerTargetFromJson(e.toString()))
      .toList();
}

List<enums.TriggerControlTriggerTarget>?
    triggerControlTriggerTargetNullableListFromJson(
  List? triggerControlTriggerTarget, [
  List<enums.TriggerControlTriggerTarget>? defaultValue,
]) {
  if (triggerControlTriggerTarget == null) {
    return defaultValue;
  }

  return triggerControlTriggerTarget
      .map((e) => triggerControlTriggerTargetFromJson(e.toString()))
      .toList();
}

String? triggerControlTriggerTypeNullableToJson(
    enums.TriggerControlTriggerType? triggerControlTriggerType) {
  return triggerControlTriggerType?.value;
}

String? triggerControlTriggerTypeToJson(
    enums.TriggerControlTriggerType triggerControlTriggerType) {
  return triggerControlTriggerType.value;
}

enums.TriggerControlTriggerType triggerControlTriggerTypeFromJson(
  Object? triggerControlTriggerType, [
  enums.TriggerControlTriggerType? defaultValue,
]) {
  return enums.TriggerControlTriggerType.values
          .firstWhereOrNull((e) => e.value == triggerControlTriggerType) ??
      defaultValue ??
      enums.TriggerControlTriggerType.swaggerGeneratedUnknown;
}

enums.TriggerControlTriggerType? triggerControlTriggerTypeNullableFromJson(
  Object? triggerControlTriggerType, [
  enums.TriggerControlTriggerType? defaultValue,
]) {
  if (triggerControlTriggerType == null) {
    return null;
  }
  return enums.TriggerControlTriggerType.values
          .firstWhereOrNull((e) => e.value == triggerControlTriggerType) ??
      defaultValue;
}

String triggerControlTriggerTypeExplodedListToJson(
    List<enums.TriggerControlTriggerType>? triggerControlTriggerType) {
  return triggerControlTriggerType?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggerControlTriggerTypeListToJson(
    List<enums.TriggerControlTriggerType>? triggerControlTriggerType) {
  if (triggerControlTriggerType == null) {
    return [];
  }

  return triggerControlTriggerType.map((e) => e.value!).toList();
}

List<enums.TriggerControlTriggerType> triggerControlTriggerTypeListFromJson(
  List? triggerControlTriggerType, [
  List<enums.TriggerControlTriggerType>? defaultValue,
]) {
  if (triggerControlTriggerType == null) {
    return defaultValue ?? [];
  }

  return triggerControlTriggerType
      .map((e) => triggerControlTriggerTypeFromJson(e.toString()))
      .toList();
}

List<enums.TriggerControlTriggerType>?
    triggerControlTriggerTypeNullableListFromJson(
  List? triggerControlTriggerType, [
  List<enums.TriggerControlTriggerType>? defaultValue,
]) {
  if (triggerControlTriggerType == null) {
    return defaultValue;
  }

  return triggerControlTriggerType
      .map((e) => triggerControlTriggerTypeFromJson(e.toString()))
      .toList();
}

String? triggerControlDeliveryTargetNullableToJson(
    enums.TriggerControlDeliveryTarget? triggerControlDeliveryTarget) {
  return triggerControlDeliveryTarget?.value;
}

String? triggerControlDeliveryTargetToJson(
    enums.TriggerControlDeliveryTarget triggerControlDeliveryTarget) {
  return triggerControlDeliveryTarget.value;
}

enums.TriggerControlDeliveryTarget triggerControlDeliveryTargetFromJson(
  Object? triggerControlDeliveryTarget, [
  enums.TriggerControlDeliveryTarget? defaultValue,
]) {
  return enums.TriggerControlDeliveryTarget.values
          .firstWhereOrNull((e) => e.value == triggerControlDeliveryTarget) ??
      defaultValue ??
      enums.TriggerControlDeliveryTarget.swaggerGeneratedUnknown;
}

enums.TriggerControlDeliveryTarget?
    triggerControlDeliveryTargetNullableFromJson(
  Object? triggerControlDeliveryTarget, [
  enums.TriggerControlDeliveryTarget? defaultValue,
]) {
  if (triggerControlDeliveryTarget == null) {
    return null;
  }
  return enums.TriggerControlDeliveryTarget.values
          .firstWhereOrNull((e) => e.value == triggerControlDeliveryTarget) ??
      defaultValue;
}

String triggerControlDeliveryTargetExplodedListToJson(
    List<enums.TriggerControlDeliveryTarget>? triggerControlDeliveryTarget) {
  return triggerControlDeliveryTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggerControlDeliveryTargetListToJson(
    List<enums.TriggerControlDeliveryTarget>? triggerControlDeliveryTarget) {
  if (triggerControlDeliveryTarget == null) {
    return [];
  }

  return triggerControlDeliveryTarget.map((e) => e.value!).toList();
}

List<enums.TriggerControlDeliveryTarget>
    triggerControlDeliveryTargetListFromJson(
  List? triggerControlDeliveryTarget, [
  List<enums.TriggerControlDeliveryTarget>? defaultValue,
]) {
  if (triggerControlDeliveryTarget == null) {
    return defaultValue ?? [];
  }

  return triggerControlDeliveryTarget
      .map((e) => triggerControlDeliveryTargetFromJson(e.toString()))
      .toList();
}

List<enums.TriggerControlDeliveryTarget>?
    triggerControlDeliveryTargetNullableListFromJson(
  List? triggerControlDeliveryTarget, [
  List<enums.TriggerControlDeliveryTarget>? defaultValue,
]) {
  if (triggerControlDeliveryTarget == null) {
    return defaultValue;
  }

  return triggerControlDeliveryTarget
      .map((e) => triggerControlDeliveryTargetFromJson(e.toString()))
      .toList();
}

String? imageFileInfoImageTypeNullableToJson(
    enums.ImageFileInfoImageType? imageFileInfoImageType) {
  return imageFileInfoImageType?.value;
}

String? imageFileInfoImageTypeToJson(
    enums.ImageFileInfoImageType imageFileInfoImageType) {
  return imageFileInfoImageType.value;
}

enums.ImageFileInfoImageType imageFileInfoImageTypeFromJson(
  Object? imageFileInfoImageType, [
  enums.ImageFileInfoImageType? defaultValue,
]) {
  return enums.ImageFileInfoImageType.values
          .firstWhereOrNull((e) => e.value == imageFileInfoImageType) ??
      defaultValue ??
      enums.ImageFileInfoImageType.swaggerGeneratedUnknown;
}

enums.ImageFileInfoImageType? imageFileInfoImageTypeNullableFromJson(
  Object? imageFileInfoImageType, [
  enums.ImageFileInfoImageType? defaultValue,
]) {
  if (imageFileInfoImageType == null) {
    return null;
  }
  return enums.ImageFileInfoImageType.values
          .firstWhereOrNull((e) => e.value == imageFileInfoImageType) ??
      defaultValue;
}

String imageFileInfoImageTypeExplodedListToJson(
    List<enums.ImageFileInfoImageType>? imageFileInfoImageType) {
  return imageFileInfoImageType?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageFileInfoImageTypeListToJson(
    List<enums.ImageFileInfoImageType>? imageFileInfoImageType) {
  if (imageFileInfoImageType == null) {
    return [];
  }

  return imageFileInfoImageType.map((e) => e.value!).toList();
}

List<enums.ImageFileInfoImageType> imageFileInfoImageTypeListFromJson(
  List? imageFileInfoImageType, [
  List<enums.ImageFileInfoImageType>? defaultValue,
]) {
  if (imageFileInfoImageType == null) {
    return defaultValue ?? [];
  }

  return imageFileInfoImageType
      .map((e) => imageFileInfoImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.ImageFileInfoImageType>? imageFileInfoImageTypeNullableListFromJson(
  List? imageFileInfoImageType, [
  List<enums.ImageFileInfoImageType>? defaultValue,
]) {
  if (imageFileInfoImageType == null) {
    return defaultValue;
  }

  return imageFileInfoImageType
      .map((e) => imageFileInfoImageTypeFromJson(e.toString()))
      .toList();
}

String? imageFileInfoImageTargetNullableToJson(
    enums.ImageFileInfoImageTarget? imageFileInfoImageTarget) {
  return imageFileInfoImageTarget?.value;
}

String? imageFileInfoImageTargetToJson(
    enums.ImageFileInfoImageTarget imageFileInfoImageTarget) {
  return imageFileInfoImageTarget.value;
}

enums.ImageFileInfoImageTarget imageFileInfoImageTargetFromJson(
  Object? imageFileInfoImageTarget, [
  enums.ImageFileInfoImageTarget? defaultValue,
]) {
  return enums.ImageFileInfoImageTarget.values
          .firstWhereOrNull((e) => e.value == imageFileInfoImageTarget) ??
      defaultValue ??
      enums.ImageFileInfoImageTarget.swaggerGeneratedUnknown;
}

enums.ImageFileInfoImageTarget? imageFileInfoImageTargetNullableFromJson(
  Object? imageFileInfoImageTarget, [
  enums.ImageFileInfoImageTarget? defaultValue,
]) {
  if (imageFileInfoImageTarget == null) {
    return null;
  }
  return enums.ImageFileInfoImageTarget.values
          .firstWhereOrNull((e) => e.value == imageFileInfoImageTarget) ??
      defaultValue;
}

String imageFileInfoImageTargetExplodedListToJson(
    List<enums.ImageFileInfoImageTarget>? imageFileInfoImageTarget) {
  return imageFileInfoImageTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageFileInfoImageTargetListToJson(
    List<enums.ImageFileInfoImageTarget>? imageFileInfoImageTarget) {
  if (imageFileInfoImageTarget == null) {
    return [];
  }

  return imageFileInfoImageTarget.map((e) => e.value!).toList();
}

List<enums.ImageFileInfoImageTarget> imageFileInfoImageTargetListFromJson(
  List? imageFileInfoImageTarget, [
  List<enums.ImageFileInfoImageTarget>? defaultValue,
]) {
  if (imageFileInfoImageTarget == null) {
    return defaultValue ?? [];
  }

  return imageFileInfoImageTarget
      .map((e) => imageFileInfoImageTargetFromJson(e.toString()))
      .toList();
}

List<enums.ImageFileInfoImageTarget>?
    imageFileInfoImageTargetNullableListFromJson(
  List? imageFileInfoImageTarget, [
  List<enums.ImageFileInfoImageTarget>? defaultValue,
]) {
  if (imageFileInfoImageTarget == null) {
    return defaultValue;
  }

  return imageFileInfoImageTarget
      .map((e) => imageFileInfoImageTargetFromJson(e.toString()))
      .toList();
}

String? imageFileImageTypeNullableToJson(
    enums.ImageFileImageType? imageFileImageType) {
  return imageFileImageType?.value;
}

String? imageFileImageTypeToJson(enums.ImageFileImageType imageFileImageType) {
  return imageFileImageType.value;
}

enums.ImageFileImageType imageFileImageTypeFromJson(
  Object? imageFileImageType, [
  enums.ImageFileImageType? defaultValue,
]) {
  return enums.ImageFileImageType.values
          .firstWhereOrNull((e) => e.value == imageFileImageType) ??
      defaultValue ??
      enums.ImageFileImageType.swaggerGeneratedUnknown;
}

enums.ImageFileImageType? imageFileImageTypeNullableFromJson(
  Object? imageFileImageType, [
  enums.ImageFileImageType? defaultValue,
]) {
  if (imageFileImageType == null) {
    return null;
  }
  return enums.ImageFileImageType.values
          .firstWhereOrNull((e) => e.value == imageFileImageType) ??
      defaultValue;
}

String imageFileImageTypeExplodedListToJson(
    List<enums.ImageFileImageType>? imageFileImageType) {
  return imageFileImageType?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageFileImageTypeListToJson(
    List<enums.ImageFileImageType>? imageFileImageType) {
  if (imageFileImageType == null) {
    return [];
  }

  return imageFileImageType.map((e) => e.value!).toList();
}

List<enums.ImageFileImageType> imageFileImageTypeListFromJson(
  List? imageFileImageType, [
  List<enums.ImageFileImageType>? defaultValue,
]) {
  if (imageFileImageType == null) {
    return defaultValue ?? [];
  }

  return imageFileImageType
      .map((e) => imageFileImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.ImageFileImageType>? imageFileImageTypeNullableListFromJson(
  List? imageFileImageType, [
  List<enums.ImageFileImageType>? defaultValue,
]) {
  if (imageFileImageType == null) {
    return defaultValue;
  }

  return imageFileImageType
      .map((e) => imageFileImageTypeFromJson(e.toString()))
      .toList();
}

String? imageFileImageTargetNullableToJson(
    enums.ImageFileImageTarget? imageFileImageTarget) {
  return imageFileImageTarget?.value;
}

String? imageFileImageTargetToJson(
    enums.ImageFileImageTarget imageFileImageTarget) {
  return imageFileImageTarget.value;
}

enums.ImageFileImageTarget imageFileImageTargetFromJson(
  Object? imageFileImageTarget, [
  enums.ImageFileImageTarget? defaultValue,
]) {
  return enums.ImageFileImageTarget.values
          .firstWhereOrNull((e) => e.value == imageFileImageTarget) ??
      defaultValue ??
      enums.ImageFileImageTarget.swaggerGeneratedUnknown;
}

enums.ImageFileImageTarget? imageFileImageTargetNullableFromJson(
  Object? imageFileImageTarget, [
  enums.ImageFileImageTarget? defaultValue,
]) {
  if (imageFileImageTarget == null) {
    return null;
  }
  return enums.ImageFileImageTarget.values
          .firstWhereOrNull((e) => e.value == imageFileImageTarget) ??
      defaultValue;
}

String imageFileImageTargetExplodedListToJson(
    List<enums.ImageFileImageTarget>? imageFileImageTarget) {
  return imageFileImageTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageFileImageTargetListToJson(
    List<enums.ImageFileImageTarget>? imageFileImageTarget) {
  if (imageFileImageTarget == null) {
    return [];
  }

  return imageFileImageTarget.map((e) => e.value!).toList();
}

List<enums.ImageFileImageTarget> imageFileImageTargetListFromJson(
  List? imageFileImageTarget, [
  List<enums.ImageFileImageTarget>? defaultValue,
]) {
  if (imageFileImageTarget == null) {
    return defaultValue ?? [];
  }

  return imageFileImageTarget
      .map((e) => imageFileImageTargetFromJson(e.toString()))
      .toList();
}

List<enums.ImageFileImageTarget>? imageFileImageTargetNullableListFromJson(
  List? imageFileImageTarget, [
  List<enums.ImageFileImageTarget>? defaultValue,
]) {
  if (imageFileImageTarget == null) {
    return defaultValue;
  }

  return imageFileImageTarget
      .map((e) => imageFileImageTargetFromJson(e.toString()))
      .toList();
}

String? displayMatchGroupMatchTypeNullableToJson(
    enums.DisplayMatchGroupMatchType? displayMatchGroupMatchType) {
  return displayMatchGroupMatchType?.value;
}

String? displayMatchGroupMatchTypeToJson(
    enums.DisplayMatchGroupMatchType displayMatchGroupMatchType) {
  return displayMatchGroupMatchType.value;
}

enums.DisplayMatchGroupMatchType displayMatchGroupMatchTypeFromJson(
  Object? displayMatchGroupMatchType, [
  enums.DisplayMatchGroupMatchType? defaultValue,
]) {
  return enums.DisplayMatchGroupMatchType.values
          .firstWhereOrNull((e) => e.value == displayMatchGroupMatchType) ??
      defaultValue ??
      enums.DisplayMatchGroupMatchType.swaggerGeneratedUnknown;
}

enums.DisplayMatchGroupMatchType? displayMatchGroupMatchTypeNullableFromJson(
  Object? displayMatchGroupMatchType, [
  enums.DisplayMatchGroupMatchType? defaultValue,
]) {
  if (displayMatchGroupMatchType == null) {
    return null;
  }
  return enums.DisplayMatchGroupMatchType.values
          .firstWhereOrNull((e) => e.value == displayMatchGroupMatchType) ??
      defaultValue;
}

String displayMatchGroupMatchTypeExplodedListToJson(
    List<enums.DisplayMatchGroupMatchType>? displayMatchGroupMatchType) {
  return displayMatchGroupMatchType?.map((e) => e.value!).join(',') ?? '';
}

List<String> displayMatchGroupMatchTypeListToJson(
    List<enums.DisplayMatchGroupMatchType>? displayMatchGroupMatchType) {
  if (displayMatchGroupMatchType == null) {
    return [];
  }

  return displayMatchGroupMatchType.map((e) => e.value!).toList();
}

List<enums.DisplayMatchGroupMatchType> displayMatchGroupMatchTypeListFromJson(
  List? displayMatchGroupMatchType, [
  List<enums.DisplayMatchGroupMatchType>? defaultValue,
]) {
  if (displayMatchGroupMatchType == null) {
    return defaultValue ?? [];
  }

  return displayMatchGroupMatchType
      .map((e) => displayMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

List<enums.DisplayMatchGroupMatchType>?
    displayMatchGroupMatchTypeNullableListFromJson(
  List? displayMatchGroupMatchType, [
  List<enums.DisplayMatchGroupMatchType>? defaultValue,
]) {
  if (displayMatchGroupMatchType == null) {
    return defaultValue;
  }

  return displayMatchGroupMatchType
      .map((e) => displayMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

String? displayMatchGroupBorderTypeNullableToJson(
    enums.DisplayMatchGroupBorderType? displayMatchGroupBorderType) {
  return displayMatchGroupBorderType?.value;
}

String? displayMatchGroupBorderTypeToJson(
    enums.DisplayMatchGroupBorderType displayMatchGroupBorderType) {
  return displayMatchGroupBorderType.value;
}

enums.DisplayMatchGroupBorderType displayMatchGroupBorderTypeFromJson(
  Object? displayMatchGroupBorderType, [
  enums.DisplayMatchGroupBorderType? defaultValue,
]) {
  return enums.DisplayMatchGroupBorderType.values
          .firstWhereOrNull((e) => e.value == displayMatchGroupBorderType) ??
      defaultValue ??
      enums.DisplayMatchGroupBorderType.swaggerGeneratedUnknown;
}

enums.DisplayMatchGroupBorderType? displayMatchGroupBorderTypeNullableFromJson(
  Object? displayMatchGroupBorderType, [
  enums.DisplayMatchGroupBorderType? defaultValue,
]) {
  if (displayMatchGroupBorderType == null) {
    return null;
  }
  return enums.DisplayMatchGroupBorderType.values
          .firstWhereOrNull((e) => e.value == displayMatchGroupBorderType) ??
      defaultValue;
}

String displayMatchGroupBorderTypeExplodedListToJson(
    List<enums.DisplayMatchGroupBorderType>? displayMatchGroupBorderType) {
  return displayMatchGroupBorderType?.map((e) => e.value!).join(',') ?? '';
}

List<String> displayMatchGroupBorderTypeListToJson(
    List<enums.DisplayMatchGroupBorderType>? displayMatchGroupBorderType) {
  if (displayMatchGroupBorderType == null) {
    return [];
  }

  return displayMatchGroupBorderType.map((e) => e.value!).toList();
}

List<enums.DisplayMatchGroupBorderType> displayMatchGroupBorderTypeListFromJson(
  List? displayMatchGroupBorderType, [
  List<enums.DisplayMatchGroupBorderType>? defaultValue,
]) {
  if (displayMatchGroupBorderType == null) {
    return defaultValue ?? [];
  }

  return displayMatchGroupBorderType
      .map((e) => displayMatchGroupBorderTypeFromJson(e.toString()))
      .toList();
}

List<enums.DisplayMatchGroupBorderType>?
    displayMatchGroupBorderTypeNullableListFromJson(
  List? displayMatchGroupBorderType, [
  List<enums.DisplayMatchGroupBorderType>? defaultValue,
]) {
  if (displayMatchGroupBorderType == null) {
    return defaultValue;
  }

  return displayMatchGroupBorderType
      .map((e) => displayMatchGroupBorderTypeFromJson(e.toString()))
      .toList();
}

String? displayableTypeNullableToJson(enums.DisplayableType? displayableType) {
  return displayableType?.value;
}

String? displayableTypeToJson(enums.DisplayableType displayableType) {
  return displayableType.value;
}

enums.DisplayableType displayableTypeFromJson(
  Object? displayableType, [
  enums.DisplayableType? defaultValue,
]) {
  return enums.DisplayableType.values
          .firstWhereOrNull((e) => e.value == displayableType) ??
      defaultValue ??
      enums.DisplayableType.swaggerGeneratedUnknown;
}

enums.DisplayableType? displayableTypeNullableFromJson(
  Object? displayableType, [
  enums.DisplayableType? defaultValue,
]) {
  if (displayableType == null) {
    return null;
  }
  return enums.DisplayableType.values
          .firstWhereOrNull((e) => e.value == displayableType) ??
      defaultValue;
}

String displayableTypeExplodedListToJson(
    List<enums.DisplayableType>? displayableType) {
  return displayableType?.map((e) => e.value!).join(',') ?? '';
}

List<String> displayableTypeListToJson(
    List<enums.DisplayableType>? displayableType) {
  if (displayableType == null) {
    return [];
  }

  return displayableType.map((e) => e.value!).toList();
}

List<enums.DisplayableType> displayableTypeListFromJson(
  List? displayableType, [
  List<enums.DisplayableType>? defaultValue,
]) {
  if (displayableType == null) {
    return defaultValue ?? [];
  }

  return displayableType
      .map((e) => displayableTypeFromJson(e.toString()))
      .toList();
}

List<enums.DisplayableType>? displayableTypeNullableListFromJson(
  List? displayableType, [
  List<enums.DisplayableType>? defaultValue,
]) {
  if (displayableType == null) {
    return defaultValue;
  }

  return displayableType
      .map((e) => displayableTypeFromJson(e.toString()))
      .toList();
}

String? deviceViewInfoInfoPositionNullableToJson(
    enums.DeviceViewInfoInfoPosition? deviceViewInfoInfoPosition) {
  return deviceViewInfoInfoPosition?.value;
}

String? deviceViewInfoInfoPositionToJson(
    enums.DeviceViewInfoInfoPosition deviceViewInfoInfoPosition) {
  return deviceViewInfoInfoPosition.value;
}

enums.DeviceViewInfoInfoPosition deviceViewInfoInfoPositionFromJson(
  Object? deviceViewInfoInfoPosition, [
  enums.DeviceViewInfoInfoPosition? defaultValue,
]) {
  return enums.DeviceViewInfoInfoPosition.values
          .firstWhereOrNull((e) => e.value == deviceViewInfoInfoPosition) ??
      defaultValue ??
      enums.DeviceViewInfoInfoPosition.swaggerGeneratedUnknown;
}

enums.DeviceViewInfoInfoPosition? deviceViewInfoInfoPositionNullableFromJson(
  Object? deviceViewInfoInfoPosition, [
  enums.DeviceViewInfoInfoPosition? defaultValue,
]) {
  if (deviceViewInfoInfoPosition == null) {
    return null;
  }
  return enums.DeviceViewInfoInfoPosition.values
          .firstWhereOrNull((e) => e.value == deviceViewInfoInfoPosition) ??
      defaultValue;
}

String deviceViewInfoInfoPositionExplodedListToJson(
    List<enums.DeviceViewInfoInfoPosition>? deviceViewInfoInfoPosition) {
  return deviceViewInfoInfoPosition?.map((e) => e.value!).join(',') ?? '';
}

List<String> deviceViewInfoInfoPositionListToJson(
    List<enums.DeviceViewInfoInfoPosition>? deviceViewInfoInfoPosition) {
  if (deviceViewInfoInfoPosition == null) {
    return [];
  }

  return deviceViewInfoInfoPosition.map((e) => e.value!).toList();
}

List<enums.DeviceViewInfoInfoPosition> deviceViewInfoInfoPositionListFromJson(
  List? deviceViewInfoInfoPosition, [
  List<enums.DeviceViewInfoInfoPosition>? defaultValue,
]) {
  if (deviceViewInfoInfoPosition == null) {
    return defaultValue ?? [];
  }

  return deviceViewInfoInfoPosition
      .map((e) => deviceViewInfoInfoPositionFromJson(e.toString()))
      .toList();
}

List<enums.DeviceViewInfoInfoPosition>?
    deviceViewInfoInfoPositionNullableListFromJson(
  List? deviceViewInfoInfoPosition, [
  List<enums.DeviceViewInfoInfoPosition>? defaultValue,
]) {
  if (deviceViewInfoInfoPosition == null) {
    return defaultValue;
  }

  return deviceViewInfoInfoPosition
      .map((e) => deviceViewInfoInfoPositionFromJson(e.toString()))
      .toList();
}

String? deviceViewInfoBorderNullableToJson(
    enums.DeviceViewInfoBorder? deviceViewInfoBorder) {
  return deviceViewInfoBorder?.value;
}

String? deviceViewInfoBorderToJson(
    enums.DeviceViewInfoBorder deviceViewInfoBorder) {
  return deviceViewInfoBorder.value;
}

enums.DeviceViewInfoBorder deviceViewInfoBorderFromJson(
  Object? deviceViewInfoBorder, [
  enums.DeviceViewInfoBorder? defaultValue,
]) {
  return enums.DeviceViewInfoBorder.values
          .firstWhereOrNull((e) => e.value == deviceViewInfoBorder) ??
      defaultValue ??
      enums.DeviceViewInfoBorder.swaggerGeneratedUnknown;
}

enums.DeviceViewInfoBorder? deviceViewInfoBorderNullableFromJson(
  Object? deviceViewInfoBorder, [
  enums.DeviceViewInfoBorder? defaultValue,
]) {
  if (deviceViewInfoBorder == null) {
    return null;
  }
  return enums.DeviceViewInfoBorder.values
          .firstWhereOrNull((e) => e.value == deviceViewInfoBorder) ??
      defaultValue;
}

String deviceViewInfoBorderExplodedListToJson(
    List<enums.DeviceViewInfoBorder>? deviceViewInfoBorder) {
  return deviceViewInfoBorder?.map((e) => e.value!).join(',') ?? '';
}

List<String> deviceViewInfoBorderListToJson(
    List<enums.DeviceViewInfoBorder>? deviceViewInfoBorder) {
  if (deviceViewInfoBorder == null) {
    return [];
  }

  return deviceViewInfoBorder.map((e) => e.value!).toList();
}

List<enums.DeviceViewInfoBorder> deviceViewInfoBorderListFromJson(
  List? deviceViewInfoBorder, [
  List<enums.DeviceViewInfoBorder>? defaultValue,
]) {
  if (deviceViewInfoBorder == null) {
    return defaultValue ?? [];
  }

  return deviceViewInfoBorder
      .map((e) => deviceViewInfoBorderFromJson(e.toString()))
      .toList();
}

List<enums.DeviceViewInfoBorder>? deviceViewInfoBorderNullableListFromJson(
  List? deviceViewInfoBorder, [
  List<enums.DeviceViewInfoBorder>? defaultValue,
]) {
  if (deviceViewInfoBorder == null) {
    return defaultValue;
  }

  return deviceViewInfoBorder
      .map((e) => deviceViewInfoBorderFromJson(e.toString()))
      .toList();
}

String? deviceViewInfoPositionNullableToJson(
    enums.DeviceViewInfoPosition? deviceViewInfoPosition) {
  return deviceViewInfoPosition?.value;
}

String? deviceViewInfoPositionToJson(
    enums.DeviceViewInfoPosition deviceViewInfoPosition) {
  return deviceViewInfoPosition.value;
}

enums.DeviceViewInfoPosition deviceViewInfoPositionFromJson(
  Object? deviceViewInfoPosition, [
  enums.DeviceViewInfoPosition? defaultValue,
]) {
  return enums.DeviceViewInfoPosition.values
          .firstWhereOrNull((e) => e.value == deviceViewInfoPosition) ??
      defaultValue ??
      enums.DeviceViewInfoPosition.swaggerGeneratedUnknown;
}

enums.DeviceViewInfoPosition? deviceViewInfoPositionNullableFromJson(
  Object? deviceViewInfoPosition, [
  enums.DeviceViewInfoPosition? defaultValue,
]) {
  if (deviceViewInfoPosition == null) {
    return null;
  }
  return enums.DeviceViewInfoPosition.values
          .firstWhereOrNull((e) => e.value == deviceViewInfoPosition) ??
      defaultValue;
}

String deviceViewInfoPositionExplodedListToJson(
    List<enums.DeviceViewInfoPosition>? deviceViewInfoPosition) {
  return deviceViewInfoPosition?.map((e) => e.value!).join(',') ?? '';
}

List<String> deviceViewInfoPositionListToJson(
    List<enums.DeviceViewInfoPosition>? deviceViewInfoPosition) {
  if (deviceViewInfoPosition == null) {
    return [];
  }

  return deviceViewInfoPosition.map((e) => e.value!).toList();
}

List<enums.DeviceViewInfoPosition> deviceViewInfoPositionListFromJson(
  List? deviceViewInfoPosition, [
  List<enums.DeviceViewInfoPosition>? defaultValue,
]) {
  if (deviceViewInfoPosition == null) {
    return defaultValue ?? [];
  }

  return deviceViewInfoPosition
      .map((e) => deviceViewInfoPositionFromJson(e.toString()))
      .toList();
}

List<enums.DeviceViewInfoPosition>? deviceViewInfoPositionNullableListFromJson(
  List? deviceViewInfoPosition, [
  List<enums.DeviceViewInfoPosition>? defaultValue,
]) {
  if (deviceViewInfoPosition == null) {
    return defaultValue;
  }

  return deviceViewInfoPosition
      .map((e) => deviceViewInfoPositionFromJson(e.toString()))
      .toList();
}

String? deviceViewBorderNullableToJson(
    enums.DeviceViewBorder? deviceViewBorder) {
  return deviceViewBorder?.value;
}

String? deviceViewBorderToJson(enums.DeviceViewBorder deviceViewBorder) {
  return deviceViewBorder.value;
}

enums.DeviceViewBorder deviceViewBorderFromJson(
  Object? deviceViewBorder, [
  enums.DeviceViewBorder? defaultValue,
]) {
  return enums.DeviceViewBorder.values
          .firstWhereOrNull((e) => e.value == deviceViewBorder) ??
      defaultValue ??
      enums.DeviceViewBorder.swaggerGeneratedUnknown;
}

enums.DeviceViewBorder? deviceViewBorderNullableFromJson(
  Object? deviceViewBorder, [
  enums.DeviceViewBorder? defaultValue,
]) {
  if (deviceViewBorder == null) {
    return null;
  }
  return enums.DeviceViewBorder.values
          .firstWhereOrNull((e) => e.value == deviceViewBorder) ??
      defaultValue;
}

String deviceViewBorderExplodedListToJson(
    List<enums.DeviceViewBorder>? deviceViewBorder) {
  return deviceViewBorder?.map((e) => e.value!).join(',') ?? '';
}

List<String> deviceViewBorderListToJson(
    List<enums.DeviceViewBorder>? deviceViewBorder) {
  if (deviceViewBorder == null) {
    return [];
  }

  return deviceViewBorder.map((e) => e.value!).toList();
}

List<enums.DeviceViewBorder> deviceViewBorderListFromJson(
  List? deviceViewBorder, [
  List<enums.DeviceViewBorder>? defaultValue,
]) {
  if (deviceViewBorder == null) {
    return defaultValue ?? [];
  }

  return deviceViewBorder
      .map((e) => deviceViewBorderFromJson(e.toString()))
      .toList();
}

List<enums.DeviceViewBorder>? deviceViewBorderNullableListFromJson(
  List? deviceViewBorder, [
  List<enums.DeviceViewBorder>? defaultValue,
]) {
  if (deviceViewBorder == null) {
    return defaultValue;
  }

  return deviceViewBorder
      .map((e) => deviceViewBorderFromJson(e.toString()))
      .toList();
}

String? triggeredControlDeliveryStatusNullableToJson(
    enums.TriggeredControlDeliveryStatus? triggeredControlDeliveryStatus) {
  return triggeredControlDeliveryStatus?.value;
}

String? triggeredControlDeliveryStatusToJson(
    enums.TriggeredControlDeliveryStatus triggeredControlDeliveryStatus) {
  return triggeredControlDeliveryStatus.value;
}

enums.TriggeredControlDeliveryStatus triggeredControlDeliveryStatusFromJson(
  Object? triggeredControlDeliveryStatus, [
  enums.TriggeredControlDeliveryStatus? defaultValue,
]) {
  return enums.TriggeredControlDeliveryStatus.values
          .firstWhereOrNull((e) => e.value == triggeredControlDeliveryStatus) ??
      defaultValue ??
      enums.TriggeredControlDeliveryStatus.swaggerGeneratedUnknown;
}

enums.TriggeredControlDeliveryStatus?
    triggeredControlDeliveryStatusNullableFromJson(
  Object? triggeredControlDeliveryStatus, [
  enums.TriggeredControlDeliveryStatus? defaultValue,
]) {
  if (triggeredControlDeliveryStatus == null) {
    return null;
  }
  return enums.TriggeredControlDeliveryStatus.values
          .firstWhereOrNull((e) => e.value == triggeredControlDeliveryStatus) ??
      defaultValue;
}

String triggeredControlDeliveryStatusExplodedListToJson(
    List<enums.TriggeredControlDeliveryStatus>?
        triggeredControlDeliveryStatus) {
  return triggeredControlDeliveryStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggeredControlDeliveryStatusListToJson(
    List<enums.TriggeredControlDeliveryStatus>?
        triggeredControlDeliveryStatus) {
  if (triggeredControlDeliveryStatus == null) {
    return [];
  }

  return triggeredControlDeliveryStatus.map((e) => e.value!).toList();
}

List<enums.TriggeredControlDeliveryStatus>
    triggeredControlDeliveryStatusListFromJson(
  List? triggeredControlDeliveryStatus, [
  List<enums.TriggeredControlDeliveryStatus>? defaultValue,
]) {
  if (triggeredControlDeliveryStatus == null) {
    return defaultValue ?? [];
  }

  return triggeredControlDeliveryStatus
      .map((e) => triggeredControlDeliveryStatusFromJson(e.toString()))
      .toList();
}

List<enums.TriggeredControlDeliveryStatus>?
    triggeredControlDeliveryStatusNullableListFromJson(
  List? triggeredControlDeliveryStatus, [
  List<enums.TriggeredControlDeliveryStatus>? defaultValue,
]) {
  if (triggeredControlDeliveryStatus == null) {
    return defaultValue;
  }

  return triggeredControlDeliveryStatus
      .map((e) => triggeredControlDeliveryStatusFromJson(e.toString()))
      .toList();
}

String? radiusConfigRadTypeNullableToJson(
    enums.RadiusConfigRadType? radiusConfigRadType) {
  return radiusConfigRadType?.value;
}

String? radiusConfigRadTypeToJson(
    enums.RadiusConfigRadType radiusConfigRadType) {
  return radiusConfigRadType.value;
}

enums.RadiusConfigRadType radiusConfigRadTypeFromJson(
  Object? radiusConfigRadType, [
  enums.RadiusConfigRadType? defaultValue,
]) {
  return enums.RadiusConfigRadType.values
          .firstWhereOrNull((e) => e.value == radiusConfigRadType) ??
      defaultValue ??
      enums.RadiusConfigRadType.swaggerGeneratedUnknown;
}

enums.RadiusConfigRadType? radiusConfigRadTypeNullableFromJson(
  Object? radiusConfigRadType, [
  enums.RadiusConfigRadType? defaultValue,
]) {
  if (radiusConfigRadType == null) {
    return null;
  }
  return enums.RadiusConfigRadType.values
          .firstWhereOrNull((e) => e.value == radiusConfigRadType) ??
      defaultValue;
}

String radiusConfigRadTypeExplodedListToJson(
    List<enums.RadiusConfigRadType>? radiusConfigRadType) {
  return radiusConfigRadType?.map((e) => e.value!).join(',') ?? '';
}

List<String> radiusConfigRadTypeListToJson(
    List<enums.RadiusConfigRadType>? radiusConfigRadType) {
  if (radiusConfigRadType == null) {
    return [];
  }

  return radiusConfigRadType.map((e) => e.value!).toList();
}

List<enums.RadiusConfigRadType> radiusConfigRadTypeListFromJson(
  List? radiusConfigRadType, [
  List<enums.RadiusConfigRadType>? defaultValue,
]) {
  if (radiusConfigRadType == null) {
    return defaultValue ?? [];
  }

  return radiusConfigRadType
      .map((e) => radiusConfigRadTypeFromJson(e.toString()))
      .toList();
}

List<enums.RadiusConfigRadType>? radiusConfigRadTypeNullableListFromJson(
  List? radiusConfigRadType, [
  List<enums.RadiusConfigRadType>? defaultValue,
]) {
  if (radiusConfigRadType == null) {
    return defaultValue;
  }

  return radiusConfigRadType
      .map((e) => radiusConfigRadTypeFromJson(e.toString()))
      .toList();
}

String? imageFitConfigFitNullableToJson(
    enums.ImageFitConfigFit? imageFitConfigFit) {
  return imageFitConfigFit?.value;
}

String? imageFitConfigFitToJson(enums.ImageFitConfigFit imageFitConfigFit) {
  return imageFitConfigFit.value;
}

enums.ImageFitConfigFit imageFitConfigFitFromJson(
  Object? imageFitConfigFit, [
  enums.ImageFitConfigFit? defaultValue,
]) {
  return enums.ImageFitConfigFit.values
          .firstWhereOrNull((e) => e.value == imageFitConfigFit) ??
      defaultValue ??
      enums.ImageFitConfigFit.swaggerGeneratedUnknown;
}

enums.ImageFitConfigFit? imageFitConfigFitNullableFromJson(
  Object? imageFitConfigFit, [
  enums.ImageFitConfigFit? defaultValue,
]) {
  if (imageFitConfigFit == null) {
    return null;
  }
  return enums.ImageFitConfigFit.values
          .firstWhereOrNull((e) => e.value == imageFitConfigFit) ??
      defaultValue;
}

String imageFitConfigFitExplodedListToJson(
    List<enums.ImageFitConfigFit>? imageFitConfigFit) {
  return imageFitConfigFit?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageFitConfigFitListToJson(
    List<enums.ImageFitConfigFit>? imageFitConfigFit) {
  if (imageFitConfigFit == null) {
    return [];
  }

  return imageFitConfigFit.map((e) => e.value!).toList();
}

List<enums.ImageFitConfigFit> imageFitConfigFitListFromJson(
  List? imageFitConfigFit, [
  List<enums.ImageFitConfigFit>? defaultValue,
]) {
  if (imageFitConfigFit == null) {
    return defaultValue ?? [];
  }

  return imageFitConfigFit
      .map((e) => imageFitConfigFitFromJson(e.toString()))
      .toList();
}

List<enums.ImageFitConfigFit>? imageFitConfigFitNullableListFromJson(
  List? imageFitConfigFit, [
  List<enums.ImageFitConfigFit>? defaultValue,
]) {
  if (imageFitConfigFit == null) {
    return defaultValue;
  }

  return imageFitConfigFit
      .map((e) => imageFitConfigFitFromJson(e.toString()))
      .toList();
}

String? alignmentConfigAlignmentNullableToJson(
    enums.AlignmentConfigAlignment? alignmentConfigAlignment) {
  return alignmentConfigAlignment?.value;
}

String? alignmentConfigAlignmentToJson(
    enums.AlignmentConfigAlignment alignmentConfigAlignment) {
  return alignmentConfigAlignment.value;
}

enums.AlignmentConfigAlignment alignmentConfigAlignmentFromJson(
  Object? alignmentConfigAlignment, [
  enums.AlignmentConfigAlignment? defaultValue,
]) {
  return enums.AlignmentConfigAlignment.values
          .firstWhereOrNull((e) => e.value == alignmentConfigAlignment) ??
      defaultValue ??
      enums.AlignmentConfigAlignment.swaggerGeneratedUnknown;
}

enums.AlignmentConfigAlignment? alignmentConfigAlignmentNullableFromJson(
  Object? alignmentConfigAlignment, [
  enums.AlignmentConfigAlignment? defaultValue,
]) {
  if (alignmentConfigAlignment == null) {
    return null;
  }
  return enums.AlignmentConfigAlignment.values
          .firstWhereOrNull((e) => e.value == alignmentConfigAlignment) ??
      defaultValue;
}

String alignmentConfigAlignmentExplodedListToJson(
    List<enums.AlignmentConfigAlignment>? alignmentConfigAlignment) {
  return alignmentConfigAlignment?.map((e) => e.value!).join(',') ?? '';
}

List<String> alignmentConfigAlignmentListToJson(
    List<enums.AlignmentConfigAlignment>? alignmentConfigAlignment) {
  if (alignmentConfigAlignment == null) {
    return [];
  }

  return alignmentConfigAlignment.map((e) => e.value!).toList();
}

List<enums.AlignmentConfigAlignment> alignmentConfigAlignmentListFromJson(
  List? alignmentConfigAlignment, [
  List<enums.AlignmentConfigAlignment>? defaultValue,
]) {
  if (alignmentConfigAlignment == null) {
    return defaultValue ?? [];
  }

  return alignmentConfigAlignment
      .map((e) => alignmentConfigAlignmentFromJson(e.toString()))
      .toList();
}

List<enums.AlignmentConfigAlignment>?
    alignmentConfigAlignmentNullableListFromJson(
  List? alignmentConfigAlignment, [
  List<enums.AlignmentConfigAlignment>? defaultValue,
]) {
  if (alignmentConfigAlignment == null) {
    return defaultValue;
  }

  return alignmentConfigAlignment
      .map((e) => alignmentConfigAlignmentFromJson(e.toString()))
      .toList();
}

String? borderConfigTypeNullableToJson(
    enums.BorderConfigType? borderConfigType) {
  return borderConfigType?.value;
}

String? borderConfigTypeToJson(enums.BorderConfigType borderConfigType) {
  return borderConfigType.value;
}

enums.BorderConfigType borderConfigTypeFromJson(
  Object? borderConfigType, [
  enums.BorderConfigType? defaultValue,
]) {
  return enums.BorderConfigType.values
          .firstWhereOrNull((e) => e.value == borderConfigType) ??
      defaultValue ??
      enums.BorderConfigType.swaggerGeneratedUnknown;
}

enums.BorderConfigType? borderConfigTypeNullableFromJson(
  Object? borderConfigType, [
  enums.BorderConfigType? defaultValue,
]) {
  if (borderConfigType == null) {
    return null;
  }
  return enums.BorderConfigType.values
          .firstWhereOrNull((e) => e.value == borderConfigType) ??
      defaultValue;
}

String borderConfigTypeExplodedListToJson(
    List<enums.BorderConfigType>? borderConfigType) {
  return borderConfigType?.map((e) => e.value!).join(',') ?? '';
}

List<String> borderConfigTypeListToJson(
    List<enums.BorderConfigType>? borderConfigType) {
  if (borderConfigType == null) {
    return [];
  }

  return borderConfigType.map((e) => e.value!).toList();
}

List<enums.BorderConfigType> borderConfigTypeListFromJson(
  List? borderConfigType, [
  List<enums.BorderConfigType>? defaultValue,
]) {
  if (borderConfigType == null) {
    return defaultValue ?? [];
  }

  return borderConfigType
      .map((e) => borderConfigTypeFromJson(e.toString()))
      .toList();
}

List<enums.BorderConfigType>? borderConfigTypeNullableListFromJson(
  List? borderConfigType, [
  List<enums.BorderConfigType>? defaultValue,
]) {
  if (borderConfigType == null) {
    return defaultValue;
  }

  return borderConfigType
      .map((e) => borderConfigTypeFromJson(e.toString()))
      .toList();
}

String? triggeredEventEventTypeNullableToJson(
    enums.TriggeredEventEventType? triggeredEventEventType) {
  return triggeredEventEventType?.value;
}

String? triggeredEventEventTypeToJson(
    enums.TriggeredEventEventType triggeredEventEventType) {
  return triggeredEventEventType.value;
}

enums.TriggeredEventEventType triggeredEventEventTypeFromJson(
  Object? triggeredEventEventType, [
  enums.TriggeredEventEventType? defaultValue,
]) {
  return enums.TriggeredEventEventType.values
          .firstWhereOrNull((e) => e.value == triggeredEventEventType) ??
      defaultValue ??
      enums.TriggeredEventEventType.swaggerGeneratedUnknown;
}

enums.TriggeredEventEventType? triggeredEventEventTypeNullableFromJson(
  Object? triggeredEventEventType, [
  enums.TriggeredEventEventType? defaultValue,
]) {
  if (triggeredEventEventType == null) {
    return null;
  }
  return enums.TriggeredEventEventType.values
          .firstWhereOrNull((e) => e.value == triggeredEventEventType) ??
      defaultValue;
}

String triggeredEventEventTypeExplodedListToJson(
    List<enums.TriggeredEventEventType>? triggeredEventEventType) {
  return triggeredEventEventType?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggeredEventEventTypeListToJson(
    List<enums.TriggeredEventEventType>? triggeredEventEventType) {
  if (triggeredEventEventType == null) {
    return [];
  }

  return triggeredEventEventType.map((e) => e.value!).toList();
}

List<enums.TriggeredEventEventType> triggeredEventEventTypeListFromJson(
  List? triggeredEventEventType, [
  List<enums.TriggeredEventEventType>? defaultValue,
]) {
  if (triggeredEventEventType == null) {
    return defaultValue ?? [];
  }

  return triggeredEventEventType
      .map((e) => triggeredEventEventTypeFromJson(e.toString()))
      .toList();
}

List<enums.TriggeredEventEventType>?
    triggeredEventEventTypeNullableListFromJson(
  List? triggeredEventEventType, [
  List<enums.TriggeredEventEventType>? defaultValue,
]) {
  if (triggeredEventEventType == null) {
    return defaultValue;
  }

  return triggeredEventEventType
      .map((e) => triggeredEventEventTypeFromJson(e.toString()))
      .toList();
}

String? triggeredEventDeliveryStatusNullableToJson(
    enums.TriggeredEventDeliveryStatus? triggeredEventDeliveryStatus) {
  return triggeredEventDeliveryStatus?.value;
}

String? triggeredEventDeliveryStatusToJson(
    enums.TriggeredEventDeliveryStatus triggeredEventDeliveryStatus) {
  return triggeredEventDeliveryStatus.value;
}

enums.TriggeredEventDeliveryStatus triggeredEventDeliveryStatusFromJson(
  Object? triggeredEventDeliveryStatus, [
  enums.TriggeredEventDeliveryStatus? defaultValue,
]) {
  return enums.TriggeredEventDeliveryStatus.values
          .firstWhereOrNull((e) => e.value == triggeredEventDeliveryStatus) ??
      defaultValue ??
      enums.TriggeredEventDeliveryStatus.swaggerGeneratedUnknown;
}

enums.TriggeredEventDeliveryStatus?
    triggeredEventDeliveryStatusNullableFromJson(
  Object? triggeredEventDeliveryStatus, [
  enums.TriggeredEventDeliveryStatus? defaultValue,
]) {
  if (triggeredEventDeliveryStatus == null) {
    return null;
  }
  return enums.TriggeredEventDeliveryStatus.values
          .firstWhereOrNull((e) => e.value == triggeredEventDeliveryStatus) ??
      defaultValue;
}

String triggeredEventDeliveryStatusExplodedListToJson(
    List<enums.TriggeredEventDeliveryStatus>? triggeredEventDeliveryStatus) {
  return triggeredEventDeliveryStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> triggeredEventDeliveryStatusListToJson(
    List<enums.TriggeredEventDeliveryStatus>? triggeredEventDeliveryStatus) {
  if (triggeredEventDeliveryStatus == null) {
    return [];
  }

  return triggeredEventDeliveryStatus.map((e) => e.value!).toList();
}

List<enums.TriggeredEventDeliveryStatus>
    triggeredEventDeliveryStatusListFromJson(
  List? triggeredEventDeliveryStatus, [
  List<enums.TriggeredEventDeliveryStatus>? defaultValue,
]) {
  if (triggeredEventDeliveryStatus == null) {
    return defaultValue ?? [];
  }

  return triggeredEventDeliveryStatus
      .map((e) => triggeredEventDeliveryStatusFromJson(e.toString()))
      .toList();
}

List<enums.TriggeredEventDeliveryStatus>?
    triggeredEventDeliveryStatusNullableListFromJson(
  List? triggeredEventDeliveryStatus, [
  List<enums.TriggeredEventDeliveryStatus>? defaultValue,
]) {
  if (triggeredEventDeliveryStatus == null) {
    return defaultValue;
  }

  return triggeredEventDeliveryStatus
      .map((e) => triggeredEventDeliveryStatusFromJson(e.toString()))
      .toList();
}

String? screenWidgetInfoTargetNullableToJson(
    enums.ScreenWidgetInfoTarget? screenWidgetInfoTarget) {
  return screenWidgetInfoTarget?.value;
}

String? screenWidgetInfoTargetToJson(
    enums.ScreenWidgetInfoTarget screenWidgetInfoTarget) {
  return screenWidgetInfoTarget.value;
}

enums.ScreenWidgetInfoTarget screenWidgetInfoTargetFromJson(
  Object? screenWidgetInfoTarget, [
  enums.ScreenWidgetInfoTarget? defaultValue,
]) {
  return enums.ScreenWidgetInfoTarget.values
          .firstWhereOrNull((e) => e.value == screenWidgetInfoTarget) ??
      defaultValue ??
      enums.ScreenWidgetInfoTarget.swaggerGeneratedUnknown;
}

enums.ScreenWidgetInfoTarget? screenWidgetInfoTargetNullableFromJson(
  Object? screenWidgetInfoTarget, [
  enums.ScreenWidgetInfoTarget? defaultValue,
]) {
  if (screenWidgetInfoTarget == null) {
    return null;
  }
  return enums.ScreenWidgetInfoTarget.values
          .firstWhereOrNull((e) => e.value == screenWidgetInfoTarget) ??
      defaultValue;
}

String screenWidgetInfoTargetExplodedListToJson(
    List<enums.ScreenWidgetInfoTarget>? screenWidgetInfoTarget) {
  return screenWidgetInfoTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> screenWidgetInfoTargetListToJson(
    List<enums.ScreenWidgetInfoTarget>? screenWidgetInfoTarget) {
  if (screenWidgetInfoTarget == null) {
    return [];
  }

  return screenWidgetInfoTarget.map((e) => e.value!).toList();
}

List<enums.ScreenWidgetInfoTarget> screenWidgetInfoTargetListFromJson(
  List? screenWidgetInfoTarget, [
  List<enums.ScreenWidgetInfoTarget>? defaultValue,
]) {
  if (screenWidgetInfoTarget == null) {
    return defaultValue ?? [];
  }

  return screenWidgetInfoTarget
      .map((e) => screenWidgetInfoTargetFromJson(e.toString()))
      .toList();
}

List<enums.ScreenWidgetInfoTarget>? screenWidgetInfoTargetNullableListFromJson(
  List? screenWidgetInfoTarget, [
  List<enums.ScreenWidgetInfoTarget>? defaultValue,
]) {
  if (screenWidgetInfoTarget == null) {
    return defaultValue;
  }

  return screenWidgetInfoTarget
      .map((e) => screenWidgetInfoTargetFromJson(e.toString()))
      .toList();
}

String? screenWidgetTargetNullableToJson(
    enums.ScreenWidgetTarget? screenWidgetTarget) {
  return screenWidgetTarget?.value;
}

String? screenWidgetTargetToJson(enums.ScreenWidgetTarget screenWidgetTarget) {
  return screenWidgetTarget.value;
}

enums.ScreenWidgetTarget screenWidgetTargetFromJson(
  Object? screenWidgetTarget, [
  enums.ScreenWidgetTarget? defaultValue,
]) {
  return enums.ScreenWidgetTarget.values
          .firstWhereOrNull((e) => e.value == screenWidgetTarget) ??
      defaultValue ??
      enums.ScreenWidgetTarget.swaggerGeneratedUnknown;
}

enums.ScreenWidgetTarget? screenWidgetTargetNullableFromJson(
  Object? screenWidgetTarget, [
  enums.ScreenWidgetTarget? defaultValue,
]) {
  if (screenWidgetTarget == null) {
    return null;
  }
  return enums.ScreenWidgetTarget.values
          .firstWhereOrNull((e) => e.value == screenWidgetTarget) ??
      defaultValue;
}

String screenWidgetTargetExplodedListToJson(
    List<enums.ScreenWidgetTarget>? screenWidgetTarget) {
  return screenWidgetTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> screenWidgetTargetListToJson(
    List<enums.ScreenWidgetTarget>? screenWidgetTarget) {
  if (screenWidgetTarget == null) {
    return [];
  }

  return screenWidgetTarget.map((e) => e.value!).toList();
}

List<enums.ScreenWidgetTarget> screenWidgetTargetListFromJson(
  List? screenWidgetTarget, [
  List<enums.ScreenWidgetTarget>? defaultValue,
]) {
  if (screenWidgetTarget == null) {
    return defaultValue ?? [];
  }

  return screenWidgetTarget
      .map((e) => screenWidgetTargetFromJson(e.toString()))
      .toList();
}

List<enums.ScreenWidgetTarget>? screenWidgetTargetNullableListFromJson(
  List? screenWidgetTarget, [
  List<enums.ScreenWidgetTarget>? defaultValue,
]) {
  if (screenWidgetTarget == null) {
    return defaultValue;
  }

  return screenWidgetTarget
      .map((e) => screenWidgetTargetFromJson(e.toString()))
      .toList();
}

String? filterMatchGroupMatchTypeNullableToJson(
    enums.FilterMatchGroupMatchType? filterMatchGroupMatchType) {
  return filterMatchGroupMatchType?.value;
}

String? filterMatchGroupMatchTypeToJson(
    enums.FilterMatchGroupMatchType filterMatchGroupMatchType) {
  return filterMatchGroupMatchType.value;
}

enums.FilterMatchGroupMatchType filterMatchGroupMatchTypeFromJson(
  Object? filterMatchGroupMatchType, [
  enums.FilterMatchGroupMatchType? defaultValue,
]) {
  return enums.FilterMatchGroupMatchType.values
          .firstWhereOrNull((e) => e.value == filterMatchGroupMatchType) ??
      defaultValue ??
      enums.FilterMatchGroupMatchType.swaggerGeneratedUnknown;
}

enums.FilterMatchGroupMatchType? filterMatchGroupMatchTypeNullableFromJson(
  Object? filterMatchGroupMatchType, [
  enums.FilterMatchGroupMatchType? defaultValue,
]) {
  if (filterMatchGroupMatchType == null) {
    return null;
  }
  return enums.FilterMatchGroupMatchType.values
          .firstWhereOrNull((e) => e.value == filterMatchGroupMatchType) ??
      defaultValue;
}

String filterMatchGroupMatchTypeExplodedListToJson(
    List<enums.FilterMatchGroupMatchType>? filterMatchGroupMatchType) {
  return filterMatchGroupMatchType?.map((e) => e.value!).join(',') ?? '';
}

List<String> filterMatchGroupMatchTypeListToJson(
    List<enums.FilterMatchGroupMatchType>? filterMatchGroupMatchType) {
  if (filterMatchGroupMatchType == null) {
    return [];
  }

  return filterMatchGroupMatchType.map((e) => e.value!).toList();
}

List<enums.FilterMatchGroupMatchType> filterMatchGroupMatchTypeListFromJson(
  List? filterMatchGroupMatchType, [
  List<enums.FilterMatchGroupMatchType>? defaultValue,
]) {
  if (filterMatchGroupMatchType == null) {
    return defaultValue ?? [];
  }

  return filterMatchGroupMatchType
      .map((e) => filterMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

List<enums.FilterMatchGroupMatchType>?
    filterMatchGroupMatchTypeNullableListFromJson(
  List? filterMatchGroupMatchType, [
  List<enums.FilterMatchGroupMatchType>? defaultValue,
]) {
  if (filterMatchGroupMatchType == null) {
    return defaultValue;
  }

  return filterMatchGroupMatchType
      .map((e) => filterMatchGroupMatchTypeFromJson(e.toString()))
      .toList();
}

String? geoFenceInfoFenceTypeNullableToJson(
    enums.GeoFenceInfoFenceType? geoFenceInfoFenceType) {
  return geoFenceInfoFenceType?.value;
}

String? geoFenceInfoFenceTypeToJson(
    enums.GeoFenceInfoFenceType geoFenceInfoFenceType) {
  return geoFenceInfoFenceType.value;
}

enums.GeoFenceInfoFenceType geoFenceInfoFenceTypeFromJson(
  Object? geoFenceInfoFenceType, [
  enums.GeoFenceInfoFenceType? defaultValue,
]) {
  return enums.GeoFenceInfoFenceType.values
          .firstWhereOrNull((e) => e.value == geoFenceInfoFenceType) ??
      defaultValue ??
      enums.GeoFenceInfoFenceType.swaggerGeneratedUnknown;
}

enums.GeoFenceInfoFenceType? geoFenceInfoFenceTypeNullableFromJson(
  Object? geoFenceInfoFenceType, [
  enums.GeoFenceInfoFenceType? defaultValue,
]) {
  if (geoFenceInfoFenceType == null) {
    return null;
  }
  return enums.GeoFenceInfoFenceType.values
          .firstWhereOrNull((e) => e.value == geoFenceInfoFenceType) ??
      defaultValue;
}

String geoFenceInfoFenceTypeExplodedListToJson(
    List<enums.GeoFenceInfoFenceType>? geoFenceInfoFenceType) {
  return geoFenceInfoFenceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> geoFenceInfoFenceTypeListToJson(
    List<enums.GeoFenceInfoFenceType>? geoFenceInfoFenceType) {
  if (geoFenceInfoFenceType == null) {
    return [];
  }

  return geoFenceInfoFenceType.map((e) => e.value!).toList();
}

List<enums.GeoFenceInfoFenceType> geoFenceInfoFenceTypeListFromJson(
  List? geoFenceInfoFenceType, [
  List<enums.GeoFenceInfoFenceType>? defaultValue,
]) {
  if (geoFenceInfoFenceType == null) {
    return defaultValue ?? [];
  }

  return geoFenceInfoFenceType
      .map((e) => geoFenceInfoFenceTypeFromJson(e.toString()))
      .toList();
}

List<enums.GeoFenceInfoFenceType>? geoFenceInfoFenceTypeNullableListFromJson(
  List? geoFenceInfoFenceType, [
  List<enums.GeoFenceInfoFenceType>? defaultValue,
]) {
  if (geoFenceInfoFenceType == null) {
    return defaultValue;
  }

  return geoFenceInfoFenceType
      .map((e) => geoFenceInfoFenceTypeFromJson(e.toString()))
      .toList();
}

String? geoFenceFenceTypeNullableToJson(
    enums.GeoFenceFenceType? geoFenceFenceType) {
  return geoFenceFenceType?.value;
}

String? geoFenceFenceTypeToJson(enums.GeoFenceFenceType geoFenceFenceType) {
  return geoFenceFenceType.value;
}

enums.GeoFenceFenceType geoFenceFenceTypeFromJson(
  Object? geoFenceFenceType, [
  enums.GeoFenceFenceType? defaultValue,
]) {
  return enums.GeoFenceFenceType.values
          .firstWhereOrNull((e) => e.value == geoFenceFenceType) ??
      defaultValue ??
      enums.GeoFenceFenceType.swaggerGeneratedUnknown;
}

enums.GeoFenceFenceType? geoFenceFenceTypeNullableFromJson(
  Object? geoFenceFenceType, [
  enums.GeoFenceFenceType? defaultValue,
]) {
  if (geoFenceFenceType == null) {
    return null;
  }
  return enums.GeoFenceFenceType.values
          .firstWhereOrNull((e) => e.value == geoFenceFenceType) ??
      defaultValue;
}

String geoFenceFenceTypeExplodedListToJson(
    List<enums.GeoFenceFenceType>? geoFenceFenceType) {
  return geoFenceFenceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> geoFenceFenceTypeListToJson(
    List<enums.GeoFenceFenceType>? geoFenceFenceType) {
  if (geoFenceFenceType == null) {
    return [];
  }

  return geoFenceFenceType.map((e) => e.value!).toList();
}

List<enums.GeoFenceFenceType> geoFenceFenceTypeListFromJson(
  List? geoFenceFenceType, [
  List<enums.GeoFenceFenceType>? defaultValue,
]) {
  if (geoFenceFenceType == null) {
    return defaultValue ?? [];
  }

  return geoFenceFenceType
      .map((e) => geoFenceFenceTypeFromJson(e.toString()))
      .toList();
}

List<enums.GeoFenceFenceType>? geoFenceFenceTypeNullableListFromJson(
  List? geoFenceFenceType, [
  List<enums.GeoFenceFenceType>? defaultValue,
]) {
  if (geoFenceFenceType == null) {
    return defaultValue;
  }

  return geoFenceFenceType
      .map((e) => geoFenceFenceTypeFromJson(e.toString()))
      .toList();
}

String? twinSysInfoEmailProviderNullableToJson(
    enums.TwinSysInfoEmailProvider? twinSysInfoEmailProvider) {
  return twinSysInfoEmailProvider?.value;
}

String? twinSysInfoEmailProviderToJson(
    enums.TwinSysInfoEmailProvider twinSysInfoEmailProvider) {
  return twinSysInfoEmailProvider.value;
}

enums.TwinSysInfoEmailProvider twinSysInfoEmailProviderFromJson(
  Object? twinSysInfoEmailProvider, [
  enums.TwinSysInfoEmailProvider? defaultValue,
]) {
  return enums.TwinSysInfoEmailProvider.values
          .firstWhereOrNull((e) => e.value == twinSysInfoEmailProvider) ??
      defaultValue ??
      enums.TwinSysInfoEmailProvider.swaggerGeneratedUnknown;
}

enums.TwinSysInfoEmailProvider? twinSysInfoEmailProviderNullableFromJson(
  Object? twinSysInfoEmailProvider, [
  enums.TwinSysInfoEmailProvider? defaultValue,
]) {
  if (twinSysInfoEmailProvider == null) {
    return null;
  }
  return enums.TwinSysInfoEmailProvider.values
          .firstWhereOrNull((e) => e.value == twinSysInfoEmailProvider) ??
      defaultValue;
}

String twinSysInfoEmailProviderExplodedListToJson(
    List<enums.TwinSysInfoEmailProvider>? twinSysInfoEmailProvider) {
  return twinSysInfoEmailProvider?.map((e) => e.value!).join(',') ?? '';
}

List<String> twinSysInfoEmailProviderListToJson(
    List<enums.TwinSysInfoEmailProvider>? twinSysInfoEmailProvider) {
  if (twinSysInfoEmailProvider == null) {
    return [];
  }

  return twinSysInfoEmailProvider.map((e) => e.value!).toList();
}

List<enums.TwinSysInfoEmailProvider> twinSysInfoEmailProviderListFromJson(
  List? twinSysInfoEmailProvider, [
  List<enums.TwinSysInfoEmailProvider>? defaultValue,
]) {
  if (twinSysInfoEmailProvider == null) {
    return defaultValue ?? [];
  }

  return twinSysInfoEmailProvider
      .map((e) => twinSysInfoEmailProviderFromJson(e.toString()))
      .toList();
}

List<enums.TwinSysInfoEmailProvider>?
    twinSysInfoEmailProviderNullableListFromJson(
  List? twinSysInfoEmailProvider, [
  List<enums.TwinSysInfoEmailProvider>? defaultValue,
]) {
  if (twinSysInfoEmailProvider == null) {
    return defaultValue;
  }

  return twinSysInfoEmailProvider
      .map((e) => twinSysInfoEmailProviderFromJson(e.toString()))
      .toList();
}

String? twinSysInfoSmsProviderNullableToJson(
    enums.TwinSysInfoSmsProvider? twinSysInfoSmsProvider) {
  return twinSysInfoSmsProvider?.value;
}

String? twinSysInfoSmsProviderToJson(
    enums.TwinSysInfoSmsProvider twinSysInfoSmsProvider) {
  return twinSysInfoSmsProvider.value;
}

enums.TwinSysInfoSmsProvider twinSysInfoSmsProviderFromJson(
  Object? twinSysInfoSmsProvider, [
  enums.TwinSysInfoSmsProvider? defaultValue,
]) {
  return enums.TwinSysInfoSmsProvider.values
          .firstWhereOrNull((e) => e.value == twinSysInfoSmsProvider) ??
      defaultValue ??
      enums.TwinSysInfoSmsProvider.swaggerGeneratedUnknown;
}

enums.TwinSysInfoSmsProvider? twinSysInfoSmsProviderNullableFromJson(
  Object? twinSysInfoSmsProvider, [
  enums.TwinSysInfoSmsProvider? defaultValue,
]) {
  if (twinSysInfoSmsProvider == null) {
    return null;
  }
  return enums.TwinSysInfoSmsProvider.values
          .firstWhereOrNull((e) => e.value == twinSysInfoSmsProvider) ??
      defaultValue;
}

String twinSysInfoSmsProviderExplodedListToJson(
    List<enums.TwinSysInfoSmsProvider>? twinSysInfoSmsProvider) {
  return twinSysInfoSmsProvider?.map((e) => e.value!).join(',') ?? '';
}

List<String> twinSysInfoSmsProviderListToJson(
    List<enums.TwinSysInfoSmsProvider>? twinSysInfoSmsProvider) {
  if (twinSysInfoSmsProvider == null) {
    return [];
  }

  return twinSysInfoSmsProvider.map((e) => e.value!).toList();
}

List<enums.TwinSysInfoSmsProvider> twinSysInfoSmsProviderListFromJson(
  List? twinSysInfoSmsProvider, [
  List<enums.TwinSysInfoSmsProvider>? defaultValue,
]) {
  if (twinSysInfoSmsProvider == null) {
    return defaultValue ?? [];
  }

  return twinSysInfoSmsProvider
      .map((e) => twinSysInfoSmsProviderFromJson(e.toString()))
      .toList();
}

List<enums.TwinSysInfoSmsProvider>? twinSysInfoSmsProviderNullableListFromJson(
  List? twinSysInfoSmsProvider, [
  List<enums.TwinSysInfoSmsProvider>? defaultValue,
]) {
  if (twinSysInfoSmsProvider == null) {
    return defaultValue;
  }

  return twinSysInfoSmsProvider
      .map((e) => twinSysInfoSmsProviderFromJson(e.toString()))
      .toList();
}

String? twinSysInfoVoiceProviderNullableToJson(
    enums.TwinSysInfoVoiceProvider? twinSysInfoVoiceProvider) {
  return twinSysInfoVoiceProvider?.value;
}

String? twinSysInfoVoiceProviderToJson(
    enums.TwinSysInfoVoiceProvider twinSysInfoVoiceProvider) {
  return twinSysInfoVoiceProvider.value;
}

enums.TwinSysInfoVoiceProvider twinSysInfoVoiceProviderFromJson(
  Object? twinSysInfoVoiceProvider, [
  enums.TwinSysInfoVoiceProvider? defaultValue,
]) {
  return enums.TwinSysInfoVoiceProvider.values
          .firstWhereOrNull((e) => e.value == twinSysInfoVoiceProvider) ??
      defaultValue ??
      enums.TwinSysInfoVoiceProvider.swaggerGeneratedUnknown;
}

enums.TwinSysInfoVoiceProvider? twinSysInfoVoiceProviderNullableFromJson(
  Object? twinSysInfoVoiceProvider, [
  enums.TwinSysInfoVoiceProvider? defaultValue,
]) {
  if (twinSysInfoVoiceProvider == null) {
    return null;
  }
  return enums.TwinSysInfoVoiceProvider.values
          .firstWhereOrNull((e) => e.value == twinSysInfoVoiceProvider) ??
      defaultValue;
}

String twinSysInfoVoiceProviderExplodedListToJson(
    List<enums.TwinSysInfoVoiceProvider>? twinSysInfoVoiceProvider) {
  return twinSysInfoVoiceProvider?.map((e) => e.value!).join(',') ?? '';
}

List<String> twinSysInfoVoiceProviderListToJson(
    List<enums.TwinSysInfoVoiceProvider>? twinSysInfoVoiceProvider) {
  if (twinSysInfoVoiceProvider == null) {
    return [];
  }

  return twinSysInfoVoiceProvider.map((e) => e.value!).toList();
}

List<enums.TwinSysInfoVoiceProvider> twinSysInfoVoiceProviderListFromJson(
  List? twinSysInfoVoiceProvider, [
  List<enums.TwinSysInfoVoiceProvider>? defaultValue,
]) {
  if (twinSysInfoVoiceProvider == null) {
    return defaultValue ?? [];
  }

  return twinSysInfoVoiceProvider
      .map((e) => twinSysInfoVoiceProviderFromJson(e.toString()))
      .toList();
}

List<enums.TwinSysInfoVoiceProvider>?
    twinSysInfoVoiceProviderNullableListFromJson(
  List? twinSysInfoVoiceProvider, [
  List<enums.TwinSysInfoVoiceProvider>? defaultValue,
]) {
  if (twinSysInfoVoiceProvider == null) {
    return defaultValue;
  }

  return twinSysInfoVoiceProvider
      .map((e) => twinSysInfoVoiceProviderFromJson(e.toString()))
      .toList();
}

String? floorInfoFloorTypeNullableToJson(
    enums.FloorInfoFloorType? floorInfoFloorType) {
  return floorInfoFloorType?.value;
}

String? floorInfoFloorTypeToJson(enums.FloorInfoFloorType floorInfoFloorType) {
  return floorInfoFloorType.value;
}

enums.FloorInfoFloorType floorInfoFloorTypeFromJson(
  Object? floorInfoFloorType, [
  enums.FloorInfoFloorType? defaultValue,
]) {
  return enums.FloorInfoFloorType.values
          .firstWhereOrNull((e) => e.value == floorInfoFloorType) ??
      defaultValue ??
      enums.FloorInfoFloorType.swaggerGeneratedUnknown;
}

enums.FloorInfoFloorType? floorInfoFloorTypeNullableFromJson(
  Object? floorInfoFloorType, [
  enums.FloorInfoFloorType? defaultValue,
]) {
  if (floorInfoFloorType == null) {
    return null;
  }
  return enums.FloorInfoFloorType.values
          .firstWhereOrNull((e) => e.value == floorInfoFloorType) ??
      defaultValue;
}

String floorInfoFloorTypeExplodedListToJson(
    List<enums.FloorInfoFloorType>? floorInfoFloorType) {
  return floorInfoFloorType?.map((e) => e.value!).join(',') ?? '';
}

List<String> floorInfoFloorTypeListToJson(
    List<enums.FloorInfoFloorType>? floorInfoFloorType) {
  if (floorInfoFloorType == null) {
    return [];
  }

  return floorInfoFloorType.map((e) => e.value!).toList();
}

List<enums.FloorInfoFloorType> floorInfoFloorTypeListFromJson(
  List? floorInfoFloorType, [
  List<enums.FloorInfoFloorType>? defaultValue,
]) {
  if (floorInfoFloorType == null) {
    return defaultValue ?? [];
  }

  return floorInfoFloorType
      .map((e) => floorInfoFloorTypeFromJson(e.toString()))
      .toList();
}

List<enums.FloorInfoFloorType>? floorInfoFloorTypeNullableListFromJson(
  List? floorInfoFloorType, [
  List<enums.FloorInfoFloorType>? defaultValue,
]) {
  if (floorInfoFloorType == null) {
    return defaultValue;
  }

  return floorInfoFloorType
      .map((e) => floorInfoFloorTypeFromJson(e.toString()))
      .toList();
}

String? floorFloorTypeNullableToJson(enums.FloorFloorType? floorFloorType) {
  return floorFloorType?.value;
}

String? floorFloorTypeToJson(enums.FloorFloorType floorFloorType) {
  return floorFloorType.value;
}

enums.FloorFloorType floorFloorTypeFromJson(
  Object? floorFloorType, [
  enums.FloorFloorType? defaultValue,
]) {
  return enums.FloorFloorType.values
          .firstWhereOrNull((e) => e.value == floorFloorType) ??
      defaultValue ??
      enums.FloorFloorType.swaggerGeneratedUnknown;
}

enums.FloorFloorType? floorFloorTypeNullableFromJson(
  Object? floorFloorType, [
  enums.FloorFloorType? defaultValue,
]) {
  if (floorFloorType == null) {
    return null;
  }
  return enums.FloorFloorType.values
          .firstWhereOrNull((e) => e.value == floorFloorType) ??
      defaultValue;
}

String floorFloorTypeExplodedListToJson(
    List<enums.FloorFloorType>? floorFloorType) {
  return floorFloorType?.map((e) => e.value!).join(',') ?? '';
}

List<String> floorFloorTypeListToJson(
    List<enums.FloorFloorType>? floorFloorType) {
  if (floorFloorType == null) {
    return [];
  }

  return floorFloorType.map((e) => e.value!).toList();
}

List<enums.FloorFloorType> floorFloorTypeListFromJson(
  List? floorFloorType, [
  List<enums.FloorFloorType>? defaultValue,
]) {
  if (floorFloorType == null) {
    return defaultValue ?? [];
  }

  return floorFloorType
      .map((e) => floorFloorTypeFromJson(e.toString()))
      .toList();
}

List<enums.FloorFloorType>? floorFloorTypeNullableListFromJson(
  List? floorFloorType, [
  List<enums.FloorFloorType>? defaultValue,
]) {
  if (floorFloorType == null) {
    return defaultValue;
  }

  return floorFloorType
      .map((e) => floorFloorTypeFromJson(e.toString()))
      .toList();
}

String? attributeAttributeTypeNullableToJson(
    enums.AttributeAttributeType? attributeAttributeType) {
  return attributeAttributeType?.value;
}

String? attributeAttributeTypeToJson(
    enums.AttributeAttributeType attributeAttributeType) {
  return attributeAttributeType.value;
}

enums.AttributeAttributeType attributeAttributeTypeFromJson(
  Object? attributeAttributeType, [
  enums.AttributeAttributeType? defaultValue,
]) {
  return enums.AttributeAttributeType.values
          .firstWhereOrNull((e) => e.value == attributeAttributeType) ??
      defaultValue ??
      enums.AttributeAttributeType.swaggerGeneratedUnknown;
}

enums.AttributeAttributeType? attributeAttributeTypeNullableFromJson(
  Object? attributeAttributeType, [
  enums.AttributeAttributeType? defaultValue,
]) {
  if (attributeAttributeType == null) {
    return null;
  }
  return enums.AttributeAttributeType.values
          .firstWhereOrNull((e) => e.value == attributeAttributeType) ??
      defaultValue;
}

String attributeAttributeTypeExplodedListToJson(
    List<enums.AttributeAttributeType>? attributeAttributeType) {
  return attributeAttributeType?.map((e) => e.value!).join(',') ?? '';
}

List<String> attributeAttributeTypeListToJson(
    List<enums.AttributeAttributeType>? attributeAttributeType) {
  if (attributeAttributeType == null) {
    return [];
  }

  return attributeAttributeType.map((e) => e.value!).toList();
}

List<enums.AttributeAttributeType> attributeAttributeTypeListFromJson(
  List? attributeAttributeType, [
  List<enums.AttributeAttributeType>? defaultValue,
]) {
  if (attributeAttributeType == null) {
    return defaultValue ?? [];
  }

  return attributeAttributeType
      .map((e) => attributeAttributeTypeFromJson(e.toString()))
      .toList();
}

List<enums.AttributeAttributeType>? attributeAttributeTypeNullableListFromJson(
  List? attributeAttributeType, [
  List<enums.AttributeAttributeType>? defaultValue,
]) {
  if (attributeAttributeType == null) {
    return defaultValue;
  }

  return attributeAttributeType
      .map((e) => attributeAttributeTypeFromJson(e.toString()))
      .toList();
}

String? attributeValidatorNullableToJson(
    enums.AttributeValidator? attributeValidator) {
  return attributeValidator?.value;
}

String? attributeValidatorToJson(enums.AttributeValidator attributeValidator) {
  return attributeValidator.value;
}

enums.AttributeValidator attributeValidatorFromJson(
  Object? attributeValidator, [
  enums.AttributeValidator? defaultValue,
]) {
  return enums.AttributeValidator.values
          .firstWhereOrNull((e) => e.value == attributeValidator) ??
      defaultValue ??
      enums.AttributeValidator.swaggerGeneratedUnknown;
}

enums.AttributeValidator? attributeValidatorNullableFromJson(
  Object? attributeValidator, [
  enums.AttributeValidator? defaultValue,
]) {
  if (attributeValidator == null) {
    return null;
  }
  return enums.AttributeValidator.values
          .firstWhereOrNull((e) => e.value == attributeValidator) ??
      defaultValue;
}

String attributeValidatorExplodedListToJson(
    List<enums.AttributeValidator>? attributeValidator) {
  return attributeValidator?.map((e) => e.value!).join(',') ?? '';
}

List<String> attributeValidatorListToJson(
    List<enums.AttributeValidator>? attributeValidator) {
  if (attributeValidator == null) {
    return [];
  }

  return attributeValidator.map((e) => e.value!).toList();
}

List<enums.AttributeValidator> attributeValidatorListFromJson(
  List? attributeValidator, [
  List<enums.AttributeValidator>? defaultValue,
]) {
  if (attributeValidator == null) {
    return defaultValue ?? [];
  }

  return attributeValidator
      .map((e) => attributeValidatorFromJson(e.toString()))
      .toList();
}

List<enums.AttributeValidator>? attributeValidatorNullableListFromJson(
  List? attributeValidator, [
  List<enums.AttributeValidator>? defaultValue,
]) {
  if (attributeValidator == null) {
    return defaultValue;
  }

  return attributeValidator
      .map((e) => attributeValidatorFromJson(e.toString()))
      .toList();
}

String? assetGroupInfoTargetNullableToJson(
    enums.AssetGroupInfoTarget? assetGroupInfoTarget) {
  return assetGroupInfoTarget?.value;
}

String? assetGroupInfoTargetToJson(
    enums.AssetGroupInfoTarget assetGroupInfoTarget) {
  return assetGroupInfoTarget.value;
}

enums.AssetGroupInfoTarget assetGroupInfoTargetFromJson(
  Object? assetGroupInfoTarget, [
  enums.AssetGroupInfoTarget? defaultValue,
]) {
  return enums.AssetGroupInfoTarget.values
          .firstWhereOrNull((e) => e.value == assetGroupInfoTarget) ??
      defaultValue ??
      enums.AssetGroupInfoTarget.swaggerGeneratedUnknown;
}

enums.AssetGroupInfoTarget? assetGroupInfoTargetNullableFromJson(
  Object? assetGroupInfoTarget, [
  enums.AssetGroupInfoTarget? defaultValue,
]) {
  if (assetGroupInfoTarget == null) {
    return null;
  }
  return enums.AssetGroupInfoTarget.values
          .firstWhereOrNull((e) => e.value == assetGroupInfoTarget) ??
      defaultValue;
}

String assetGroupInfoTargetExplodedListToJson(
    List<enums.AssetGroupInfoTarget>? assetGroupInfoTarget) {
  return assetGroupInfoTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> assetGroupInfoTargetListToJson(
    List<enums.AssetGroupInfoTarget>? assetGroupInfoTarget) {
  if (assetGroupInfoTarget == null) {
    return [];
  }

  return assetGroupInfoTarget.map((e) => e.value!).toList();
}

List<enums.AssetGroupInfoTarget> assetGroupInfoTargetListFromJson(
  List? assetGroupInfoTarget, [
  List<enums.AssetGroupInfoTarget>? defaultValue,
]) {
  if (assetGroupInfoTarget == null) {
    return defaultValue ?? [];
  }

  return assetGroupInfoTarget
      .map((e) => assetGroupInfoTargetFromJson(e.toString()))
      .toList();
}

List<enums.AssetGroupInfoTarget>? assetGroupInfoTargetNullableListFromJson(
  List? assetGroupInfoTarget, [
  List<enums.AssetGroupInfoTarget>? defaultValue,
]) {
  if (assetGroupInfoTarget == null) {
    return defaultValue;
  }

  return assetGroupInfoTarget
      .map((e) => assetGroupInfoTargetFromJson(e.toString()))
      .toList();
}

String? assetGroupTargetNullableToJson(
    enums.AssetGroupTarget? assetGroupTarget) {
  return assetGroupTarget?.value;
}

String? assetGroupTargetToJson(enums.AssetGroupTarget assetGroupTarget) {
  return assetGroupTarget.value;
}

enums.AssetGroupTarget assetGroupTargetFromJson(
  Object? assetGroupTarget, [
  enums.AssetGroupTarget? defaultValue,
]) {
  return enums.AssetGroupTarget.values
          .firstWhereOrNull((e) => e.value == assetGroupTarget) ??
      defaultValue ??
      enums.AssetGroupTarget.swaggerGeneratedUnknown;
}

enums.AssetGroupTarget? assetGroupTargetNullableFromJson(
  Object? assetGroupTarget, [
  enums.AssetGroupTarget? defaultValue,
]) {
  if (assetGroupTarget == null) {
    return null;
  }
  return enums.AssetGroupTarget.values
          .firstWhereOrNull((e) => e.value == assetGroupTarget) ??
      defaultValue;
}

String assetGroupTargetExplodedListToJson(
    List<enums.AssetGroupTarget>? assetGroupTarget) {
  return assetGroupTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> assetGroupTargetListToJson(
    List<enums.AssetGroupTarget>? assetGroupTarget) {
  if (assetGroupTarget == null) {
    return [];
  }

  return assetGroupTarget.map((e) => e.value!).toList();
}

List<enums.AssetGroupTarget> assetGroupTargetListFromJson(
  List? assetGroupTarget, [
  List<enums.AssetGroupTarget>? defaultValue,
]) {
  if (assetGroupTarget == null) {
    return defaultValue ?? [];
  }

  return assetGroupTarget
      .map((e) => assetGroupTargetFromJson(e.toString()))
      .toList();
}

List<enums.AssetGroupTarget>? assetGroupTargetNullableListFromJson(
  List? assetGroupTarget, [
  List<enums.AssetGroupTarget>? defaultValue,
]) {
  if (assetGroupTarget == null) {
    return defaultValue;
  }

  return assetGroupTarget
      .map((e) => assetGroupTargetFromJson(e.toString()))
      .toList();
}

String? fieldFilterInfoFieldTypeNullableToJson(
    enums.FieldFilterInfoFieldType? fieldFilterInfoFieldType) {
  return fieldFilterInfoFieldType?.value;
}

String? fieldFilterInfoFieldTypeToJson(
    enums.FieldFilterInfoFieldType fieldFilterInfoFieldType) {
  return fieldFilterInfoFieldType.value;
}

enums.FieldFilterInfoFieldType fieldFilterInfoFieldTypeFromJson(
  Object? fieldFilterInfoFieldType, [
  enums.FieldFilterInfoFieldType? defaultValue,
]) {
  return enums.FieldFilterInfoFieldType.values
          .firstWhereOrNull((e) => e.value == fieldFilterInfoFieldType) ??
      defaultValue ??
      enums.FieldFilterInfoFieldType.swaggerGeneratedUnknown;
}

enums.FieldFilterInfoFieldType? fieldFilterInfoFieldTypeNullableFromJson(
  Object? fieldFilterInfoFieldType, [
  enums.FieldFilterInfoFieldType? defaultValue,
]) {
  if (fieldFilterInfoFieldType == null) {
    return null;
  }
  return enums.FieldFilterInfoFieldType.values
          .firstWhereOrNull((e) => e.value == fieldFilterInfoFieldType) ??
      defaultValue;
}

String fieldFilterInfoFieldTypeExplodedListToJson(
    List<enums.FieldFilterInfoFieldType>? fieldFilterInfoFieldType) {
  return fieldFilterInfoFieldType?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterInfoFieldTypeListToJson(
    List<enums.FieldFilterInfoFieldType>? fieldFilterInfoFieldType) {
  if (fieldFilterInfoFieldType == null) {
    return [];
  }

  return fieldFilterInfoFieldType.map((e) => e.value!).toList();
}

List<enums.FieldFilterInfoFieldType> fieldFilterInfoFieldTypeListFromJson(
  List? fieldFilterInfoFieldType, [
  List<enums.FieldFilterInfoFieldType>? defaultValue,
]) {
  if (fieldFilterInfoFieldType == null) {
    return defaultValue ?? [];
  }

  return fieldFilterInfoFieldType
      .map((e) => fieldFilterInfoFieldTypeFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterInfoFieldType>?
    fieldFilterInfoFieldTypeNullableListFromJson(
  List? fieldFilterInfoFieldType, [
  List<enums.FieldFilterInfoFieldType>? defaultValue,
]) {
  if (fieldFilterInfoFieldType == null) {
    return defaultValue;
  }

  return fieldFilterInfoFieldType
      .map((e) => fieldFilterInfoFieldTypeFromJson(e.toString()))
      .toList();
}

String? fieldFilterInfoConditionNullableToJson(
    enums.FieldFilterInfoCondition? fieldFilterInfoCondition) {
  return fieldFilterInfoCondition?.value;
}

String? fieldFilterInfoConditionToJson(
    enums.FieldFilterInfoCondition fieldFilterInfoCondition) {
  return fieldFilterInfoCondition.value;
}

enums.FieldFilterInfoCondition fieldFilterInfoConditionFromJson(
  Object? fieldFilterInfoCondition, [
  enums.FieldFilterInfoCondition? defaultValue,
]) {
  return enums.FieldFilterInfoCondition.values
          .firstWhereOrNull((e) => e.value == fieldFilterInfoCondition) ??
      defaultValue ??
      enums.FieldFilterInfoCondition.swaggerGeneratedUnknown;
}

enums.FieldFilterInfoCondition? fieldFilterInfoConditionNullableFromJson(
  Object? fieldFilterInfoCondition, [
  enums.FieldFilterInfoCondition? defaultValue,
]) {
  if (fieldFilterInfoCondition == null) {
    return null;
  }
  return enums.FieldFilterInfoCondition.values
          .firstWhereOrNull((e) => e.value == fieldFilterInfoCondition) ??
      defaultValue;
}

String fieldFilterInfoConditionExplodedListToJson(
    List<enums.FieldFilterInfoCondition>? fieldFilterInfoCondition) {
  return fieldFilterInfoCondition?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterInfoConditionListToJson(
    List<enums.FieldFilterInfoCondition>? fieldFilterInfoCondition) {
  if (fieldFilterInfoCondition == null) {
    return [];
  }

  return fieldFilterInfoCondition.map((e) => e.value!).toList();
}

List<enums.FieldFilterInfoCondition> fieldFilterInfoConditionListFromJson(
  List? fieldFilterInfoCondition, [
  List<enums.FieldFilterInfoCondition>? defaultValue,
]) {
  if (fieldFilterInfoCondition == null) {
    return defaultValue ?? [];
  }

  return fieldFilterInfoCondition
      .map((e) => fieldFilterInfoConditionFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterInfoCondition>?
    fieldFilterInfoConditionNullableListFromJson(
  List? fieldFilterInfoCondition, [
  List<enums.FieldFilterInfoCondition>? defaultValue,
]) {
  if (fieldFilterInfoCondition == null) {
    return defaultValue;
  }

  return fieldFilterInfoCondition
      .map((e) => fieldFilterInfoConditionFromJson(e.toString()))
      .toList();
}

String? fieldFilterFieldTypeNullableToJson(
    enums.FieldFilterFieldType? fieldFilterFieldType) {
  return fieldFilterFieldType?.value;
}

String? fieldFilterFieldTypeToJson(
    enums.FieldFilterFieldType fieldFilterFieldType) {
  return fieldFilterFieldType.value;
}

enums.FieldFilterFieldType fieldFilterFieldTypeFromJson(
  Object? fieldFilterFieldType, [
  enums.FieldFilterFieldType? defaultValue,
]) {
  return enums.FieldFilterFieldType.values
          .firstWhereOrNull((e) => e.value == fieldFilterFieldType) ??
      defaultValue ??
      enums.FieldFilterFieldType.swaggerGeneratedUnknown;
}

enums.FieldFilterFieldType? fieldFilterFieldTypeNullableFromJson(
  Object? fieldFilterFieldType, [
  enums.FieldFilterFieldType? defaultValue,
]) {
  if (fieldFilterFieldType == null) {
    return null;
  }
  return enums.FieldFilterFieldType.values
          .firstWhereOrNull((e) => e.value == fieldFilterFieldType) ??
      defaultValue;
}

String fieldFilterFieldTypeExplodedListToJson(
    List<enums.FieldFilterFieldType>? fieldFilterFieldType) {
  return fieldFilterFieldType?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterFieldTypeListToJson(
    List<enums.FieldFilterFieldType>? fieldFilterFieldType) {
  if (fieldFilterFieldType == null) {
    return [];
  }

  return fieldFilterFieldType.map((e) => e.value!).toList();
}

List<enums.FieldFilterFieldType> fieldFilterFieldTypeListFromJson(
  List? fieldFilterFieldType, [
  List<enums.FieldFilterFieldType>? defaultValue,
]) {
  if (fieldFilterFieldType == null) {
    return defaultValue ?? [];
  }

  return fieldFilterFieldType
      .map((e) => fieldFilterFieldTypeFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterFieldType>? fieldFilterFieldTypeNullableListFromJson(
  List? fieldFilterFieldType, [
  List<enums.FieldFilterFieldType>? defaultValue,
]) {
  if (fieldFilterFieldType == null) {
    return defaultValue;
  }

  return fieldFilterFieldType
      .map((e) => fieldFilterFieldTypeFromJson(e.toString()))
      .toList();
}

String? fieldFilterConditionNullableToJson(
    enums.FieldFilterCondition? fieldFilterCondition) {
  return fieldFilterCondition?.value;
}

String? fieldFilterConditionToJson(
    enums.FieldFilterCondition fieldFilterCondition) {
  return fieldFilterCondition.value;
}

enums.FieldFilterCondition fieldFilterConditionFromJson(
  Object? fieldFilterCondition, [
  enums.FieldFilterCondition? defaultValue,
]) {
  return enums.FieldFilterCondition.values
          .firstWhereOrNull((e) => e.value == fieldFilterCondition) ??
      defaultValue ??
      enums.FieldFilterCondition.swaggerGeneratedUnknown;
}

enums.FieldFilterCondition? fieldFilterConditionNullableFromJson(
  Object? fieldFilterCondition, [
  enums.FieldFilterCondition? defaultValue,
]) {
  if (fieldFilterCondition == null) {
    return null;
  }
  return enums.FieldFilterCondition.values
          .firstWhereOrNull((e) => e.value == fieldFilterCondition) ??
      defaultValue;
}

String fieldFilterConditionExplodedListToJson(
    List<enums.FieldFilterCondition>? fieldFilterCondition) {
  return fieldFilterCondition?.map((e) => e.value!).join(',') ?? '';
}

List<String> fieldFilterConditionListToJson(
    List<enums.FieldFilterCondition>? fieldFilterCondition) {
  if (fieldFilterCondition == null) {
    return [];
  }

  return fieldFilterCondition.map((e) => e.value!).toList();
}

List<enums.FieldFilterCondition> fieldFilterConditionListFromJson(
  List? fieldFilterCondition, [
  List<enums.FieldFilterCondition>? defaultValue,
]) {
  if (fieldFilterCondition == null) {
    return defaultValue ?? [];
  }

  return fieldFilterCondition
      .map((e) => fieldFilterConditionFromJson(e.toString()))
      .toList();
}

List<enums.FieldFilterCondition>? fieldFilterConditionNullableListFromJson(
  List? fieldFilterCondition, [
  List<enums.FieldFilterCondition>? defaultValue,
]) {
  if (fieldFilterCondition == null) {
    return defaultValue;
  }

  return fieldFilterCondition
      .map((e) => fieldFilterConditionFromJson(e.toString()))
      .toList();
}

String? ioTTwinTagsGetEntityTypeGetEntityTypeNullableToJson(
    enums.IoTTwinTagsGetEntityTypeGetEntityType?
        ioTTwinTagsGetEntityTypeGetEntityType) {
  return ioTTwinTagsGetEntityTypeGetEntityType?.value;
}

String? ioTTwinTagsGetEntityTypeGetEntityTypeToJson(
    enums.IoTTwinTagsGetEntityTypeGetEntityType
        ioTTwinTagsGetEntityTypeGetEntityType) {
  return ioTTwinTagsGetEntityTypeGetEntityType.value;
}

enums.IoTTwinTagsGetEntityTypeGetEntityType
    ioTTwinTagsGetEntityTypeGetEntityTypeFromJson(
  Object? ioTTwinTagsGetEntityTypeGetEntityType, [
  enums.IoTTwinTagsGetEntityTypeGetEntityType? defaultValue,
]) {
  return enums.IoTTwinTagsGetEntityTypeGetEntityType.values.firstWhereOrNull(
          (e) => e.value == ioTTwinTagsGetEntityTypeGetEntityType) ??
      defaultValue ??
      enums.IoTTwinTagsGetEntityTypeGetEntityType.swaggerGeneratedUnknown;
}

enums.IoTTwinTagsGetEntityTypeGetEntityType?
    ioTTwinTagsGetEntityTypeGetEntityTypeNullableFromJson(
  Object? ioTTwinTagsGetEntityTypeGetEntityType, [
  enums.IoTTwinTagsGetEntityTypeGetEntityType? defaultValue,
]) {
  if (ioTTwinTagsGetEntityTypeGetEntityType == null) {
    return null;
  }
  return enums.IoTTwinTagsGetEntityTypeGetEntityType.values.firstWhereOrNull(
          (e) => e.value == ioTTwinTagsGetEntityTypeGetEntityType) ??
      defaultValue;
}

String ioTTwinTagsGetEntityTypeGetEntityTypeExplodedListToJson(
    List<enums.IoTTwinTagsGetEntityTypeGetEntityType>?
        ioTTwinTagsGetEntityTypeGetEntityType) {
  return ioTTwinTagsGetEntityTypeGetEntityType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> ioTTwinTagsGetEntityTypeGetEntityTypeListToJson(
    List<enums.IoTTwinTagsGetEntityTypeGetEntityType>?
        ioTTwinTagsGetEntityTypeGetEntityType) {
  if (ioTTwinTagsGetEntityTypeGetEntityType == null) {
    return [];
  }

  return ioTTwinTagsGetEntityTypeGetEntityType.map((e) => e.value!).toList();
}

List<enums.IoTTwinTagsGetEntityTypeGetEntityType>
    ioTTwinTagsGetEntityTypeGetEntityTypeListFromJson(
  List? ioTTwinTagsGetEntityTypeGetEntityType, [
  List<enums.IoTTwinTagsGetEntityTypeGetEntityType>? defaultValue,
]) {
  if (ioTTwinTagsGetEntityTypeGetEntityType == null) {
    return defaultValue ?? [];
  }

  return ioTTwinTagsGetEntityTypeGetEntityType
      .map((e) => ioTTwinTagsGetEntityTypeGetEntityTypeFromJson(e.toString()))
      .toList();
}

List<enums.IoTTwinTagsGetEntityTypeGetEntityType>?
    ioTTwinTagsGetEntityTypeGetEntityTypeNullableListFromJson(
  List? ioTTwinTagsGetEntityTypeGetEntityType, [
  List<enums.IoTTwinTagsGetEntityTypeGetEntityType>? defaultValue,
]) {
  if (ioTTwinTagsGetEntityTypeGetEntityType == null) {
    return defaultValue;
  }

  return ioTTwinTagsGetEntityTypeGetEntityType
      .map((e) => ioTTwinTagsGetEntityTypeGetEntityTypeFromJson(e.toString()))
      .toList();
}

String? deviceDataTrendsDeviceIdFieldGetFilterNullableToJson(
    enums.DeviceDataTrendsDeviceIdFieldGetFilter?
        deviceDataTrendsDeviceIdFieldGetFilter) {
  return deviceDataTrendsDeviceIdFieldGetFilter?.value;
}

String? deviceDataTrendsDeviceIdFieldGetFilterToJson(
    enums.DeviceDataTrendsDeviceIdFieldGetFilter
        deviceDataTrendsDeviceIdFieldGetFilter) {
  return deviceDataTrendsDeviceIdFieldGetFilter.value;
}

enums.DeviceDataTrendsDeviceIdFieldGetFilter
    deviceDataTrendsDeviceIdFieldGetFilterFromJson(
  Object? deviceDataTrendsDeviceIdFieldGetFilter, [
  enums.DeviceDataTrendsDeviceIdFieldGetFilter? defaultValue,
]) {
  return enums.DeviceDataTrendsDeviceIdFieldGetFilter.values.firstWhereOrNull(
          (e) => e.value == deviceDataTrendsDeviceIdFieldGetFilter) ??
      defaultValue ??
      enums.DeviceDataTrendsDeviceIdFieldGetFilter.swaggerGeneratedUnknown;
}

enums.DeviceDataTrendsDeviceIdFieldGetFilter?
    deviceDataTrendsDeviceIdFieldGetFilterNullableFromJson(
  Object? deviceDataTrendsDeviceIdFieldGetFilter, [
  enums.DeviceDataTrendsDeviceIdFieldGetFilter? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetFilter == null) {
    return null;
  }
  return enums.DeviceDataTrendsDeviceIdFieldGetFilter.values.firstWhereOrNull(
          (e) => e.value == deviceDataTrendsDeviceIdFieldGetFilter) ??
      defaultValue;
}

String deviceDataTrendsDeviceIdFieldGetFilterExplodedListToJson(
    List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>?
        deviceDataTrendsDeviceIdFieldGetFilter) {
  return deviceDataTrendsDeviceIdFieldGetFilter
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> deviceDataTrendsDeviceIdFieldGetFilterListToJson(
    List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>?
        deviceDataTrendsDeviceIdFieldGetFilter) {
  if (deviceDataTrendsDeviceIdFieldGetFilter == null) {
    return [];
  }

  return deviceDataTrendsDeviceIdFieldGetFilter.map((e) => e.value!).toList();
}

List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>
    deviceDataTrendsDeviceIdFieldGetFilterListFromJson(
  List? deviceDataTrendsDeviceIdFieldGetFilter, [
  List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetFilter == null) {
    return defaultValue ?? [];
  }

  return deviceDataTrendsDeviceIdFieldGetFilter
      .map((e) => deviceDataTrendsDeviceIdFieldGetFilterFromJson(e.toString()))
      .toList();
}

List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>?
    deviceDataTrendsDeviceIdFieldGetFilterNullableListFromJson(
  List? deviceDataTrendsDeviceIdFieldGetFilter, [
  List<enums.DeviceDataTrendsDeviceIdFieldGetFilter>? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetFilter == null) {
    return defaultValue;
  }

  return deviceDataTrendsDeviceIdFieldGetFilter
      .map((e) => deviceDataTrendsDeviceIdFieldGetFilterFromJson(e.toString()))
      .toList();
}

String? deviceDataTrendsDeviceIdFieldGetIntervalNullableToJson(
    enums.DeviceDataTrendsDeviceIdFieldGetInterval?
        deviceDataTrendsDeviceIdFieldGetInterval) {
  return deviceDataTrendsDeviceIdFieldGetInterval?.value;
}

String? deviceDataTrendsDeviceIdFieldGetIntervalToJson(
    enums.DeviceDataTrendsDeviceIdFieldGetInterval
        deviceDataTrendsDeviceIdFieldGetInterval) {
  return deviceDataTrendsDeviceIdFieldGetInterval.value;
}

enums.DeviceDataTrendsDeviceIdFieldGetInterval
    deviceDataTrendsDeviceIdFieldGetIntervalFromJson(
  Object? deviceDataTrendsDeviceIdFieldGetInterval, [
  enums.DeviceDataTrendsDeviceIdFieldGetInterval? defaultValue,
]) {
  return enums.DeviceDataTrendsDeviceIdFieldGetInterval.values.firstWhereOrNull(
          (e) => e.value == deviceDataTrendsDeviceIdFieldGetInterval) ??
      defaultValue ??
      enums.DeviceDataTrendsDeviceIdFieldGetInterval.swaggerGeneratedUnknown;
}

enums.DeviceDataTrendsDeviceIdFieldGetInterval?
    deviceDataTrendsDeviceIdFieldGetIntervalNullableFromJson(
  Object? deviceDataTrendsDeviceIdFieldGetInterval, [
  enums.DeviceDataTrendsDeviceIdFieldGetInterval? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetInterval == null) {
    return null;
  }
  return enums.DeviceDataTrendsDeviceIdFieldGetInterval.values.firstWhereOrNull(
          (e) => e.value == deviceDataTrendsDeviceIdFieldGetInterval) ??
      defaultValue;
}

String deviceDataTrendsDeviceIdFieldGetIntervalExplodedListToJson(
    List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>?
        deviceDataTrendsDeviceIdFieldGetInterval) {
  return deviceDataTrendsDeviceIdFieldGetInterval
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> deviceDataTrendsDeviceIdFieldGetIntervalListToJson(
    List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>?
        deviceDataTrendsDeviceIdFieldGetInterval) {
  if (deviceDataTrendsDeviceIdFieldGetInterval == null) {
    return [];
  }

  return deviceDataTrendsDeviceIdFieldGetInterval.map((e) => e.value!).toList();
}

List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>
    deviceDataTrendsDeviceIdFieldGetIntervalListFromJson(
  List? deviceDataTrendsDeviceIdFieldGetInterval, [
  List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetInterval == null) {
    return defaultValue ?? [];
  }

  return deviceDataTrendsDeviceIdFieldGetInterval
      .map(
          (e) => deviceDataTrendsDeviceIdFieldGetIntervalFromJson(e.toString()))
      .toList();
}

List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>?
    deviceDataTrendsDeviceIdFieldGetIntervalNullableListFromJson(
  List? deviceDataTrendsDeviceIdFieldGetInterval, [
  List<enums.DeviceDataTrendsDeviceIdFieldGetInterval>? defaultValue,
]) {
  if (deviceDataTrendsDeviceIdFieldGetInterval == null) {
    return defaultValue;
  }

  return deviceDataTrendsDeviceIdFieldGetInterval
      .map(
          (e) => deviceDataTrendsDeviceIdFieldGetIntervalFromJson(e.toString()))
      .toList();
}

String? deviceDataSeriesDeviceIdFieldPageSizeGetFilterNullableToJson(
    enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter?
        deviceDataSeriesDeviceIdFieldPageSizeGetFilter) {
  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter?.value;
}

String? deviceDataSeriesDeviceIdFieldPageSizeGetFilterToJson(
    enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter
        deviceDataSeriesDeviceIdFieldPageSizeGetFilter) {
  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter.value;
}

enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter
    deviceDataSeriesDeviceIdFieldPageSizeGetFilterFromJson(
  Object? deviceDataSeriesDeviceIdFieldPageSizeGetFilter, [
  enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter? defaultValue,
]) {
  return enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter.values
          .firstWhereOrNull((e) =>
              e.value == deviceDataSeriesDeviceIdFieldPageSizeGetFilter) ??
      defaultValue ??
      enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter
          .swaggerGeneratedUnknown;
}

enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter?
    deviceDataSeriesDeviceIdFieldPageSizeGetFilterNullableFromJson(
  Object? deviceDataSeriesDeviceIdFieldPageSizeGetFilter, [
  enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter? defaultValue,
]) {
  if (deviceDataSeriesDeviceIdFieldPageSizeGetFilter == null) {
    return null;
  }
  return enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter.values
          .firstWhereOrNull((e) =>
              e.value == deviceDataSeriesDeviceIdFieldPageSizeGetFilter) ??
      defaultValue;
}

String deviceDataSeriesDeviceIdFieldPageSizeGetFilterExplodedListToJson(
    List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>?
        deviceDataSeriesDeviceIdFieldPageSizeGetFilter) {
  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> deviceDataSeriesDeviceIdFieldPageSizeGetFilterListToJson(
    List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>?
        deviceDataSeriesDeviceIdFieldPageSizeGetFilter) {
  if (deviceDataSeriesDeviceIdFieldPageSizeGetFilter == null) {
    return [];
  }

  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter
      .map((e) => e.value!)
      .toList();
}

List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>
    deviceDataSeriesDeviceIdFieldPageSizeGetFilterListFromJson(
  List? deviceDataSeriesDeviceIdFieldPageSizeGetFilter, [
  List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>? defaultValue,
]) {
  if (deviceDataSeriesDeviceIdFieldPageSizeGetFilter == null) {
    return defaultValue ?? [];
  }

  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter
      .map((e) =>
          deviceDataSeriesDeviceIdFieldPageSizeGetFilterFromJson(e.toString()))
      .toList();
}

List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>?
    deviceDataSeriesDeviceIdFieldPageSizeGetFilterNullableListFromJson(
  List? deviceDataSeriesDeviceIdFieldPageSizeGetFilter, [
  List<enums.DeviceDataSeriesDeviceIdFieldPageSizeGetFilter>? defaultValue,
]) {
  if (deviceDataSeriesDeviceIdFieldPageSizeGetFilter == null) {
    return defaultValue;
  }

  return deviceDataSeriesDeviceIdFieldPageSizeGetFilter
      .map((e) =>
          deviceDataSeriesDeviceIdFieldPageSizeGetFilterFromJson(e.toString()))
      .toList();
}

String? screenWidgetListTargetPostTargetNullableToJson(
    enums.ScreenWidgetListTargetPostTarget? screenWidgetListTargetPostTarget) {
  return screenWidgetListTargetPostTarget?.value;
}

String? screenWidgetListTargetPostTargetToJson(
    enums.ScreenWidgetListTargetPostTarget screenWidgetListTargetPostTarget) {
  return screenWidgetListTargetPostTarget.value;
}

enums.ScreenWidgetListTargetPostTarget screenWidgetListTargetPostTargetFromJson(
  Object? screenWidgetListTargetPostTarget, [
  enums.ScreenWidgetListTargetPostTarget? defaultValue,
]) {
  return enums.ScreenWidgetListTargetPostTarget.values.firstWhereOrNull(
          (e) => e.value == screenWidgetListTargetPostTarget) ??
      defaultValue ??
      enums.ScreenWidgetListTargetPostTarget.swaggerGeneratedUnknown;
}

enums.ScreenWidgetListTargetPostTarget?
    screenWidgetListTargetPostTargetNullableFromJson(
  Object? screenWidgetListTargetPostTarget, [
  enums.ScreenWidgetListTargetPostTarget? defaultValue,
]) {
  if (screenWidgetListTargetPostTarget == null) {
    return null;
  }
  return enums.ScreenWidgetListTargetPostTarget.values.firstWhereOrNull(
          (e) => e.value == screenWidgetListTargetPostTarget) ??
      defaultValue;
}

String screenWidgetListTargetPostTargetExplodedListToJson(
    List<enums.ScreenWidgetListTargetPostTarget>?
        screenWidgetListTargetPostTarget) {
  return screenWidgetListTargetPostTarget?.map((e) => e.value!).join(',') ?? '';
}

List<String> screenWidgetListTargetPostTargetListToJson(
    List<enums.ScreenWidgetListTargetPostTarget>?
        screenWidgetListTargetPostTarget) {
  if (screenWidgetListTargetPostTarget == null) {
    return [];
  }

  return screenWidgetListTargetPostTarget.map((e) => e.value!).toList();
}

List<enums.ScreenWidgetListTargetPostTarget>
    screenWidgetListTargetPostTargetListFromJson(
  List? screenWidgetListTargetPostTarget, [
  List<enums.ScreenWidgetListTargetPostTarget>? defaultValue,
]) {
  if (screenWidgetListTargetPostTarget == null) {
    return defaultValue ?? [];
  }

  return screenWidgetListTargetPostTarget
      .map((e) => screenWidgetListTargetPostTargetFromJson(e.toString()))
      .toList();
}

List<enums.ScreenWidgetListTargetPostTarget>?
    screenWidgetListTargetPostTargetNullableListFromJson(
  List? screenWidgetListTargetPostTarget, [
  List<enums.ScreenWidgetListTargetPostTarget>? defaultValue,
]) {
  if (screenWidgetListTargetPostTarget == null) {
    return defaultValue;
  }

  return screenWidgetListTargetPostTarget
      .map((e) => screenWidgetListTargetPostTargetFromJson(e.toString()))
      .toList();
}

String? screenWidgetSearchTargetPostTargetNullableToJson(
    enums.ScreenWidgetSearchTargetPostTarget?
        screenWidgetSearchTargetPostTarget) {
  return screenWidgetSearchTargetPostTarget?.value;
}

String? screenWidgetSearchTargetPostTargetToJson(
    enums.ScreenWidgetSearchTargetPostTarget
        screenWidgetSearchTargetPostTarget) {
  return screenWidgetSearchTargetPostTarget.value;
}

enums.ScreenWidgetSearchTargetPostTarget
    screenWidgetSearchTargetPostTargetFromJson(
  Object? screenWidgetSearchTargetPostTarget, [
  enums.ScreenWidgetSearchTargetPostTarget? defaultValue,
]) {
  return enums.ScreenWidgetSearchTargetPostTarget.values.firstWhereOrNull(
          (e) => e.value == screenWidgetSearchTargetPostTarget) ??
      defaultValue ??
      enums.ScreenWidgetSearchTargetPostTarget.swaggerGeneratedUnknown;
}

enums.ScreenWidgetSearchTargetPostTarget?
    screenWidgetSearchTargetPostTargetNullableFromJson(
  Object? screenWidgetSearchTargetPostTarget, [
  enums.ScreenWidgetSearchTargetPostTarget? defaultValue,
]) {
  if (screenWidgetSearchTargetPostTarget == null) {
    return null;
  }
  return enums.ScreenWidgetSearchTargetPostTarget.values.firstWhereOrNull(
          (e) => e.value == screenWidgetSearchTargetPostTarget) ??
      defaultValue;
}

String screenWidgetSearchTargetPostTargetExplodedListToJson(
    List<enums.ScreenWidgetSearchTargetPostTarget>?
        screenWidgetSearchTargetPostTarget) {
  return screenWidgetSearchTargetPostTarget?.map((e) => e.value!).join(',') ??
      '';
}

List<String> screenWidgetSearchTargetPostTargetListToJson(
    List<enums.ScreenWidgetSearchTargetPostTarget>?
        screenWidgetSearchTargetPostTarget) {
  if (screenWidgetSearchTargetPostTarget == null) {
    return [];
  }

  return screenWidgetSearchTargetPostTarget.map((e) => e.value!).toList();
}

List<enums.ScreenWidgetSearchTargetPostTarget>
    screenWidgetSearchTargetPostTargetListFromJson(
  List? screenWidgetSearchTargetPostTarget, [
  List<enums.ScreenWidgetSearchTargetPostTarget>? defaultValue,
]) {
  if (screenWidgetSearchTargetPostTarget == null) {
    return defaultValue ?? [];
  }

  return screenWidgetSearchTargetPostTarget
      .map((e) => screenWidgetSearchTargetPostTargetFromJson(e.toString()))
      .toList();
}

List<enums.ScreenWidgetSearchTargetPostTarget>?
    screenWidgetSearchTargetPostTargetNullableListFromJson(
  List? screenWidgetSearchTargetPostTarget, [
  List<enums.ScreenWidgetSearchTargetPostTarget>? defaultValue,
]) {
  if (screenWidgetSearchTargetPostTarget == null) {
    return defaultValue;
  }

  return screenWidgetSearchTargetPostTarget
      .map((e) => screenWidgetSearchTargetPostTargetFromJson(e.toString()))
      .toList();
}

String? twinImageUploadModelImageTypeModelIdPostImageTypeNullableToJson(
    enums.TwinImageUploadModelImageTypeModelIdPostImageType?
        twinImageUploadModelImageTypeModelIdPostImageType) {
  return twinImageUploadModelImageTypeModelIdPostImageType?.value;
}

String? twinImageUploadModelImageTypeModelIdPostImageTypeToJson(
    enums.TwinImageUploadModelImageTypeModelIdPostImageType
        twinImageUploadModelImageTypeModelIdPostImageType) {
  return twinImageUploadModelImageTypeModelIdPostImageType.value;
}

enums.TwinImageUploadModelImageTypeModelIdPostImageType
    twinImageUploadModelImageTypeModelIdPostImageTypeFromJson(
  Object? twinImageUploadModelImageTypeModelIdPostImageType, [
  enums.TwinImageUploadModelImageTypeModelIdPostImageType? defaultValue,
]) {
  return enums.TwinImageUploadModelImageTypeModelIdPostImageType.values
          .firstWhereOrNull((e) =>
              e.value == twinImageUploadModelImageTypeModelIdPostImageType) ??
      defaultValue ??
      enums.TwinImageUploadModelImageTypeModelIdPostImageType
          .swaggerGeneratedUnknown;
}

enums.TwinImageUploadModelImageTypeModelIdPostImageType?
    twinImageUploadModelImageTypeModelIdPostImageTypeNullableFromJson(
  Object? twinImageUploadModelImageTypeModelIdPostImageType, [
  enums.TwinImageUploadModelImageTypeModelIdPostImageType? defaultValue,
]) {
  if (twinImageUploadModelImageTypeModelIdPostImageType == null) {
    return null;
  }
  return enums.TwinImageUploadModelImageTypeModelIdPostImageType.values
          .firstWhereOrNull((e) =>
              e.value == twinImageUploadModelImageTypeModelIdPostImageType) ??
      defaultValue;
}

String twinImageUploadModelImageTypeModelIdPostImageTypeExplodedListToJson(
    List<enums.TwinImageUploadModelImageTypeModelIdPostImageType>?
        twinImageUploadModelImageTypeModelIdPostImageType) {
  return twinImageUploadModelImageTypeModelIdPostImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> twinImageUploadModelImageTypeModelIdPostImageTypeListToJson(
    List<enums.TwinImageUploadModelImageTypeModelIdPostImageType>?
        twinImageUploadModelImageTypeModelIdPostImageType) {
  if (twinImageUploadModelImageTypeModelIdPostImageType == null) {
    return [];
  }

  return twinImageUploadModelImageTypeModelIdPostImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.TwinImageUploadModelImageTypeModelIdPostImageType>
    twinImageUploadModelImageTypeModelIdPostImageTypeListFromJson(
  List? twinImageUploadModelImageTypeModelIdPostImageType, [
  List<enums.TwinImageUploadModelImageTypeModelIdPostImageType>? defaultValue,
]) {
  if (twinImageUploadModelImageTypeModelIdPostImageType == null) {
    return defaultValue ?? [];
  }

  return twinImageUploadModelImageTypeModelIdPostImageType
      .map((e) => twinImageUploadModelImageTypeModelIdPostImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.TwinImageUploadModelImageTypeModelIdPostImageType>?
    twinImageUploadModelImageTypeModelIdPostImageTypeNullableListFromJson(
  List? twinImageUploadModelImageTypeModelIdPostImageType, [
  List<enums.TwinImageUploadModelImageTypeModelIdPostImageType>? defaultValue,
]) {
  if (twinImageUploadModelImageTypeModelIdPostImageType == null) {
    return defaultValue;
  }

  return twinImageUploadModelImageTypeModelIdPostImageType
      .map((e) => twinImageUploadModelImageTypeModelIdPostImageTypeFromJson(
          e.toString()))
      .toList();
}

String? twinImageUploadAlarmImageTypeAlarmIdPostImageTypeNullableToJson(
    enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType?
        twinImageUploadAlarmImageTypeAlarmIdPostImageType) {
  return twinImageUploadAlarmImageTypeAlarmIdPostImageType?.value;
}

String? twinImageUploadAlarmImageTypeAlarmIdPostImageTypeToJson(
    enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType
        twinImageUploadAlarmImageTypeAlarmIdPostImageType) {
  return twinImageUploadAlarmImageTypeAlarmIdPostImageType.value;
}

enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType
    twinImageUploadAlarmImageTypeAlarmIdPostImageTypeFromJson(
  Object? twinImageUploadAlarmImageTypeAlarmIdPostImageType, [
  enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType? defaultValue,
]) {
  return enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType.values
          .firstWhereOrNull((e) =>
              e.value == twinImageUploadAlarmImageTypeAlarmIdPostImageType) ??
      defaultValue ??
      enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType
          .swaggerGeneratedUnknown;
}

enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType?
    twinImageUploadAlarmImageTypeAlarmIdPostImageTypeNullableFromJson(
  Object? twinImageUploadAlarmImageTypeAlarmIdPostImageType, [
  enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType? defaultValue,
]) {
  if (twinImageUploadAlarmImageTypeAlarmIdPostImageType == null) {
    return null;
  }
  return enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType.values
          .firstWhereOrNull((e) =>
              e.value == twinImageUploadAlarmImageTypeAlarmIdPostImageType) ??
      defaultValue;
}

String twinImageUploadAlarmImageTypeAlarmIdPostImageTypeExplodedListToJson(
    List<enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType>?
        twinImageUploadAlarmImageTypeAlarmIdPostImageType) {
  return twinImageUploadAlarmImageTypeAlarmIdPostImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> twinImageUploadAlarmImageTypeAlarmIdPostImageTypeListToJson(
    List<enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType>?
        twinImageUploadAlarmImageTypeAlarmIdPostImageType) {
  if (twinImageUploadAlarmImageTypeAlarmIdPostImageType == null) {
    return [];
  }

  return twinImageUploadAlarmImageTypeAlarmIdPostImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType>
    twinImageUploadAlarmImageTypeAlarmIdPostImageTypeListFromJson(
  List? twinImageUploadAlarmImageTypeAlarmIdPostImageType, [
  List<enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType>? defaultValue,
]) {
  if (twinImageUploadAlarmImageTypeAlarmIdPostImageType == null) {
    return defaultValue ?? [];
  }

  return twinImageUploadAlarmImageTypeAlarmIdPostImageType
      .map((e) => twinImageUploadAlarmImageTypeAlarmIdPostImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType>?
    twinImageUploadAlarmImageTypeAlarmIdPostImageTypeNullableListFromJson(
  List? twinImageUploadAlarmImageTypeAlarmIdPostImageType, [
  List<enums.TwinImageUploadAlarmImageTypeAlarmIdPostImageType>? defaultValue,
]) {
  if (twinImageUploadAlarmImageTypeAlarmIdPostImageType == null) {
    return defaultValue;
  }

  return twinImageUploadAlarmImageTypeAlarmIdPostImageType
      .map((e) => twinImageUploadAlarmImageTypeAlarmIdPostImageTypeFromJson(
          e.toString()))
      .toList();
}

String? twinImageUploadDeviceImageTypeDeviceIdPostImageTypeNullableToJson(
    enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType?
        twinImageUploadDeviceImageTypeDeviceIdPostImageType) {
  return twinImageUploadDeviceImageTypeDeviceIdPostImageType?.value;
}

String? twinImageUploadDeviceImageTypeDeviceIdPostImageTypeToJson(
    enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType
        twinImageUploadDeviceImageTypeDeviceIdPostImageType) {
  return twinImageUploadDeviceImageTypeDeviceIdPostImageType.value;
}

enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType
    twinImageUploadDeviceImageTypeDeviceIdPostImageTypeFromJson(
  Object? twinImageUploadDeviceImageTypeDeviceIdPostImageType, [
  enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType? defaultValue,
]) {
  return enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType.values
          .firstWhereOrNull((e) =>
              e.value == twinImageUploadDeviceImageTypeDeviceIdPostImageType) ??
      defaultValue ??
      enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType
          .swaggerGeneratedUnknown;
}

enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType?
    twinImageUploadDeviceImageTypeDeviceIdPostImageTypeNullableFromJson(
  Object? twinImageUploadDeviceImageTypeDeviceIdPostImageType, [
  enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType? defaultValue,
]) {
  if (twinImageUploadDeviceImageTypeDeviceIdPostImageType == null) {
    return null;
  }
  return enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType.values
          .firstWhereOrNull((e) =>
              e.value == twinImageUploadDeviceImageTypeDeviceIdPostImageType) ??
      defaultValue;
}

String twinImageUploadDeviceImageTypeDeviceIdPostImageTypeExplodedListToJson(
    List<enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType>?
        twinImageUploadDeviceImageTypeDeviceIdPostImageType) {
  return twinImageUploadDeviceImageTypeDeviceIdPostImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> twinImageUploadDeviceImageTypeDeviceIdPostImageTypeListToJson(
    List<enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType>?
        twinImageUploadDeviceImageTypeDeviceIdPostImageType) {
  if (twinImageUploadDeviceImageTypeDeviceIdPostImageType == null) {
    return [];
  }

  return twinImageUploadDeviceImageTypeDeviceIdPostImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType>
    twinImageUploadDeviceImageTypeDeviceIdPostImageTypeListFromJson(
  List? twinImageUploadDeviceImageTypeDeviceIdPostImageType, [
  List<enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType>? defaultValue,
]) {
  if (twinImageUploadDeviceImageTypeDeviceIdPostImageType == null) {
    return defaultValue ?? [];
  }

  return twinImageUploadDeviceImageTypeDeviceIdPostImageType
      .map((e) => twinImageUploadDeviceImageTypeDeviceIdPostImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType>?
    twinImageUploadDeviceImageTypeDeviceIdPostImageTypeNullableListFromJson(
  List? twinImageUploadDeviceImageTypeDeviceIdPostImageType, [
  List<enums.TwinImageUploadDeviceImageTypeDeviceIdPostImageType>? defaultValue,
]) {
  if (twinImageUploadDeviceImageTypeDeviceIdPostImageType == null) {
    return defaultValue;
  }

  return twinImageUploadDeviceImageTypeDeviceIdPostImageType
      .map((e) => twinImageUploadDeviceImageTypeDeviceIdPostImageTypeFromJson(
          e.toString()))
      .toList();
}

String? twinImageUploadDomainImageTypePostImageTypeNullableToJson(
    enums.TwinImageUploadDomainImageTypePostImageType?
        twinImageUploadDomainImageTypePostImageType) {
  return twinImageUploadDomainImageTypePostImageType?.value;
}

String? twinImageUploadDomainImageTypePostImageTypeToJson(
    enums.TwinImageUploadDomainImageTypePostImageType
        twinImageUploadDomainImageTypePostImageType) {
  return twinImageUploadDomainImageTypePostImageType.value;
}

enums.TwinImageUploadDomainImageTypePostImageType
    twinImageUploadDomainImageTypePostImageTypeFromJson(
  Object? twinImageUploadDomainImageTypePostImageType, [
  enums.TwinImageUploadDomainImageTypePostImageType? defaultValue,
]) {
  return enums.TwinImageUploadDomainImageTypePostImageType.values
          .firstWhereOrNull(
              (e) => e.value == twinImageUploadDomainImageTypePostImageType) ??
      defaultValue ??
      enums.TwinImageUploadDomainImageTypePostImageType.swaggerGeneratedUnknown;
}

enums.TwinImageUploadDomainImageTypePostImageType?
    twinImageUploadDomainImageTypePostImageTypeNullableFromJson(
  Object? twinImageUploadDomainImageTypePostImageType, [
  enums.TwinImageUploadDomainImageTypePostImageType? defaultValue,
]) {
  if (twinImageUploadDomainImageTypePostImageType == null) {
    return null;
  }
  return enums.TwinImageUploadDomainImageTypePostImageType.values
          .firstWhereOrNull(
              (e) => e.value == twinImageUploadDomainImageTypePostImageType) ??
      defaultValue;
}

String twinImageUploadDomainImageTypePostImageTypeExplodedListToJson(
    List<enums.TwinImageUploadDomainImageTypePostImageType>?
        twinImageUploadDomainImageTypePostImageType) {
  return twinImageUploadDomainImageTypePostImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> twinImageUploadDomainImageTypePostImageTypeListToJson(
    List<enums.TwinImageUploadDomainImageTypePostImageType>?
        twinImageUploadDomainImageTypePostImageType) {
  if (twinImageUploadDomainImageTypePostImageType == null) {
    return [];
  }

  return twinImageUploadDomainImageTypePostImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.TwinImageUploadDomainImageTypePostImageType>
    twinImageUploadDomainImageTypePostImageTypeListFromJson(
  List? twinImageUploadDomainImageTypePostImageType, [
  List<enums.TwinImageUploadDomainImageTypePostImageType>? defaultValue,
]) {
  if (twinImageUploadDomainImageTypePostImageType == null) {
    return defaultValue ?? [];
  }

  return twinImageUploadDomainImageTypePostImageType
      .map((e) =>
          twinImageUploadDomainImageTypePostImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.TwinImageUploadDomainImageTypePostImageType>?
    twinImageUploadDomainImageTypePostImageTypeNullableListFromJson(
  List? twinImageUploadDomainImageTypePostImageType, [
  List<enums.TwinImageUploadDomainImageTypePostImageType>? defaultValue,
]) {
  if (twinImageUploadDomainImageTypePostImageType == null) {
    return defaultValue;
  }

  return twinImageUploadDomainImageTypePostImageType
      .map((e) =>
          twinImageUploadDomainImageTypePostImageTypeFromJson(e.toString()))
      .toList();
}

String? twinImageSearchImageTypePostImageTypeNullableToJson(
    enums.TwinImageSearchImageTypePostImageType?
        twinImageSearchImageTypePostImageType) {
  return twinImageSearchImageTypePostImageType?.value;
}

String? twinImageSearchImageTypePostImageTypeToJson(
    enums.TwinImageSearchImageTypePostImageType
        twinImageSearchImageTypePostImageType) {
  return twinImageSearchImageTypePostImageType.value;
}

enums.TwinImageSearchImageTypePostImageType
    twinImageSearchImageTypePostImageTypeFromJson(
  Object? twinImageSearchImageTypePostImageType, [
  enums.TwinImageSearchImageTypePostImageType? defaultValue,
]) {
  return enums.TwinImageSearchImageTypePostImageType.values.firstWhereOrNull(
          (e) => e.value == twinImageSearchImageTypePostImageType) ??
      defaultValue ??
      enums.TwinImageSearchImageTypePostImageType.swaggerGeneratedUnknown;
}

enums.TwinImageSearchImageTypePostImageType?
    twinImageSearchImageTypePostImageTypeNullableFromJson(
  Object? twinImageSearchImageTypePostImageType, [
  enums.TwinImageSearchImageTypePostImageType? defaultValue,
]) {
  if (twinImageSearchImageTypePostImageType == null) {
    return null;
  }
  return enums.TwinImageSearchImageTypePostImageType.values.firstWhereOrNull(
          (e) => e.value == twinImageSearchImageTypePostImageType) ??
      defaultValue;
}

String twinImageSearchImageTypePostImageTypeExplodedListToJson(
    List<enums.TwinImageSearchImageTypePostImageType>?
        twinImageSearchImageTypePostImageType) {
  return twinImageSearchImageTypePostImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> twinImageSearchImageTypePostImageTypeListToJson(
    List<enums.TwinImageSearchImageTypePostImageType>?
        twinImageSearchImageTypePostImageType) {
  if (twinImageSearchImageTypePostImageType == null) {
    return [];
  }

  return twinImageSearchImageTypePostImageType.map((e) => e.value!).toList();
}

List<enums.TwinImageSearchImageTypePostImageType>
    twinImageSearchImageTypePostImageTypeListFromJson(
  List? twinImageSearchImageTypePostImageType, [
  List<enums.TwinImageSearchImageTypePostImageType>? defaultValue,
]) {
  if (twinImageSearchImageTypePostImageType == null) {
    return defaultValue ?? [];
  }

  return twinImageSearchImageTypePostImageType
      .map((e) => twinImageSearchImageTypePostImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.TwinImageSearchImageTypePostImageType>?
    twinImageSearchImageTypePostImageTypeNullableListFromJson(
  List? twinImageSearchImageTypePostImageType, [
  List<enums.TwinImageSearchImageTypePostImageType>? defaultValue,
]) {
  if (twinImageSearchImageTypePostImageType == null) {
    return defaultValue;
  }

  return twinImageSearchImageTypePostImageType
      .map((e) => twinImageSearchImageTypePostImageTypeFromJson(e.toString()))
      .toList();
}

String? twinImageListImageTypePostImageTypeNullableToJson(
    enums.TwinImageListImageTypePostImageType?
        twinImageListImageTypePostImageType) {
  return twinImageListImageTypePostImageType?.value;
}

String? twinImageListImageTypePostImageTypeToJson(
    enums.TwinImageListImageTypePostImageType
        twinImageListImageTypePostImageType) {
  return twinImageListImageTypePostImageType.value;
}

enums.TwinImageListImageTypePostImageType
    twinImageListImageTypePostImageTypeFromJson(
  Object? twinImageListImageTypePostImageType, [
  enums.TwinImageListImageTypePostImageType? defaultValue,
]) {
  return enums.TwinImageListImageTypePostImageType.values.firstWhereOrNull(
          (e) => e.value == twinImageListImageTypePostImageType) ??
      defaultValue ??
      enums.TwinImageListImageTypePostImageType.swaggerGeneratedUnknown;
}

enums.TwinImageListImageTypePostImageType?
    twinImageListImageTypePostImageTypeNullableFromJson(
  Object? twinImageListImageTypePostImageType, [
  enums.TwinImageListImageTypePostImageType? defaultValue,
]) {
  if (twinImageListImageTypePostImageType == null) {
    return null;
  }
  return enums.TwinImageListImageTypePostImageType.values.firstWhereOrNull(
          (e) => e.value == twinImageListImageTypePostImageType) ??
      defaultValue;
}

String twinImageListImageTypePostImageTypeExplodedListToJson(
    List<enums.TwinImageListImageTypePostImageType>?
        twinImageListImageTypePostImageType) {
  return twinImageListImageTypePostImageType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> twinImageListImageTypePostImageTypeListToJson(
    List<enums.TwinImageListImageTypePostImageType>?
        twinImageListImageTypePostImageType) {
  if (twinImageListImageTypePostImageType == null) {
    return [];
  }

  return twinImageListImageTypePostImageType.map((e) => e.value!).toList();
}

List<enums.TwinImageListImageTypePostImageType>
    twinImageListImageTypePostImageTypeListFromJson(
  List? twinImageListImageTypePostImageType, [
  List<enums.TwinImageListImageTypePostImageType>? defaultValue,
]) {
  if (twinImageListImageTypePostImageType == null) {
    return defaultValue ?? [];
  }

  return twinImageListImageTypePostImageType
      .map((e) => twinImageListImageTypePostImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.TwinImageListImageTypePostImageType>?
    twinImageListImageTypePostImageTypeNullableListFromJson(
  List? twinImageListImageTypePostImageType, [
  List<enums.TwinImageListImageTypePostImageType>? defaultValue,
]) {
  if (twinImageListImageTypePostImageType == null) {
    return defaultValue;
  }

  return twinImageListImageTypePostImageType
      .map((e) => twinImageListImageTypePostImageTypeFromJson(e.toString()))
      .toList();
}

typedef $JsonFactory<T> = T Function(Map<String, dynamic> json);

class $CustomJsonDecoder {
  $CustomJsonDecoder(this.factories);

  final Map<Type, $JsonFactory> factories;

  dynamic decode<T>(dynamic entity) {
    if (entity is Iterable) {
      return _decodeList<T>(entity);
    }

    if (entity is T) {
      return entity;
    }

    if (isTypeOf<T, Map>()) {
      return entity;
    }

    if (isTypeOf<T, Iterable>()) {
      return entity;
    }

    if (entity is Map<String, dynamic>) {
      return _decodeMap<T>(entity);
    }

    return entity;
  }

  T _decodeMap<T>(Map<String, dynamic> values) {
    final jsonFactory = factories[T];
    if (jsonFactory == null || jsonFactory is! $JsonFactory<T>) {
      return throw "Could not find factory for type $T. Is '$T: $T.fromJsonFactory' included in the CustomJsonDecoder instance creation in bootstrapper.dart?";
    }

    return jsonFactory(values);
  }

  List<T> _decodeList<T>(Iterable values) =>
      values.where((v) => v != null).map<T>((v) => decode<T>(v) as T).toList();
}

class $JsonSerializableConverter extends chopper.JsonConverter {
  @override
  FutureOr<chopper.Response<ResultType>> convertResponse<ResultType, Item>(
      chopper.Response response) async {
    if (response.bodyString.isEmpty) {
      // In rare cases, when let's say 204 (no content) is returned -
      // we cannot decode the missing json with the result type specified
      return chopper.Response(response.base, null, error: response.error);
    }

    if (ResultType == String) {
      return response.copyWith();
    }

    if (ResultType == DateTime) {
      return response.copyWith(
          body: DateTime.parse((response.body as String).replaceAll('"', ''))
              as ResultType);
    }

    final jsonRes = await super.convertResponse(response);
    return jsonRes.copyWith<ResultType>(
        body: $jsonDecoder.decode<Item>(jsonRes.body) as ResultType);
  }
}

final $jsonDecoder = $CustomJsonDecoder(generatedMapping);

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
